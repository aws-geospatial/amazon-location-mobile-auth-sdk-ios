//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GeoRoutesClientTypes {

    /// The input fails to satisfy the constraints specified by the Amazon Location service.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The error message.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the resource.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension GeoRoutesClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The input cannot be parsed. For example a required JSON document, ARN identifier, date value, or numeric field cannot be parsed.
        case cannotparse
        /// The input is present and parsable, but it is otherwise invalid. For example, a required numeric argument is outside the allowed range.
        case fieldvalidationfailed
        /// The required input is missing.
        case missing
        /// The input is invalid but no more specific reason is applicable.
        case other
        /// No such field is supported.
        case unknownfield
        /// No such operation is supported.
        case unknownoperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotparse,
                .fieldvalidationfailed,
                .missing,
                .other,
                .unknownfield,
                .unknownoperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotparse: return "CannotParse"
            case .fieldvalidationfailed: return "FieldValidationFailed"
            case .missing: return "Missing"
            case .other: return "Other"
            case .unknownfield: return "UnknownField"
            case .unknownoperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var fieldList: [GeoRoutesClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// This member is required.
        public internal(set) var reason: GeoRoutesClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [GeoRoutesClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: GeoRoutesClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension GeoRoutesClientTypes {

    /// Features that are allowed while calculation.
    public struct IsolineAllowOptions: Swift.Sendable {
        /// Allow Hot (High Occupancy Toll) lanes for calculation.
        public var hot: Swift.Bool?
        /// Allow Hov (High Occupancy vehicle) lanes for calculation.
        public var hov: Swift.Bool?

        public init(
            hot: Swift.Bool? = nil,
            hov: Swift.Bool? = nil
        )
        {
            self.hot = hot
            self.hov = hov
        }
    }
}

extension GeoRoutesClientTypes {

    /// Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.
    public struct Corridor: Swift.Sendable {
        /// An ordered list of positions used to plot a route on a map. LineString and Polyline are mutually exclusive properties.
        /// This member is required.
        public var lineString: [[Swift.Double]]?
        /// Radius that defines the width of the corridor.
        /// This member is required.
        public var radius: Swift.Int?

        public init(
            lineString: [[Swift.Double]]? = nil,
            radius: Swift.Int? = nil
        )
        {
            self.lineString = lineString
            self.radius = radius
        }
    }
}

extension GeoRoutesClientTypes.Corridor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension GeoRoutesClientTypes {

    /// Geometry defined as an encoded corridor - an encoded polyloine with a radius that defines the width of the corridor.
    public struct PolylineCorridor: Swift.Sendable {
        /// An ordered list of positions used to plot a route on a map in a lossy compression format. LineString and Polyline are mutually exclusive properties.
        /// This member is required.
        public var polyline: Swift.String?
        /// Considers all roads within the provided radius to match the provided destination to. The roads that are considered are determined by the provided Strategy. Unit: Meters
        /// This member is required.
        public var radius: Swift.Int?

        public init(
            polyline: Swift.String? = nil,
            radius: Swift.Int? = nil
        )
        {
            self.polyline = polyline
            self.radius = radius
        }
    }
}

extension GeoRoutesClientTypes.PolylineCorridor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension GeoRoutesClientTypes {

    /// The avoidance geometry, to be included for calculation.
    public struct IsolineAvoidanceAreaGeometry: Swift.Sendable {
        /// Gometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public var boundingBox: [Swift.Double]?
        /// Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.
        public var corridor: GeoRoutesClientTypes.Corridor?
        /// A list of Polygon will be excluded for calculating isolines, the list can only contain 1 polygon.
        public var polygon: [[[Swift.Double]]]?
        /// Geometry defined as an encoded corridor â€“ a polyline with a radius that defines the width of the corridor. For more information on polyline encoding, see [https://github.com/heremaps/flexiblepolyline/blob/master/README.md](https://github.com/heremaps/flexiblepolyline/blob/master/README.md).
        public var polylineCorridor: GeoRoutesClientTypes.PolylineCorridor?
        /// A list of PolylinePolygon's that are excluded for calculating isolines, the list can only contain 1 polygon. For more information on polyline encoding, see [https://github.com/heremaps/flexiblepolyline/blob/master/README.md](https://github.com/heremaps/flexiblepolyline/blob/master/README.md).
        public var polylinePolygon: [Swift.String]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            corridor: GeoRoutesClientTypes.Corridor? = nil,
            polygon: [[[Swift.Double]]]? = nil,
            polylineCorridor: GeoRoutesClientTypes.PolylineCorridor? = nil,
            polylinePolygon: [Swift.String]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.corridor = corridor
            self.polygon = polygon
            self.polylineCorridor = polylineCorridor
            self.polylinePolygon = polylinePolygon
        }
    }
}

extension GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsolineAvoidanceAreaGeometry(boundingBox: \"CONTENT_REDACTED\", corridor: \"CONTENT_REDACTED\", polygon: \"CONTENT_REDACTED\", polylineCorridor: \"CONTENT_REDACTED\", polylinePolygon: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// The area to be avoided.
    public struct IsolineAvoidanceArea: Swift.Sendable {
        /// Exceptions to the provided avoidance geometry, to be included for calculation.
        public var except: [GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry]?
        /// Geometry of the area to be avoided.
        /// This member is required.
        public var geometry: GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry?

        public init(
            except: [GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry]? = nil,
            geometry: GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry? = nil
        )
        {
            self.except = except
            self.geometry = geometry
        }
    }
}

extension GeoRoutesClientTypes {

    public enum IsolineZoneCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case congestionPricing
        case environmental
        case vignette
        case sdkUnknown(Swift.String)

        public static var allCases: [IsolineZoneCategory] {
            return [
                .congestionPricing,
                .environmental,
                .vignette
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .congestionPricing: return "CongestionPricing"
            case .environmental: return "Environmental"
            case .vignette: return "Vignette"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Zone category to be avoided.
    public struct IsolineAvoidanceZoneCategory: Swift.Sendable {
        /// Zone category to be avoided.
        public var category: GeoRoutesClientTypes.IsolineZoneCategory?

        public init(
            category: GeoRoutesClientTypes.IsolineZoneCategory? = nil
        )
        {
            self.category = category
        }
    }
}

extension GeoRoutesClientTypes {

    /// Features that are avoided while calculation. Avoidance is on a best-case basis.If an avoidance cannot be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.
    public struct IsolineAvoidanceOptions: Swift.Sendable {
        /// Areas to be avoided.
        public var areas: [GeoRoutesClientTypes.IsolineAvoidanceArea]?
        /// Avoid car shuttle trains for calculation.
        public var carShuttleTrains: Swift.Bool?
        /// Avoid controlled access highways for calculation.
        public var controlledAccessHighways: Swift.Bool?
        /// Avoid dirt roads for calculation.
        public var dirtRoads: Swift.Bool?
        /// Avoid ferries for calculation.
        public var ferries: Swift.Bool?
        /// Avoid roads that have seasonal closure for calculation.
        public var seasonalClosure: Swift.Bool?
        /// Avoid toll roads for calculation.
        public var tollRoads: Swift.Bool?
        /// Avoid toll roads for calculation.
        public var tollTransponders: Swift.Bool?
        /// Truck road type identifiers to be avoided. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico. There are currently no other supported values as of 26th April 2024.
        public var truckRoadTypes: [Swift.String]?
        /// Avoid tunnels for calculation.
        public var tunnels: Swift.Bool?
        /// Avoid u turns for calculation on highways and motorways.
        public var uTurns: Swift.Bool?
        /// Zone categories to be avoided.
        public var zoneCategories: [GeoRoutesClientTypes.IsolineAvoidanceZoneCategory]?

        public init(
            areas: [GeoRoutesClientTypes.IsolineAvoidanceArea]? = nil,
            carShuttleTrains: Swift.Bool? = nil,
            controlledAccessHighways: Swift.Bool? = nil,
            dirtRoads: Swift.Bool? = nil,
            ferries: Swift.Bool? = nil,
            seasonalClosure: Swift.Bool? = nil,
            tollRoads: Swift.Bool? = nil,
            tollTransponders: Swift.Bool? = nil,
            truckRoadTypes: [Swift.String]? = nil,
            tunnels: Swift.Bool? = nil,
            uTurns: Swift.Bool? = nil,
            zoneCategories: [GeoRoutesClientTypes.IsolineAvoidanceZoneCategory]? = nil
        )
        {
            self.areas = areas
            self.carShuttleTrains = carShuttleTrains
            self.controlledAccessHighways = controlledAccessHighways
            self.dirtRoads = dirtRoads
            self.ferries = ferries
            self.seasonalClosure = seasonalClosure
            self.tollRoads = tollRoads
            self.tollTransponders = tollTransponders
            self.truckRoadTypes = truckRoadTypes
            self.tunnels = tunnels
            self.uTurns = uTurns
            self.zoneCategories = zoneCategories
        }
    }
}

extension GeoRoutesClientTypes {

    public enum MatchingStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case matchAny
        case matchMostSignificantRoad
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchingStrategy] {
            return [
                .matchAny,
                .matchMostSignificantRoad
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .matchAny: return "MatchAny"
            case .matchMostSignificantRoad: return "MatchMostSignificantRoad"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Isoline matching related options.
    public struct IsolineMatchingOptions: Swift.Sendable {
        /// Attempts to match the provided position to a road similar to the provided name.
        public var nameHint: Swift.String?
        /// If the distance to a highway/bridge/tunnel/sliproad is within threshold, the waypoint will be snapped to the highway/bridge/tunnel/sliproad.
        public var onRoadThreshold: Swift.Int
        /// Considers all roads within the provided radius to match the provided destination to. The roads that are considered are determined by the provided Strategy. Unit: Meters
        public var radius: Swift.Int
        /// Strategy that defines matching of the position onto the road network. MatchAny considers all roads possible, whereas MatchMostSignificantRoad matches to the most significant road.
        public var strategy: GeoRoutesClientTypes.MatchingStrategy?

        public init(
            nameHint: Swift.String? = nil,
            onRoadThreshold: Swift.Int = 0,
            radius: Swift.Int = 0,
            strategy: GeoRoutesClientTypes.MatchingStrategy? = nil
        )
        {
            self.nameHint = nameHint
            self.onRoadThreshold = onRoadThreshold
            self.radius = radius
            self.strategy = strategy
        }
    }
}

extension GeoRoutesClientTypes.IsolineMatchingOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsolineMatchingOptions(onRoadThreshold: \(Swift.String(describing: onRoadThreshold)), radius: \(Swift.String(describing: radius)), strategy: \(Swift.String(describing: strategy)), nameHint: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    public enum SideOfStreetMatchingStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anyStreet
        case dividedStreetOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [SideOfStreetMatchingStrategy] {
            return [
                .anyStreet,
                .dividedStreetOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anyStreet: return "AnyStreet"
            case .dividedStreetOnly: return "DividedStreetOnly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options to configure matching the provided position to a side of the street.
    public struct IsolineSideOfStreetOptions: Swift.Sendable {
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?
        /// Strategy that defines when the side of street position should be used. AnyStreet will always use the provided position. Default Value: DividedStreetOnly
        public var useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy?

        public init(
            position: [Swift.Double]? = nil,
            useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy? = nil
        )
        {
            self.position = position
            self.useWith = useWith
        }
    }
}

extension GeoRoutesClientTypes.IsolineSideOfStreetOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsolineSideOfStreetOptions(useWith: \(Swift.String(describing: useWith)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Desination related options.
    public struct IsolineDestinationOptions: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.IsolineMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.IsolineSideOfStreetOptions?

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.IsolineMatchingOptions? = nil,
            sideOfStreet: GeoRoutesClientTypes.IsolineSideOfStreetOptions? = nil
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes {

    public enum GeometryFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case flexiblepolyline
        case simple
        case sdkUnknown(Swift.String)

        public static var allCases: [GeometryFormat] {
            return [
                .flexiblepolyline,
                .simple
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .flexiblepolyline: return "FlexiblePolyline"
            case .simple: return "Simple"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Isoline granularity related options.
    public struct IsolineGranularityOptions: Swift.Sendable {
        /// Maximum number of points of returned Isoline.
        public var maxPoints: Swift.Int?
        /// Maximum resolution of the returned isoline, in meters.
        public var maxResolution: Swift.Int

        public init(
            maxPoints: Swift.Int? = nil,
            maxResolution: Swift.Int = 0
        )
        {
            self.maxPoints = maxPoints
            self.maxResolution = maxResolution
        }
    }
}

extension GeoRoutesClientTypes {

    public enum IsolineOptimizationObjective: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accurateCalculation
        case balancedCalculation
        case fastCalculation
        case sdkUnknown(Swift.String)

        public static var allCases: [IsolineOptimizationObjective] {
            return [
                .accurateCalculation,
                .balancedCalculation,
                .fastCalculation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accurateCalculation: return "AccurateCalculation"
            case .balancedCalculation: return "BalancedCalculation"
            case .fastCalculation: return "FastCalculation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RoutingObjective: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fastestRoute
        case shortestRoute
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingObjective] {
            return [
                .fastestRoute,
                .shortestRoute
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fastestRoute: return "FastestRoute"
            case .shortestRoute: return "ShortestRoute"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options for the property.
    public struct IsolineOriginOptions: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.IsolineMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.IsolineSideOfStreetOptions?

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.IsolineMatchingOptions? = nil,
            sideOfStreet: GeoRoutesClientTypes.IsolineSideOfStreetOptions? = nil
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes {

    /// Threshold to be used for the isoline calculation. Upto 3 thresholds per provided type can be requested.
    public struct IsolineThresholds: Swift.Sendable {
        /// Consumption to be used for the calculation. Units: Watt-hours for EV, and meters/Time for distance.
        public var consumption: [Swift.Int]?
        /// Distance to be used for the isoline calculation.
        public var distance: [Swift.Int]?
        /// Time to be used for the isoline calculation.
        public var time: [Swift.Int]?

        public init(
            consumption: [Swift.Int]? = nil,
            distance: [Swift.Int]? = nil,
            time: [Swift.Int]? = nil
        )
        {
            self.consumption = consumption
            self.distance = distance
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    public enum TrafficUsage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ignoreTrafficData
        case useTrafficData
        case sdkUnknown(Swift.String)

        public static var allCases: [TrafficUsage] {
            return [
                .ignoreTrafficData,
                .useTrafficData
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ignoreTrafficData: return "IgnoreTrafficData"
            case .useTrafficData: return "UseTrafficData"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to traffic.
    public struct IsolineTrafficOptions: Swift.Sendable {
        /// Duration for which flow traffic is considered valid. For this period, the flow traffic is used over historical traffic data. Flow traffic refers to congestion, which changes very quickly. Duration in seconds for which flow traffic event would be considered valid. While flow traffic event is valid it will be used over the historical traffic data.
        public var flowEventThresholdOverride: Swift.Int
        /// Determines if traffic should be used or ignored for calculation. Default Value: UseTrafficData
        public var usage: GeoRoutesClientTypes.TrafficUsage?

        public init(
            flowEventThresholdOverride: Swift.Int = 0,
            usage: GeoRoutesClientTypes.TrafficUsage? = nil
        )
        {
            self.flowEventThresholdOverride = flowEventThresholdOverride
            self.usage = usage
        }
    }
}

extension GeoRoutesClientTypes {

    public enum IsolineTravelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case car
        case pedestrian
        case scooter
        case truck
        case sdkUnknown(Swift.String)

        public static var allCases: [IsolineTravelMode] {
            return [
                .car,
                .pedestrian,
                .scooter,
                .truck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .pedestrian: return "Pedestrian"
            case .scooter: return "Scooter"
            case .truck: return "Truck"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum IsolineEngineType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case electric
        case internalCombustion
        case pluginHybrid
        case sdkUnknown(Swift.String)

        public static var allCases: [IsolineEngineType] {
            return [
                .electric,
                .internalCombustion,
                .pluginHybrid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .electric: return "Electric"
            case .internalCombustion: return "InternalCombustion"
            case .pluginHybrid: return "PluginHybrid"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The vehicle license plate.
    public struct IsolineVehicleLicensePlate: Swift.Sendable {
        /// The last character of the License Plate.
        public var lastCharacter: Swift.String?

        public init(
            lastCharacter: Swift.String? = nil
        )
        {
            self.lastCharacter = lastCharacter
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options for vehicles.
    public struct IsolineCarOptions: Swift.Sendable {
        /// Engine type of the vehicle.
        public var engineType: GeoRoutesClientTypes.IsolineEngineType?
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.IsolineVehicleLicensePlate?
        /// Maximum speed specified in Kilometers per hour.
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?

        public init(
            engineType: GeoRoutesClientTypes.IsolineEngineType? = nil,
            licensePlate: GeoRoutesClientTypes.IsolineVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil
        )
        {
            self.engineType = engineType
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }
    }
}

extension GeoRoutesClientTypes {

    /// Rate of energy consumed at speed.
    public struct IsolineConsumptionRateAtSpeed: Swift.Sendable {
        /// Rate of energy consumed by the vehicle's auxiliary systems like lights, or air conditioning. Unit: Kw/H
        /// This member is required.
        public var consumptionRate: Swift.Double?
        /// The speed of the vehicle. Unit: Km/H Default Value: 3.6
        /// This member is required.
        public var speed: Swift.Double

        public init(
            consumptionRate: Swift.Double? = nil,
            speed: Swift.Double = 0.0
        )
        {
            self.consumptionRate = consumptionRate
            self.speed = speed
        }
    }
}

extension GeoRoutesClientTypes {

    /// Electric vehicle related options.
    public struct IsolineEvOptions: Swift.Sendable {
        /// Rate of energy consumed by the vehicle's auxiliary systems like lights, or air conditioning. Unit: Kw/H
        public var auxiliaryConsumptionRate: Swift.Double
        /// Rate of energy consumed per meter rise in elevation. Unit: Watt-hours / meter
        public var consumptionRateOnAscent: Swift.Double
        /// Rate of energy consumer per meter fall in elevation. Unit: Watt-hours / meter
        public var consumptionRateOnDescent: Swift.Double
        /// Curve specifying the consumption rate at a given speed, in free flowing traffic.
        public var freeFlowConsumptionCurve: [GeoRoutesClientTypes.IsolineConsumptionRateAtSpeed]?
        /// Curve specifying the consumption rate at a given speed, at traffic reduced speed on a flat stretch of road.
        public var trafficConsumptionCurve: [GeoRoutesClientTypes.IsolineConsumptionRateAtSpeed]?

        public init(
            auxiliaryConsumptionRate: Swift.Double = 0.0,
            consumptionRateOnAscent: Swift.Double = 0.0,
            consumptionRateOnDescent: Swift.Double = 0.0,
            freeFlowConsumptionCurve: [GeoRoutesClientTypes.IsolineConsumptionRateAtSpeed]? = nil,
            trafficConsumptionCurve: [GeoRoutesClientTypes.IsolineConsumptionRateAtSpeed]? = nil
        )
        {
            self.auxiliaryConsumptionRate = auxiliaryConsumptionRate
            self.consumptionRateOnAscent = consumptionRateOnAscent
            self.consumptionRateOnDescent = consumptionRateOnDescent
            self.freeFlowConsumptionCurve = freeFlowConsumptionCurve
            self.trafficConsumptionCurve = trafficConsumptionCurve
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options for the property.
    public struct IsolineScooterOptions: Swift.Sendable {
        /// Engine type of the vehicle.
        public var engineType: GeoRoutesClientTypes.IsolineEngineType?
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.IsolineVehicleLicensePlate?
        /// Maximum speed specified in Kilometers per hour.
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?

        public init(
            engineType: GeoRoutesClientTypes.IsolineEngineType? = nil,
            licensePlate: GeoRoutesClientTypes.IsolineVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil
        )
        {
            self.engineType = engineType
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }
    }
}

extension GeoRoutesClientTypes {

    public enum IsolineHazardousCargoType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case combustible
        case corrosive
        case explosive
        case flammable
        case gas
        case harmfulToWater
        case organic
        case other
        case poison
        case poisonousInhalation
        case radioactive
        case sdkUnknown(Swift.String)

        public static var allCases: [IsolineHazardousCargoType] {
            return [
                .combustible,
                .corrosive,
                .explosive,
                .flammable,
                .gas,
                .harmfulToWater,
                .organic,
                .other,
                .poison,
                .poisonousInhalation,
                .radioactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .combustible: return "Combustible"
            case .corrosive: return "Corrosive"
            case .explosive: return "Explosive"
            case .flammable: return "Flammable"
            case .gas: return "Gas"
            case .harmfulToWater: return "HarmfulToWater"
            case .organic: return "Organic"
            case .other: return "Other"
            case .poison: return "Poison"
            case .poisonousInhalation: return "PoisonousInhalation"
            case .radioactive: return "Radioactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Trailer options corresponding to the vehicle.
    public struct IsolineTrailerOptions: Swift.Sendable {
        /// Total number of axles of the vehicle.
        public var axleCount: Swift.Int?
        /// Number of trailers attached to the vehicle. Default Value: 0
        public var trailerCount: Swift.Int?

        public init(
            axleCount: Swift.Int? = nil,
            trailerCount: Swift.Int? = nil
        )
        {
            self.axleCount = axleCount
            self.trailerCount = trailerCount
        }
    }
}

extension GeoRoutesClientTypes {

    public enum IsolineTruckType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lightTruck
        case straightTruck
        case tractor
        case sdkUnknown(Swift.String)

        public static var allCases: [IsolineTruckType] {
            return [
                .lightTruck,
                .straightTruck,
                .tractor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lightTruck: return "LightTruck"
            case .straightTruck: return "StraightTruck"
            case .tractor: return "Tractor"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Specifies the total weight for the specified axle group. Meant for usage in countries that have different regulations based on the axle group type.
    public struct WeightPerAxleGroup: Swift.Sendable {
        /// Weight for quad axle group.
        public var quad: Swift.Int
        /// Weight for quad quint group.
        public var quint: Swift.Int
        /// Weight for single axle group.
        public var single: Swift.Int
        /// Weight for tandem axle group.
        public var tandem: Swift.Int
        /// Weight for triple axle group.
        public var triple: Swift.Int

        public init(
            quad: Swift.Int = 0,
            quint: Swift.Int = 0,
            single: Swift.Int = 0,
            tandem: Swift.Int = 0,
            triple: Swift.Int = 0
        )
        {
            self.quad = quad
            self.quint = quint
            self.single = single
            self.tandem = tandem
            self.triple = triple
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Truck"
    public struct IsolineTruckOptions: Swift.Sendable {
        /// Total number of axles of the vehicle.
        public var axleCount: Swift.Int?
        /// Engine type of the vehicle.
        public var engineType: GeoRoutesClientTypes.IsolineEngineType?
        /// Gross weight of the vehicle including trailers, and goods at capacity.
        public var grossWeight: Swift.Int
        /// List of Hazardous cargos contained in the vehicle.
        public var hazardousCargos: [GeoRoutesClientTypes.IsolineHazardousCargoType]?
        /// Height of the vehicle in centimeters.
        public var height: Swift.Int
        /// Height of the vehicle above its first axle in centimeters.
        public var heightAboveFirstAxle: Swift.Int
        /// Kingpin to rear axle length of the vehicle in meters.
        public var kpraLength: Swift.Int
        /// Length of the vehicle in meters.
        public var length: Swift.Int
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.IsolineVehicleLicensePlate?
        /// Maximum speed specified in Kilometers per hour.
        public var maxSpeed: Swift.Double?
        public var occupancy: Swift.Int?
        /// Payload capacity of the vehicle and trailers attached.
        public var payloadCapacity: Swift.Int
        /// Number of tires on the vehicle.
        public var tireCount: Swift.Int?
        /// Trailer options corresponding to the vehicle.
        public var trailer: GeoRoutesClientTypes.IsolineTrailerOptions?
        /// Type of the truck.
        public var truckType: GeoRoutesClientTypes.IsolineTruckType?
        /// The tunnel restriction code.
        public var tunnelRestrictionCode: Swift.String?
        /// Heaviest weight per axle irrespective of the axle type or the axle group. Meant for usage in countries where the differences in axle types or axle groups are not distinguished. Unit: Kilograms
        public var weightPerAxle: Swift.Int
        /// Specifies the total weight for the specified axle group. Meant for usage in countries that have different regulations based on the axle group type.
        public var weightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup?
        /// Width of the vehicle in centimenters.
        public var width: Swift.Int

        public init(
            axleCount: Swift.Int? = nil,
            engineType: GeoRoutesClientTypes.IsolineEngineType? = nil,
            grossWeight: Swift.Int = 0,
            hazardousCargos: [GeoRoutesClientTypes.IsolineHazardousCargoType]? = nil,
            height: Swift.Int = 0,
            heightAboveFirstAxle: Swift.Int = 0,
            kpraLength: Swift.Int = 0,
            length: Swift.Int = 0,
            licensePlate: GeoRoutesClientTypes.IsolineVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil,
            payloadCapacity: Swift.Int = 0,
            tireCount: Swift.Int? = nil,
            trailer: GeoRoutesClientTypes.IsolineTrailerOptions? = nil,
            truckType: GeoRoutesClientTypes.IsolineTruckType? = nil,
            tunnelRestrictionCode: Swift.String? = nil,
            weightPerAxle: Swift.Int = 0,
            weightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup? = nil,
            width: Swift.Int = 0
        )
        {
            self.axleCount = axleCount
            self.engineType = engineType
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.heightAboveFirstAxle = heightAboveFirstAxle
            self.kpraLength = kpraLength
            self.length = length
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
            self.payloadCapacity = payloadCapacity
            self.tireCount = tireCount
            self.trailer = trailer
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.weightPerAxle = weightPerAxle
            self.weightPerAxleGroup = weightPerAxleGroup
            self.width = width
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode related options for the provided travel mode.
    public struct IsolineTravelModeOptions: Swift.Sendable {
        /// Travel mode options when the provided travel mode is "Car"
        public var car: GeoRoutesClientTypes.IsolineCarOptions?
        /// Ev option if the vehicle is electric powered.
        public var ev: GeoRoutesClientTypes.IsolineEvOptions?
        /// Travel mode options when the provided travel mode is "Scooter"
        public var scooter: GeoRoutesClientTypes.IsolineScooterOptions?
        /// Travel mode options when the provided travel mode is "Truck"
        public var truck: GeoRoutesClientTypes.IsolineTruckOptions?

        public init(
            car: GeoRoutesClientTypes.IsolineCarOptions? = nil,
            ev: GeoRoutesClientTypes.IsolineEvOptions? = nil,
            scooter: GeoRoutesClientTypes.IsolineScooterOptions? = nil,
            truck: GeoRoutesClientTypes.IsolineTruckOptions? = nil
        )
        {
            self.car = car
            self.ev = ev
            self.scooter = scooter
            self.truck = truck
        }
    }
}

public struct CalculateIsolinesInput: Swift.Sendable {
    /// Features that are allowed while calculation.
    public var allow: GeoRoutesClientTypes.IsolineAllowOptions?
    /// Time of arrival at the destination. This parameter is returned only if the Destination parameters was provided in the request. Template:YYYY-MM-DDThh:mm:ss.sssZ YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var arrivalTime: Swift.String?
    /// Features that are avoided while calculation. Avoidance is on a best-case basis.If an avoidance cannot be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.
    public var avoid: GeoRoutesClientTypes.IsolineAvoidanceOptions?
    /// Uses the current time as the time of departure.
    public var departNow: Swift.Bool?
    /// Time of departure for Origin. Template:YYYY-MM-DDThh:mm:ss.sssZ YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var departureTime: Swift.String?
    /// The finish position for the route. In the World Geodetic System (WGS 84) format: (longitude, latitude).
    public var destination: [Swift.Double]?
    /// Desination related options.
    public var destinationOptions: GeoRoutesClientTypes.IsolineDestinationOptions?
    /// The format of the returned IsolineGeometry. Default Value:FlexiblePolyline
    public var isolineGeometryFormat: GeoRoutesClientTypes.GeometryFormat?
    /// Defines the granularity of the returned Isoline
    public var isolineGranularity: GeoRoutesClientTypes.IsolineGranularityOptions?
    /// Optional: The API key to be used for authorization. Optional, either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// Specifies the optimization criteria for when calculating an isoline. AccurateCalculation generates an isoline of higher granularity that is more precise. FastCalculation generates an isoline faster by reducing the granularity, and in turn the quality of the isoline. BalancedCalculation generates an isoline by balancing between quality and performance. Default Value: BalancedCalculation
    public var optimizeIsolineFor: GeoRoutesClientTypes.IsolineOptimizationObjective?
    /// Specifies the optimization criteria for calculating a route. Default Value: FastestRoute
    public var optimizeRoutingFor: GeoRoutesClientTypes.RoutingObjective?
    /// The start position for the route.
    public var origin: [Swift.Double]?
    /// Origin related options.
    public var originOptions: GeoRoutesClientTypes.IsolineOriginOptions?
    /// Threshold to be used for the isoline calculation. Up to 3 thresholds per provided type can be requested.
    /// This member is required.
    public var thresholds: GeoRoutesClientTypes.IsolineThresholds?
    /// Traffic related options.
    public var traffic: GeoRoutesClientTypes.IsolineTrafficOptions?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value:Car Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value:Car
    public var travelMode: GeoRoutesClientTypes.IsolineTravelMode?
    /// Travel mode related options for the provided travel mode.
    public var travelModeOptions: GeoRoutesClientTypes.IsolineTravelModeOptions?

    public init(
        allow: GeoRoutesClientTypes.IsolineAllowOptions? = nil,
        arrivalTime: Swift.String? = nil,
        avoid: GeoRoutesClientTypes.IsolineAvoidanceOptions? = nil,
        departNow: Swift.Bool? = nil,
        departureTime: Swift.String? = nil,
        destination: [Swift.Double]? = nil,
        destinationOptions: GeoRoutesClientTypes.IsolineDestinationOptions? = nil,
        isolineGeometryFormat: GeoRoutesClientTypes.GeometryFormat? = nil,
        isolineGranularity: GeoRoutesClientTypes.IsolineGranularityOptions? = nil,
        key: Swift.String? = nil,
        optimizeIsolineFor: GeoRoutesClientTypes.IsolineOptimizationObjective? = nil,
        optimizeRoutingFor: GeoRoutesClientTypes.RoutingObjective? = nil,
        origin: [Swift.Double]? = nil,
        originOptions: GeoRoutesClientTypes.IsolineOriginOptions? = nil,
        thresholds: GeoRoutesClientTypes.IsolineThresholds? = nil,
        traffic: GeoRoutesClientTypes.IsolineTrafficOptions? = nil,
        travelMode: GeoRoutesClientTypes.IsolineTravelMode? = nil,
        travelModeOptions: GeoRoutesClientTypes.IsolineTravelModeOptions? = nil
    )
    {
        self.allow = allow
        self.arrivalTime = arrivalTime
        self.avoid = avoid
        self.departNow = departNow
        self.departureTime = departureTime
        self.destination = destination
        self.destinationOptions = destinationOptions
        self.isolineGeometryFormat = isolineGeometryFormat
        self.isolineGranularity = isolineGranularity
        self.key = key
        self.optimizeIsolineFor = optimizeIsolineFor
        self.optimizeRoutingFor = optimizeRoutingFor
        self.origin = origin
        self.originOptions = originOptions
        self.thresholds = thresholds
        self.traffic = traffic
        self.travelMode = travelMode
        self.travelModeOptions = travelModeOptions
    }
}

extension CalculateIsolinesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateIsolinesInput(allow: \(Swift.String(describing: allow)), arrivalTime: \(Swift.String(describing: arrivalTime)), avoid: \(Swift.String(describing: avoid)), departNow: \(Swift.String(describing: departNow)), departureTime: \(Swift.String(describing: departureTime)), destinationOptions: \(Swift.String(describing: destinationOptions)), isolineGeometryFormat: \(Swift.String(describing: isolineGeometryFormat)), isolineGranularity: \(Swift.String(describing: isolineGranularity)), optimizeIsolineFor: \(Swift.String(describing: optimizeIsolineFor)), optimizeRoutingFor: \(Swift.String(describing: optimizeRoutingFor)), originOptions: \(Swift.String(describing: originOptions)), thresholds: \(Swift.String(describing: thresholds)), traffic: \(Swift.String(describing: traffic)), travelMode: \(Swift.String(describing: travelMode)), travelModeOptions: \(Swift.String(describing: travelModeOptions)), destination: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", origin: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Geometry of the connection between different Isoline components.
    public struct IsolineConnectionGeometry: Swift.Sendable {
        /// An ordered list of positions used to plot a route on a map. LineString and Polyline are mutually exclusive properties.
        public var lineString: [[Swift.Double]]?
        /// An ordered list of positions used to plot a route on a map in a lossy compression format. LineString and Polyline are mutually exclusive properties.
        public var polyline: Swift.String?

        public init(
            lineString: [[Swift.Double]]? = nil,
            polyline: Swift.String? = nil
        )
        {
            self.lineString = lineString
            self.polyline = polyline
        }
    }
}

extension GeoRoutesClientTypes.IsolineConnectionGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsolineConnectionGeometry(lineString: \"CONTENT_REDACTED\", polyline: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Isolines may contain multiple components, if these components are connected by ferry links. These components are returned as separate polygons while the ferry links are returned as connections.
    public struct IsolineConnection: Swift.Sendable {
        /// Index of the polygon corresponding to the "from" component of the connection. The polygon is available from Isoline[].Geometries.
        /// This member is required.
        public var fromPolygonIndex: Swift.Int?
        /// The isoline geometry.
        /// This member is required.
        public var geometry: GeoRoutesClientTypes.IsolineConnectionGeometry?
        /// Index of the polygon corresponding to the "to" component of the connection. The polygon is available from Isoline[].Geometries.
        /// This member is required.
        public var toPolygonIndex: Swift.Int?

        public init(
            fromPolygonIndex: Swift.Int? = nil,
            geometry: GeoRoutesClientTypes.IsolineConnectionGeometry? = nil,
            toPolygonIndex: Swift.Int? = nil
        )
        {
            self.fromPolygonIndex = fromPolygonIndex
            self.geometry = geometry
            self.toPolygonIndex = toPolygonIndex
        }
    }
}

extension GeoRoutesClientTypes {

    /// Geometry of the connection between different Isoline components.
    public struct IsolineShapeGeometry: Swift.Sendable {
        /// A list of Isoline Polygons, for each isoline polygon, it contains polygons of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings).
        public var polygon: [[[Swift.Double]]]?
        /// A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings). For more information on polyline encoding, see [https://github.com/heremaps/flexiblepolyline/blob/master/README.md](https://github.com/heremaps/flexiblepolyline/blob/master/README.md).
        public var polylinePolygon: [Swift.String]?

        public init(
            polygon: [[[Swift.Double]]]? = nil,
            polylinePolygon: [Swift.String]? = nil
        )
        {
            self.polygon = polygon
            self.polylinePolygon = polylinePolygon
        }
    }
}

extension GeoRoutesClientTypes.IsolineShapeGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsolineShapeGeometry(polygon: \"CONTENT_REDACTED\", polylinePolygon: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Calculated Isolines and associated properties.
    public struct Isoline: Swift.Sendable {
        /// Isolines may contain multiple components, if these components are connected by ferry links. These components are returned as separate polygons while the ferry links are returned as connections.
        /// This member is required.
        public var connections: [GeoRoutesClientTypes.IsolineConnection]?
        /// Consumption threshold corresponding to the calculated Isoline.
        public var consumptionThreshold: Swift.Int?
        /// Distance threshold corresponding to the calculated Isoline.
        public var distanceThreshold: Swift.Int
        /// Geometries for the calculated isolines.
        /// This member is required.
        public var geometries: [GeoRoutesClientTypes.IsolineShapeGeometry]?
        /// Time threshold corresponding to the calculated isoline.
        public var timeThreshold: Swift.Int

        public init(
            connections: [GeoRoutesClientTypes.IsolineConnection]? = nil,
            consumptionThreshold: Swift.Int? = nil,
            distanceThreshold: Swift.Int = 0,
            geometries: [GeoRoutesClientTypes.IsolineShapeGeometry]? = nil,
            timeThreshold: Swift.Int = 0
        )
        {
            self.connections = connections
            self.consumptionThreshold = consumptionThreshold
            self.distanceThreshold = distanceThreshold
            self.geometries = geometries
            self.timeThreshold = timeThreshold
        }
    }
}

public struct CalculateIsolinesOutput: Swift.Sendable {
    /// Time of arrival at the destination. This parameter is returned only if the Destination parameters was provided in the request. Template:YYYY-MM-DDThh:mm:ss.sssZ YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var arrivalTime: Swift.String?
    /// Time of departure for Origin. Template:YYYY-MM-DDThh:mm:ss.sssZ YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var departureTime: Swift.String?
    /// The format of the returned IsolineGeometry. Default Value:FlexiblePolyline
    /// This member is required.
    public var isolineGeometryFormat: GeoRoutesClientTypes.GeometryFormat?
    /// Calculated Isolines and associated properties.
    /// This member is required.
    public var isolines: [GeoRoutesClientTypes.Isoline]?
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// Snapped destination that was used for the Isoline calculation.
    public var snappedDestination: [Swift.Double]?
    /// Snapped origin that was used for the Isoline calculation.
    public var snappedOrigin: [Swift.Double]?

    public init(
        arrivalTime: Swift.String? = nil,
        departureTime: Swift.String? = nil,
        isolineGeometryFormat: GeoRoutesClientTypes.GeometryFormat? = nil,
        isolines: [GeoRoutesClientTypes.Isoline]? = nil,
        pricingBucket: Swift.String? = nil,
        snappedDestination: [Swift.Double]? = nil,
        snappedOrigin: [Swift.Double]? = nil
    )
    {
        self.arrivalTime = arrivalTime
        self.departureTime = departureTime
        self.isolineGeometryFormat = isolineGeometryFormat
        self.isolines = isolines
        self.pricingBucket = pricingBucket
        self.snappedDestination = snappedDestination
        self.snappedOrigin = snappedOrigin
    }
}

extension CalculateIsolinesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateIsolinesOutput(arrivalTime: \(Swift.String(describing: arrivalTime)), departureTime: \(Swift.String(describing: departureTime)), isolineGeometryFormat: \(Swift.String(describing: isolineGeometryFormat)), isolines: \(Swift.String(describing: isolines)), pricingBucket: \(Swift.String(describing: pricingBucket)), snappedDestination: \"CONTENT_REDACTED\", snappedOrigin: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Allow Options related to the route matrix.
    public struct RouteMatrixAllowOptions: Swift.Sendable {
        /// Allow Hot (High Occupancy Toll) lanes for calculation.
        public var hot: Swift.Bool?
        /// Allow Hov (High Occupancy vehicle) lanes for calculation.
        public var hov: Swift.Bool?

        public init(
            hot: Swift.Bool? = nil,
            hov: Swift.Bool? = nil
        )
        {
            self.hot = hot
            self.hov = hov
        }
    }
}

extension GeoRoutesClientTypes {

    /// Geometry of the area to be avoided.
    public struct RouteMatrixAvoidanceAreaGeometry: Swift.Sendable {
        /// Gometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public var boundingBox: [Swift.Double]?
        /// Geometry defined as a polygon with only one linear ring.
        public var polygon: [[[Swift.Double]]]?
        /// A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings). For more information on polyline encoding, see [https://github.com/heremaps/flexiblepolyline/blob/master/README.md](https://github.com/heremaps/flexiblepolyline/blob/master/README.md).
        public var polylinePolygon: [Swift.String]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            polygon: [[[Swift.Double]]]? = nil,
            polylinePolygon: [Swift.String]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.polygon = polygon
            self.polylinePolygon = polylinePolygon
        }
    }
}

extension GeoRoutesClientTypes.RouteMatrixAvoidanceAreaGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatrixAvoidanceAreaGeometry(boundingBox: \"CONTENT_REDACTED\", polygon: \"CONTENT_REDACTED\", polylinePolygon: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Area to be avoided.
    public struct RouteMatrixAvoidanceArea: Swift.Sendable {
        /// Geometry of the area to be avoided.
        /// This member is required.
        public var geometry: GeoRoutesClientTypes.RouteMatrixAvoidanceAreaGeometry?

        public init(
            geometry: GeoRoutesClientTypes.RouteMatrixAvoidanceAreaGeometry? = nil
        )
        {
            self.geometry = geometry
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteMatrixZoneCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case congestionPricing
        case environmental
        case vignette
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixZoneCategory] {
            return [
                .congestionPricing,
                .environmental,
                .vignette
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .congestionPricing: return "CongestionPricing"
            case .environmental: return "Environmental"
            case .vignette: return "Vignette"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Zone categories to be avoided.
    public struct RouteMatrixAvoidanceZoneCategory: Swift.Sendable {
        /// Zone category to be avoided.
        public var category: GeoRoutesClientTypes.RouteMatrixZoneCategory?

        public init(
            category: GeoRoutesClientTypes.RouteMatrixZoneCategory? = nil
        )
        {
            self.category = category
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to the route matrix.
    public struct RouteMatrixAvoidanceOptions: Swift.Sendable {
        /// Areas to be avoided.
        public var areas: [GeoRoutesClientTypes.RouteMatrixAvoidanceArea]?
        /// Avoid car shuttle trains for calculation.
        public var carShuttleTrains: Swift.Bool?
        /// Avoid controlled access highways for calculation.
        public var controlledAccessHighways: Swift.Bool?
        /// Avoid dirt roads for calculation.
        public var dirtRoads: Swift.Bool?
        /// Avoid ferries for calculation.
        public var ferries: Swift.Bool?
        /// Avoid toll roads for calculation.
        public var tollRoads: Swift.Bool?
        public var tollTransponders: Swift.Bool?
        /// Truck road type identifiers to be avoided. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico. There are currently no other supported values as of 26th April 2024.
        public var truckRoadTypes: [Swift.String]?
        /// Avoid tunnels for calculation.
        public var tunnels: Swift.Bool?
        /// Avoid u turns for calculation on highways and motorways.
        public var uTurns: Swift.Bool?
        /// Zone categories to be avoided.
        public var zoneCategories: [GeoRoutesClientTypes.RouteMatrixAvoidanceZoneCategory]?

        public init(
            areas: [GeoRoutesClientTypes.RouteMatrixAvoidanceArea]? = nil,
            carShuttleTrains: Swift.Bool? = nil,
            controlledAccessHighways: Swift.Bool? = nil,
            dirtRoads: Swift.Bool? = nil,
            ferries: Swift.Bool? = nil,
            tollRoads: Swift.Bool? = nil,
            tollTransponders: Swift.Bool? = nil,
            truckRoadTypes: [Swift.String]? = nil,
            tunnels: Swift.Bool? = nil,
            uTurns: Swift.Bool? = nil,
            zoneCategories: [GeoRoutesClientTypes.RouteMatrixAvoidanceZoneCategory]? = nil
        )
        {
            self.areas = areas
            self.carShuttleTrains = carShuttleTrains
            self.controlledAccessHighways = controlledAccessHighways
            self.dirtRoads = dirtRoads
            self.ferries = ferries
            self.tollRoads = tollRoads
            self.tollTransponders = tollTransponders
            self.truckRoadTypes = truckRoadTypes
            self.tunnels = tunnels
            self.uTurns = uTurns
            self.zoneCategories = zoneCategories
        }
    }
}

extension GeoRoutesClientTypes {

    /// Matching options.
    public struct RouteMatrixMatchingOptions: Swift.Sendable {
        /// Attempts to match the provided position to a road similar to the provided name.
        public var nameHint: Swift.String?
        /// If the distance to a highway/bridge/tunnel/sliproad is within threshold, the waypoint will be snapped to the highway/bridge/tunnel/sliproad.
        public var onRoadThreshold: Swift.Int
        /// Considers all roads within the provided radius to match the provided destination to. The roads that are considered are determined by the provided Strategy. Unit: Meters
        public var radius: Swift.Int
        /// Strategy that defines matching of the position onto the road network. MatchAny considers all roads possible, whereas MatchMostSignificantRoad matches to the most significant road.
        public var strategy: GeoRoutesClientTypes.MatchingStrategy?

        public init(
            nameHint: Swift.String? = nil,
            onRoadThreshold: Swift.Int = 0,
            radius: Swift.Int = 0,
            strategy: GeoRoutesClientTypes.MatchingStrategy? = nil
        )
        {
            self.nameHint = nameHint
            self.onRoadThreshold = onRoadThreshold
            self.radius = radius
            self.strategy = strategy
        }
    }
}

extension GeoRoutesClientTypes.RouteMatrixMatchingOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatrixMatchingOptions(onRoadThreshold: \(Swift.String(describing: onRoadThreshold)), radius: \(Swift.String(describing: radius)), strategy: \(Swift.String(describing: strategy)), nameHint: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Options to configure matching the provided position to a side of the street.
    public struct RouteMatrixSideOfStreetOptions: Swift.Sendable {
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?
        /// Strategy that defines when the side of street position should be used. AnyStreet will always use the provided position. Default Value: DividedStreetOnly
        public var useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy?

        public init(
            position: [Swift.Double]? = nil,
            useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy? = nil
        )
        {
            self.position = position
            self.useWith = useWith
        }
    }
}

extension GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatrixSideOfStreetOptions(useWith: \(Swift.String(describing: useWith)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Options related to the destination.
    public struct RouteMatrixDestinationOptions: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.RouteMatrixMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions?

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.RouteMatrixMatchingOptions? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions? = nil
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes {

    /// The route destination.
    public struct RouteMatrixDestination: Swift.Sendable {
        /// Destination related options.
        public var options: GeoRoutesClientTypes.RouteMatrixDestinationOptions?
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?

        public init(
            options: GeoRoutesClientTypes.RouteMatrixDestinationOptions? = nil,
            position: [Swift.Double]? = nil
        )
        {
            self.options = options
            self.position = position
        }
    }
}

extension GeoRoutesClientTypes.RouteMatrixDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatrixDestination(options: \(Swift.String(describing: options)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Exclusion options.
    public struct RouteMatrixExclusionOptions: Swift.Sendable {
        /// List of countries to be avoided defined by two-letter or three-letter country codes.
        /// This member is required.
        public var countries: [Swift.String]?

        public init(
            countries: [Swift.String]? = nil
        )
        {
            self.countries = countries
        }
    }
}

extension GeoRoutesClientTypes {

    /// Origin related options.
    public struct RouteMatrixOriginOptions: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.RouteMatrixMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions?

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.RouteMatrixMatchingOptions? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions? = nil
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes {

    /// The start position for the route.
    public struct RouteMatrixOrigin: Swift.Sendable {
        /// Origin related options.
        public var options: GeoRoutesClientTypes.RouteMatrixOriginOptions?
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?

        public init(
            options: GeoRoutesClientTypes.RouteMatrixOriginOptions? = nil,
            position: [Swift.Double]? = nil
        )
        {
            self.options = options
            self.position = position
        }
    }
}

extension GeoRoutesClientTypes.RouteMatrixOrigin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatrixOrigin(options: \(Swift.String(describing: options)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Provides the circle that was used for calcuation.
    public struct RouteMatrixAutoCircle: Swift.Sendable {
        /// The margin provided for the calcuation.
        public var margin: Swift.Int
        /// The maximum size of the radius provided for the calcuation.
        public var maxRadius: Swift.Int

        public init(
            margin: Swift.Int = 0,
            maxRadius: Swift.Int = 0
        )
        {
            self.margin = margin
            self.maxRadius = maxRadius
        }
    }
}

extension GeoRoutesClientTypes {

    /// Geometry defined as a circle. When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.
    public struct Circle: Swift.Sendable {
        /// Center of the Circle defeind in longitude and latitude coordinates. Example: [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        /// This member is required.
        public var center: [Swift.Double]?
        /// Radius of the Circle. Unit: meters
        /// This member is required.
        public var radius: Swift.Double?

        public init(
            center: [Swift.Double]? = nil,
            radius: Swift.Double? = nil
        )
        {
            self.center = center
            self.radius = radius
        }
    }
}

extension GeoRoutesClientTypes.Circle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension GeoRoutesClientTypes {

    /// Geometry of the routing boundary.
    public struct RouteMatrixBoundaryGeometry: Swift.Sendable {
        /// Provides the circle that was used for calcuation.
        public var autoCircle: GeoRoutesClientTypes.RouteMatrixAutoCircle?
        /// Gometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public var boundingBox: [Swift.Double]?
        /// Geometry defined as a circle. When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.
        public var circle: GeoRoutesClientTypes.Circle?
        /// Geometry defined as a polygon with only one linear ring.
        public var polygon: [[[Swift.Double]]]?

        public init(
            autoCircle: GeoRoutesClientTypes.RouteMatrixAutoCircle? = nil,
            boundingBox: [Swift.Double]? = nil,
            circle: GeoRoutesClientTypes.Circle? = nil,
            polygon: [[[Swift.Double]]]? = nil
        )
        {
            self.autoCircle = autoCircle
            self.boundingBox = boundingBox
            self.circle = circle
            self.polygon = polygon
        }
    }
}

extension GeoRoutesClientTypes.RouteMatrixBoundaryGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatrixBoundaryGeometry(autoCircle: \(Swift.String(describing: autoCircle)), boundingBox: \"CONTENT_REDACTED\", circle: \"CONTENT_REDACTED\", polygon: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid.
    public struct RouteMatrixBoundary: Swift.Sendable {
        /// Geometry of the area to be avoided.
        public var geometry: GeoRoutesClientTypes.RouteMatrixBoundaryGeometry?
        /// No restrictions in terms of a routing boundary, and is typically used for longer routes.
        public var unbounded: Swift.Bool?

        public init(
            geometry: GeoRoutesClientTypes.RouteMatrixBoundaryGeometry? = nil,
            unbounded: Swift.Bool? = nil
        )
        {
            self.geometry = geometry
            self.unbounded = unbounded
        }
    }
}

extension GeoRoutesClientTypes {

    /// Traffic related options.
    public struct RouteMatrixTrafficOptions: Swift.Sendable {
        /// Duration for which flow traffic is considered valid. For this period, the flow traffic is used over historical traffic data. Flow traffic refers to congestion, which changes very quickly. Duration in seconds for which flow traffic event would be considered valid. While flow traffic event is valid it will be used over the historical traffic data.
        public var flowEventThresholdOverride: Swift.Int
        /// Determines if traffic should be used or ignored for calculation. Default Value: UseTrafficData
        public var usage: GeoRoutesClientTypes.TrafficUsage?

        public init(
            flowEventThresholdOverride: Swift.Int = 0,
            usage: GeoRoutesClientTypes.TrafficUsage? = nil
        )
        {
            self.flowEventThresholdOverride = flowEventThresholdOverride
            self.usage = usage
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteMatrixTravelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case car
        case pedestrian
        case scooter
        case truck
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixTravelMode] {
            return [
                .car,
                .pedestrian,
                .scooter,
                .truck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .pedestrian: return "Pedestrian"
            case .scooter: return "Scooter"
            case .truck: return "Truck"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public struct RouteMatrixVehicleLicensePlate: Swift.Sendable {
        public var lastCharacter: Swift.String?

        public init(
            lastCharacter: Swift.String? = nil
        )
        {
            self.lastCharacter = lastCharacter
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to the car.
    public struct RouteMatrixCarOptions: Swift.Sendable {
        public var licensePlate: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate?
        /// Maximum speed specified in Kilometers per hour.
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?

        public init(
            licensePlate: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil
        )
        {
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }
    }
}

extension GeoRoutesClientTypes {

    public struct RouteMatrixScooterOptions: Swift.Sendable {
        public var licensePlate: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate?
        public var maxSpeed: Swift.Double?
        public var occupancy: Swift.Int?

        public init(
            licensePlate: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil
        )
        {
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteMatrixHazardousCargoType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case combustible
        case corrosive
        case explosive
        case flammable
        case gas
        case harmfulToWater
        case organic
        case other
        case poison
        case poisonousInhalation
        case radioactive
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixHazardousCargoType] {
            return [
                .combustible,
                .corrosive,
                .explosive,
                .flammable,
                .gas,
                .harmfulToWater,
                .organic,
                .other,
                .poison,
                .poisonousInhalation,
                .radioactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .combustible: return "Combustible"
            case .corrosive: return "Corrosive"
            case .explosive: return "Explosive"
            case .flammable: return "Flammable"
            case .gas: return "Gas"
            case .harmfulToWater: return "HarmfulToWater"
            case .organic: return "Organic"
            case .other: return "Other"
            case .poison: return "Poison"
            case .poisonousInhalation: return "PoisonousInhalation"
            case .radioactive: return "Radioactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Trailer options corresponding to the vehicle.
    public struct RouteMatrixTrailerOptions: Swift.Sendable {
        /// Number of trailers attached to the vehicle. Default Value: 0
        public var trailerCount: Swift.Int?

        public init(
            trailerCount: Swift.Int? = nil
        )
        {
            self.trailerCount = trailerCount
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteMatrixTruckType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lightTruck
        case straightTruck
        case tractor
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixTruckType] {
            return [
                .lightTruck,
                .straightTruck,
                .tractor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lightTruck: return "LightTruck"
            case .straightTruck: return "StraightTruck"
            case .tractor: return "Tractor"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Truck"
    public struct RouteMatrixTruckOptions: Swift.Sendable {
        /// Total number of axles of the vehicle.
        public var axleCount: Swift.Int?
        /// Gross weight of the vehicle including trailers, and goods at capacity.
        public var grossWeight: Swift.Int
        /// List of Hazardous cargos contained in the vehicle.
        public var hazardousCargos: [GeoRoutesClientTypes.RouteMatrixHazardousCargoType]?
        /// Height of the vehicle in centimeters.
        public var height: Swift.Int
        /// Kingpin to rear axle length of the vehicle in meters.
        public var kpraLength: Swift.Int
        /// Length of the vehicle in meters.
        public var length: Swift.Int
        public var licensePlate: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate?
        /// Maximum speed specified in Kilometers per hour.
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?
        /// Payload capacity of the vehicle and trailers attached.
        public var payloadCapacity: Swift.Int
        /// Trailer options corresponding to the vehicle.
        public var trailer: GeoRoutesClientTypes.RouteMatrixTrailerOptions?
        /// Type of the truck.
        public var truckType: GeoRoutesClientTypes.RouteMatrixTruckType?
        /// The tunnel restriction code.
        public var tunnelRestrictionCode: Swift.String?
        /// Heaviest weight per axle irrespective of the axle type or the axle group. Meant for usage in countries where the differences in axle types or axle groups are not distinguished. Unit: Kilograms
        public var weightPerAxle: Swift.Int
        /// Specifies the total weight for the specified axle group. Meant for usage in countries that have different regulations based on the axle group type.
        public var weightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup?
        /// Width of the vehicle in centimenters.
        public var width: Swift.Int

        public init(
            axleCount: Swift.Int? = nil,
            grossWeight: Swift.Int = 0,
            hazardousCargos: [GeoRoutesClientTypes.RouteMatrixHazardousCargoType]? = nil,
            height: Swift.Int = 0,
            kpraLength: Swift.Int = 0,
            length: Swift.Int = 0,
            licensePlate: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil,
            payloadCapacity: Swift.Int = 0,
            trailer: GeoRoutesClientTypes.RouteMatrixTrailerOptions? = nil,
            truckType: GeoRoutesClientTypes.RouteMatrixTruckType? = nil,
            tunnelRestrictionCode: Swift.String? = nil,
            weightPerAxle: Swift.Int = 0,
            weightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup? = nil,
            width: Swift.Int = 0
        )
        {
            self.axleCount = axleCount
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.kpraLength = kpraLength
            self.length = length
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
            self.payloadCapacity = payloadCapacity
            self.trailer = trailer
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.weightPerAxle = weightPerAxle
            self.weightPerAxleGroup = weightPerAxleGroup
            self.width = width
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode related options for the provided travel mode.
    public struct RouteMatrixTravelModeOptions: Swift.Sendable {
        /// Travel mode options when the provided travel mode is "Car"
        public var car: GeoRoutesClientTypes.RouteMatrixCarOptions?
        public var scooter: GeoRoutesClientTypes.RouteMatrixScooterOptions?
        /// Travel mode options when the provided travel mode is "Truck"
        public var truck: GeoRoutesClientTypes.RouteMatrixTruckOptions?

        public init(
            car: GeoRoutesClientTypes.RouteMatrixCarOptions? = nil,
            scooter: GeoRoutesClientTypes.RouteMatrixScooterOptions? = nil,
            truck: GeoRoutesClientTypes.RouteMatrixTruckOptions? = nil
        )
        {
            self.car = car
            self.scooter = scooter
            self.truck = truck
        }
    }
}

public struct CalculateRouteMatrixInput: Swift.Sendable {
    /// Features that are allowed while calculation.
    public var allow: GeoRoutesClientTypes.RouteMatrixAllowOptions?
    /// Features that are avoided while calculation. Avoidance is on a best-case basis.If an avoidance cannot be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.
    public var avoid: GeoRoutesClientTypes.RouteMatrixAvoidanceOptions?
    /// Uses the current time as the time of departure.
    public var departNow: Swift.Bool?
    /// Time of departure for Origin. Template:YYYY-MM-DDThh:mm:ss.sssZ YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var departureTime: Swift.String?
    /// List of destinations for the route.
    /// This member is required.
    public var destinations: [GeoRoutesClientTypes.RouteMatrixDestination]?
    /// Features to be strictly excluded for calculation.
    public var exclude: GeoRoutesClientTypes.RouteMatrixExclusionOptions?
    /// Optional: The API key to be used for authorization. Optional, either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// Specifies the optimization criteria for calculating a route. Default Value: FastestRoute
    public var optimizeRoutingFor: GeoRoutesClientTypes.RoutingObjective?
    /// The position in longitude and latitude for the origin.
    /// This member is required.
    public var origins: [GeoRoutesClientTypes.RouteMatrixOrigin]?
    /// Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid.
    /// This member is required.
    public var routingBoundary: GeoRoutesClientTypes.RouteMatrixBoundary?
    /// Traffic related options.
    public var traffic: GeoRoutesClientTypes.RouteMatrixTrafficOptions?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value:Car
    public var travelMode: GeoRoutesClientTypes.RouteMatrixTravelMode?
    /// Travel mode related options for the provided travel mode.
    public var travelModeOptions: GeoRoutesClientTypes.RouteMatrixTravelModeOptions?

    public init(
        allow: GeoRoutesClientTypes.RouteMatrixAllowOptions? = nil,
        avoid: GeoRoutesClientTypes.RouteMatrixAvoidanceOptions? = nil,
        departNow: Swift.Bool? = nil,
        departureTime: Swift.String? = nil,
        destinations: [GeoRoutesClientTypes.RouteMatrixDestination]? = nil,
        exclude: GeoRoutesClientTypes.RouteMatrixExclusionOptions? = nil,
        key: Swift.String? = nil,
        optimizeRoutingFor: GeoRoutesClientTypes.RoutingObjective? = nil,
        origins: [GeoRoutesClientTypes.RouteMatrixOrigin]? = nil,
        routingBoundary: GeoRoutesClientTypes.RouteMatrixBoundary? = nil,
        traffic: GeoRoutesClientTypes.RouteMatrixTrafficOptions? = nil,
        travelMode: GeoRoutesClientTypes.RouteMatrixTravelMode? = nil,
        travelModeOptions: GeoRoutesClientTypes.RouteMatrixTravelModeOptions? = nil
    )
    {
        self.allow = allow
        self.avoid = avoid
        self.departNow = departNow
        self.departureTime = departureTime
        self.destinations = destinations
        self.exclude = exclude
        self.key = key
        self.optimizeRoutingFor = optimizeRoutingFor
        self.origins = origins
        self.routingBoundary = routingBoundary
        self.traffic = traffic
        self.travelMode = travelMode
        self.travelModeOptions = travelModeOptions
    }
}

extension CalculateRouteMatrixInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteMatrixInput(allow: \(Swift.String(describing: allow)), avoid: \(Swift.String(describing: avoid)), departNow: \(Swift.String(describing: departNow)), departureTime: \(Swift.String(describing: departureTime)), destinations: \(Swift.String(describing: destinations)), exclude: \(Swift.String(describing: exclude)), optimizeRoutingFor: \(Swift.String(describing: optimizeRoutingFor)), origins: \(Swift.String(describing: origins)), routingBoundary: \(Swift.String(describing: routingBoundary)), traffic: \(Swift.String(describing: traffic)), travelMode: \(Swift.String(describing: travelMode)), travelModeOptions: \(Swift.String(describing: travelModeOptions)), key: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    public enum RouteMatrixErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case noMatch
        case noMatchDestination
        case noMatchOrigin
        case noRoute
        case other
        case outOfBounds
        case outOfBoundsDestination
        case outOfBoundsOrigin
        case violation
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixErrorCode] {
            return [
                .noMatch,
                .noMatchDestination,
                .noMatchOrigin,
                .noRoute,
                .other,
                .outOfBounds,
                .outOfBoundsDestination,
                .outOfBoundsOrigin,
                .violation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .noMatch: return "NoMatch"
            case .noMatchDestination: return "NoMatchDestination"
            case .noMatchOrigin: return "NoMatchOrigin"
            case .noRoute: return "NoRoute"
            case .other: return "Other"
            case .outOfBounds: return "OutOfBounds"
            case .outOfBoundsDestination: return "OutOfBoundsDestination"
            case .outOfBoundsOrigin: return "OutOfBoundsOrigin"
            case .violation: return "Violation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The calculated route matrix containing the results for all pairs of Origins to Destination positions. Each row corresponds to one entry in Origins. Each entry in the row corresponds to the route from that entry in Origins to an entry in Destination positions.
    public struct RouteMatrixEntry: Swift.Sendable {
        /// The total distance of travel for the route.
        /// This member is required.
        public var distance: Swift.Int
        /// The expected duration of travel for the route.
        /// This member is required.
        public var duration: Swift.Int
        /// Error code that occurred during calculation of the route.
        public var error: GeoRoutesClientTypes.RouteMatrixErrorCode?

        public init(
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            error: GeoRoutesClientTypes.RouteMatrixErrorCode? = nil
        )
        {
            self.distance = distance
            self.duration = duration
            self.error = error
        }
    }
}

public struct CalculateRouteMatrixOutput: Swift.Sendable {
    /// The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.
    /// This member is required.
    public var errorCount: Swift.Int?
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// The calculated route matrix containing the results for all pairs of Origins to Destination positions. Each row corresponds to one entry in Origins. Each entry in the row corresponds to the route from that entry in Origins to an entry in Destination positions.
    /// This member is required.
    public var routeMatrix: [[GeoRoutesClientTypes.RouteMatrixEntry]]?
    /// Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid.
    /// This member is required.
    public var routingBoundary: GeoRoutesClientTypes.RouteMatrixBoundary?

    public init(
        errorCount: Swift.Int? = nil,
        pricingBucket: Swift.String? = nil,
        routeMatrix: [[GeoRoutesClientTypes.RouteMatrixEntry]]? = nil,
        routingBoundary: GeoRoutesClientTypes.RouteMatrixBoundary? = nil
    )
    {
        self.errorCount = errorCount
        self.pricingBucket = pricingBucket
        self.routeMatrix = routeMatrix
        self.routingBoundary = routingBoundary
    }
}

extension GeoRoutesClientTypes {

    /// Features that are allowed while calculation.
    public struct RouteAllowOptions: Swift.Sendable {
        /// Allow Hot (High Occupancy Toll) lanes for calculation.
        public var hot: Swift.Bool?
        /// Allow Hov (High Occupancy vehicle) lanes for calculation.
        public var hov: Swift.Bool?

        public init(
            hot: Swift.Bool? = nil,
            hov: Swift.Bool? = nil
        )
        {
            self.hot = hot
            self.hov = hov
        }
    }
}

extension GeoRoutesClientTypes {

    /// Geometry of the area to be avoided.
    public struct RouteAvoidanceAreaGeometry: Swift.Sendable {
        /// Gometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public var boundingBox: [Swift.Double]?
        /// Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.
        public var corridor: GeoRoutesClientTypes.Corridor?
        /// Geometry defined as a polygon with only one linear ring.
        public var polygon: [[[Swift.Double]]]?
        /// Geometry defined as an encoded corridor - an encoded polyloine with a radius that defines the width of the corridor.
        public var polylineCorridor: GeoRoutesClientTypes.PolylineCorridor?
        /// A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings). For more information on polyline encoding, see [https://github.com/heremaps/flexiblepolyline/blob/master/README.md](https://github.com/heremaps/flexiblepolyline/blob/master/README.md).
        public var polylinePolygon: [Swift.String]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            corridor: GeoRoutesClientTypes.Corridor? = nil,
            polygon: [[[Swift.Double]]]? = nil,
            polylineCorridor: GeoRoutesClientTypes.PolylineCorridor? = nil,
            polylinePolygon: [Swift.String]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.corridor = corridor
            self.polygon = polygon
            self.polylineCorridor = polylineCorridor
            self.polylinePolygon = polylinePolygon
        }
    }
}

extension GeoRoutesClientTypes.RouteAvoidanceAreaGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteAvoidanceAreaGeometry(boundingBox: \"CONTENT_REDACTED\", corridor: \"CONTENT_REDACTED\", polygon: \"CONTENT_REDACTED\", polylineCorridor: \"CONTENT_REDACTED\", polylinePolygon: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Areas to be avoided.
    public struct RouteAvoidanceArea: Swift.Sendable {
        /// Exceptions to the provided avoidance geometry, to be included for calculation.
        public var except: [GeoRoutesClientTypes.RouteAvoidanceAreaGeometry]?
        /// Geometry of the area to be avoided.
        /// This member is required.
        public var geometry: GeoRoutesClientTypes.RouteAvoidanceAreaGeometry?

        public init(
            except: [GeoRoutesClientTypes.RouteAvoidanceAreaGeometry]? = nil,
            geometry: GeoRoutesClientTypes.RouteAvoidanceAreaGeometry? = nil
        )
        {
            self.except = except
            self.geometry = geometry
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteZoneCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case congestionPricing
        case environmental
        case vignette
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteZoneCategory] {
            return [
                .congestionPricing,
                .environmental,
                .vignette
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .congestionPricing: return "CongestionPricing"
            case .environmental: return "Environmental"
            case .vignette: return "Vignette"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Zone categories to be avoided.
    public struct RouteAvoidanceZoneCategory: Swift.Sendable {
        /// Zone category to be avoided.
        /// This member is required.
        public var category: GeoRoutesClientTypes.RouteZoneCategory?

        public init(
            category: GeoRoutesClientTypes.RouteZoneCategory? = nil
        )
        {
            self.category = category
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to areas to be avoided.
    public struct RouteAvoidanceOptions: Swift.Sendable {
        /// Areas to be avoided.
        public var areas: [GeoRoutesClientTypes.RouteAvoidanceArea]?
        /// Avoid car shuttle trains for calculation.
        public var carShuttleTrains: Swift.Bool?
        /// Avoid controlled access highways for calculation.
        public var controlledAccessHighways: Swift.Bool?
        /// Avoid dirt roads for calculation.
        public var dirtRoads: Swift.Bool?
        /// Avoid ferries for calculation.
        public var ferries: Swift.Bool?
        /// Avoid roads that have seasonal closure for calculation.
        public var seasonalClosure: Swift.Bool?
        /// Avoid toll roads for calculation.
        public var tollRoads: Swift.Bool?
        /// Avoid toll roads for calculation.
        public var tollTransponders: Swift.Bool?
        /// Truck road type identifiers to be avoided. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico. There are currently no other supported values as of 26th April 2024.
        public var truckRoadTypes: [Swift.String]?
        /// Avoid tunnels for calculation.
        public var tunnels: Swift.Bool?
        /// Avoid u turns for calculation on highways and motorways.
        public var uTurns: Swift.Bool?
        /// Zone categories to be avoided.
        public var zoneCategories: [GeoRoutesClientTypes.RouteAvoidanceZoneCategory]?

        public init(
            areas: [GeoRoutesClientTypes.RouteAvoidanceArea]? = nil,
            carShuttleTrains: Swift.Bool? = nil,
            controlledAccessHighways: Swift.Bool? = nil,
            dirtRoads: Swift.Bool? = nil,
            ferries: Swift.Bool? = nil,
            seasonalClosure: Swift.Bool? = nil,
            tollRoads: Swift.Bool? = nil,
            tollTransponders: Swift.Bool? = nil,
            truckRoadTypes: [Swift.String]? = nil,
            tunnels: Swift.Bool? = nil,
            uTurns: Swift.Bool? = nil,
            zoneCategories: [GeoRoutesClientTypes.RouteAvoidanceZoneCategory]? = nil
        )
        {
            self.areas = areas
            self.carShuttleTrains = carShuttleTrains
            self.controlledAccessHighways = controlledAccessHighways
            self.dirtRoads = dirtRoads
            self.ferries = ferries
            self.seasonalClosure = seasonalClosure
            self.tollRoads = tollRoads
            self.tollTransponders = tollTransponders
            self.truckRoadTypes = truckRoadTypes
            self.tunnels = tunnels
            self.uTurns = uTurns
            self.zoneCategories = zoneCategories
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to route matching.
    public struct RouteMatchingOptions: Swift.Sendable {
        /// Attempts to match the provided position to a road similar to the provided name.
        public var nameHint: Swift.String?
        /// If the distance to a highway/bridge/tunnel/sliproad is within threshold, the waypoint will be snapped to the highway/bridge/tunnel/sliproad.
        public var onRoadThreshold: Swift.Int
        /// Considers all roads within the provided radius to match the provided destination to. The roads that are considered are determined by the provided Strategy. Unit: Meters
        public var radius: Swift.Int
        /// Strategy that defines matching of the position onto the road network. MatchAny considers all roads possible, whereas MatchMostSignificantRoad matches to the most significant road.
        public var strategy: GeoRoutesClientTypes.MatchingStrategy?

        public init(
            nameHint: Swift.String? = nil,
            onRoadThreshold: Swift.Int = 0,
            radius: Swift.Int = 0,
            strategy: GeoRoutesClientTypes.MatchingStrategy? = nil
        )
        {
            self.nameHint = nameHint
            self.onRoadThreshold = onRoadThreshold
            self.radius = radius
            self.strategy = strategy
        }
    }
}

extension GeoRoutesClientTypes.RouteMatchingOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatchingOptions(onRoadThreshold: \(Swift.String(describing: onRoadThreshold)), radius: \(Swift.String(describing: radius)), strategy: \(Swift.String(describing: strategy)), nameHint: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Options to configure matching the provided position to a side of the street.
    public struct RouteSideOfStreetOptions: Swift.Sendable {
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?
        /// Strategy that defines when the side of street position should be used. AnyStreet will always use the provided position. Default Value: DividedStreetOnly Default Value: DividedStreetOnly
        public var useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy?

        public init(
            position: [Swift.Double]? = nil,
            useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy? = nil
        )
        {
            self.position = position
            self.useWith = useWith
        }
    }
}

extension GeoRoutesClientTypes.RouteSideOfStreetOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteSideOfStreetOptions(useWith: \(Swift.String(describing: useWith)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Options related to the destination.
    public struct RouteDestinationOptions: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// Avoid u turns for calculation on highways and motorways.
        public var avoidUTurns: Swift.Bool?
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.RouteMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreetOptions?
        /// Duration of the stop.
        public var stopDuration: Swift.Int

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            avoidUTurns: Swift.Bool? = nil,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.RouteMatchingOptions? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreetOptions? = nil,
            stopDuration: Swift.Int = 0
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.avoidUTurns = avoidUTurns
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
            self.stopDuration = stopDuration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Interval of the driver work-rest schedule. Stops are added to fulfil the provided rest schedule.
    public struct RouteDriverScheduleInterval: Swift.Sendable {
        /// Maximum allowed driving time before stopping to rest.
        /// This member is required.
        public var driveDuration: Swift.Int
        /// Resting time before the driver can continue driving.
        /// This member is required.
        public var restDuration: Swift.Int

        public init(
            driveDuration: Swift.Int = 0,
            restDuration: Swift.Int = 0
        )
        {
            self.driveDuration = driveDuration
            self.restDuration = restDuration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Driver related options.
    public struct RouteDriverOptions: Swift.Sendable {
        /// Driver work-rest schedule. Stops are added to fulfil the provided rest schedule.
        public var schedule: [GeoRoutesClientTypes.RouteDriverScheduleInterval]?

        public init(
            schedule: [GeoRoutesClientTypes.RouteDriverScheduleInterval]? = nil
        )
        {
            self.schedule = schedule
        }
    }
}

extension GeoRoutesClientTypes {

    /// Excludsion options for the route.
    public struct RouteExclusionOptions: Swift.Sendable {
        /// List of countries to be avoided defined by two-letter or three-letter country codes.
        /// This member is required.
        public var countries: [Swift.String]?

        public init(
            countries: [Swift.String]? = nil
        )
        {
            self.countries = countries
        }
    }
}

extension GeoRoutesClientTypes {

    public enum MeasurementSystem: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case imperial
        case metric
        case sdkUnknown(Swift.String)

        public static var allCases: [MeasurementSystem] {
            return [
                .imperial,
                .metric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .imperial: return "Imperial"
            case .metric: return "Metric"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteLegAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case elevation
        case incidents
        case passThroughWaypoints
        case summary
        case tolls
        case travelStepInstructions
        case truckRoadTypes
        case typicalDuration
        case zones
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteLegAdditionalFeature] {
            return [
                .elevation,
                .incidents,
                .passThroughWaypoints,
                .summary,
                .tolls,
                .travelStepInstructions,
                .truckRoadTypes,
                .typicalDuration,
                .zones
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .elevation: return "Elevation"
            case .incidents: return "Incidents"
            case .passThroughWaypoints: return "PassThroughWaypoints"
            case .summary: return "Summary"
            case .tolls: return "Tolls"
            case .travelStepInstructions: return "TravelStepInstructions"
            case .truckRoadTypes: return "TruckRoadTypes"
            case .typicalDuration: return "TypicalDuration"
            case .zones: return "Zones"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Origin related options.
    public struct RouteOriginOptions: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// Avoid u turns for calculation on highways and motorways.
        public var avoidUTurns: Swift.Bool?
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.RouteMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreetOptions?

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            avoidUTurns: Swift.Bool? = nil,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.RouteMatchingOptions? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreetOptions? = nil
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.avoidUTurns = avoidUTurns
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bestCaseDuration
        case carAccess
        case consumption
        case country
        case distance
        case duration
        case dynamicSpeed
        case functionalClassification
        case gates
        case incidents
        case names
        case notices
        case pedestrianAccess
        case railwayCrossings
        case region
        case roadAttributes
        case routeNumbers
        case scooterAccess
        case speedLimit
        case tollSystems
        case truckAccess
        case truckRoadTypes
        case typicalDuration
        case zones
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanAdditionalFeature] {
            return [
                .bestCaseDuration,
                .carAccess,
                .consumption,
                .country,
                .distance,
                .duration,
                .dynamicSpeed,
                .functionalClassification,
                .gates,
                .incidents,
                .names,
                .notices,
                .pedestrianAccess,
                .railwayCrossings,
                .region,
                .roadAttributes,
                .routeNumbers,
                .scooterAccess,
                .speedLimit,
                .tollSystems,
                .truckAccess,
                .truckRoadTypes,
                .typicalDuration,
                .zones
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bestCaseDuration: return "BestCaseDuration"
            case .carAccess: return "CarAccess"
            case .consumption: return "Consumption"
            case .country: return "Country"
            case .distance: return "Distance"
            case .duration: return "Duration"
            case .dynamicSpeed: return "DynamicSpeed"
            case .functionalClassification: return "FunctionalClassification"
            case .gates: return "Gates"
            case .incidents: return "Incidents"
            case .names: return "Names"
            case .notices: return "Notices"
            case .pedestrianAccess: return "PedestrianAccess"
            case .railwayCrossings: return "RailwayCrossings"
            case .region: return "Region"
            case .roadAttributes: return "RoadAttributes"
            case .routeNumbers: return "RouteNumbers"
            case .scooterAccess: return "ScooterAccess"
            case .speedLimit: return "SpeedLimit"
            case .tollSystems: return "TollSystems"
            case .truckAccess: return "TruckAccess"
            case .truckRoadTypes: return "TruckRoadTypes"
            case .typicalDuration: return "TypicalDuration"
            case .zones: return "Zones"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Type of the emission.
    public struct RouteEmissionType: Swift.Sendable {
        /// The CO 2 emission classes.
        public var co2EmissionClass: Swift.String?
        /// Type of the emission.
        /// This member is required.
        public var type: Swift.String?

        public init(
            co2EmissionClass: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.co2EmissionClass = co2EmissionClass
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTollVehicleCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case minibus
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTollVehicleCategory] {
            return [
                .minibus
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .minibus: return "Minibus"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to Tolls on a route.
    public struct RouteTollOptions: Swift.Sendable {
        /// Specifies if the user has valid transponder with access to all toll systems. This impacts toll calculation, and if true the price with tranponders is used.
        public var allTransponders: Swift.Bool?
        /// Specifies if the user has valid vignettes with access for all toll roads. If a user has a vignette for a toll road, then toll cost for that road is omitted since no further payment is necessary.
        public var allVignettes: Swift.Bool?
        /// Currency code corresponding to the price. This is the same as Currency specified in the request.
        public var currency: Swift.String?
        /// Emission type of the vehicle for toll cost calculation.
        public var emissionType: GeoRoutesClientTypes.RouteEmissionType?
        /// Vehicle category for toll cost calculation.
        public var vehicleCategory: GeoRoutesClientTypes.RouteTollVehicleCategory?

        public init(
            allTransponders: Swift.Bool? = nil,
            allVignettes: Swift.Bool? = nil,
            currency: Swift.String? = nil,
            emissionType: GeoRoutesClientTypes.RouteEmissionType? = nil,
            vehicleCategory: GeoRoutesClientTypes.RouteTollVehicleCategory? = nil
        )
        {
            self.allTransponders = allTransponders
            self.allVignettes = allVignettes
            self.currency = currency
            self.emissionType = emissionType
            self.vehicleCategory = vehicleCategory
        }
    }
}

extension GeoRoutesClientTypes {

    /// Traffic options for the route.
    public struct RouteTrafficOptions: Swift.Sendable {
        /// Duration for which flow traffic is considered valid. For this period, the flow traffic is used over historical traffic data. Flow traffic refers to congestion, which changes very quickly. Duration in seconds for which flow traffic event would be considered valid. While flow traffic event is valid it will be used over the historical traffic data.
        public var flowEventThresholdOverride: Swift.Int
        /// Determines if traffic should be used or ignored for calculation. Default Value: UseTrafficData
        public var usage: GeoRoutesClientTypes.TrafficUsage?

        public init(
            flowEventThresholdOverride: Swift.Int = 0,
            usage: GeoRoutesClientTypes.TrafficUsage? = nil
        )
        {
            self.flowEventThresholdOverride = flowEventThresholdOverride
            self.usage = usage
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTravelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case car
        case pedestrian
        case scooter
        case truck
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTravelMode] {
            return [
                .car,
                .pedestrian,
                .scooter,
                .truck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .pedestrian: return "Pedestrian"
            case .scooter: return "Scooter"
            case .truck: return "Truck"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteEngineType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case electric
        case internalCombustion
        case pluginHybrid
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteEngineType] {
            return [
                .electric,
                .internalCombustion,
                .pluginHybrid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .electric: return "Electric"
            case .internalCombustion: return "InternalCombustion"
            case .pluginHybrid: return "PluginHybrid"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// LicensePlate information of the vehicle. Currently, only the last character is used wehre license plate based controlled access is enforced.
    public struct RouteVehicleLicensePlate: Swift.Sendable {
        /// The last character of the License Plate.
        public var lastCharacter: Swift.String?

        public init(
            lastCharacter: Swift.String? = nil
        )
        {
            self.lastCharacter = lastCharacter
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Car"
    public struct RouteCarOptions: Swift.Sendable {
        /// Engine type of the vehicle.
        public var engineType: GeoRoutesClientTypes.RouteEngineType?
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.RouteVehicleLicensePlate?
        /// Maximum speed specified in Kilometers per hour.
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?

        public init(
            engineType: GeoRoutesClientTypes.RouteEngineType? = nil,
            licensePlate: GeoRoutesClientTypes.RouteVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil
        )
        {
            self.engineType = engineType
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }
    }
}

extension GeoRoutesClientTypes {

    /// Charging rate at the provided charging level.
    public struct ChargingRateAtChargeLevel: Swift.Sendable {
        /// The charging level.
        /// This member is required.
        public var chargingLevel: Swift.Double
        /// The charge rate.
        /// This member is required.
        public var chargingRate: Swift.Double

        public init(
            chargingLevel: Swift.Double = 0.0,
            chargingRate: Swift.Double = 0.0
        )
        {
            self.chargingLevel = chargingLevel
            self.chargingRate = chargingRate
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteChargingConnectorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ccs1
        case ccs2
        case chademo
        case gbtDc
        case nacs
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteChargingConnectorType] {
            return [
                .ccs1,
                .ccs2,
                .chademo,
                .gbtDc,
                .nacs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ccs1: return "Ccs1"
            case .ccs2: return "Ccs2"
            case .chademo: return "Chademo"
            case .gbtDc: return "GbtDc"
            case .nacs: return "Nacs"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Rate of energy consumed by the vehicle's auxiliary systems like lights, or air conditioning, at the current vehicle speed.
    public struct ConsumptionRateAtSpeed: Swift.Sendable {
        /// Rate of energy consumed by the vehicle's auxiliary systems like lights, or air conditioning. Unit: Kw/H
        /// This member is required.
        public var consumptionRate: Swift.Double?
        /// The current vehicle speed in Kilometers per hour. Unit: Km/H Default Value: 3.6
        /// This member is required.
        public var speed: Swift.Double

        public init(
            consumptionRate: Swift.Double? = nil,
            speed: Swift.Double = 0.0
        )
        {
            self.consumptionRate = consumptionRate
            self.speed = speed
        }
    }
}

extension GeoRoutesClientTypes {

    /// Electric Vehicle (Ev) related options.
    public struct RouteEvOptions: Swift.Sendable {
        /// Rate of energy consumed by the vehicle's auxiliary systems like lights, or air conditioning. Unit: Kw/H
        public var auxiliaryConsumptionRate: Swift.Double
        /// Curve defining the maximum battery charging rate at a given charge level.
        public var chargingCurve: [GeoRoutesClientTypes.ChargingRateAtChargeLevel]?
        /// Time required to setup charging at a charging station. This is after arriving at the station and before charging itself.
        public var chargingSetupDuration: Swift.Int
        /// Connector types that are compatible with the vehicle. ChargingTime in the response is based on the connector type with the highest power rating, if multiple connector types are specified.
        public var connectorTypes: [GeoRoutesClientTypes.RouteChargingConnectorType]?
        /// Rate of energy consumed per meter rise in elevation. Unit: Watt-hours / meter
        public var consumptionRateOnAscent: Swift.Double
        /// Rate of energy consumer per meter fall in elevation. Unit: Watt-hours / meter
        public var consumptionRateOnDescent: Swift.Double
        /// Curve specifying the consumption rate at a given speed, in free flowing traffic.
        public var freeFlowConsumptionCurve: [GeoRoutesClientTypes.ConsumptionRateAtSpeed]?
        /// When set to true, the route calculated ensures that the required charging constraints are satisifed. If charging stations need to be added to attain reachability, they are.
        public var makeReachable: Swift.Bool?
        /// Total capacity of the battery.
        public var maxCharge: Swift.Double
        /// Maximum charge to which the battery should be charged at a charging station.
        public var maxChargeDepartingFromChargingStation: Swift.Double
        /// Maximum charging current supported by the battery.
        public var maxChargingCurrent: Swift.Double
        /// Maximum charging voltage supported by the battery.
        public var maxChargingVoltage: Swift.Double
        /// Estimated vehicle battery charge before this step (in kWh).
        public var minChargeArrivingAtChargingStation: Swift.Double
        /// Minimum charge possible when arriviing at the destination.
        public var minChargeArrivingAtDestination: Swift.Double
        /// Estimated vehicle battery charge before this step (in kWh).
        public var minChargeArrivingAtFirstChargingStation: Swift.Double
        /// Charge at the origin.
        public var originCharge: Swift.Double
        /// Curve specifying the consumption rate at a given speed, at traffic reduced speed on a flat stretch of road.
        public var trafficConsumptionCurve: [GeoRoutesClientTypes.ConsumptionRateAtSpeed]?

        public init(
            auxiliaryConsumptionRate: Swift.Double = 0.0,
            chargingCurve: [GeoRoutesClientTypes.ChargingRateAtChargeLevel]? = nil,
            chargingSetupDuration: Swift.Int = 0,
            connectorTypes: [GeoRoutesClientTypes.RouteChargingConnectorType]? = nil,
            consumptionRateOnAscent: Swift.Double = 0.0,
            consumptionRateOnDescent: Swift.Double = 0.0,
            freeFlowConsumptionCurve: [GeoRoutesClientTypes.ConsumptionRateAtSpeed]? = nil,
            makeReachable: Swift.Bool? = nil,
            maxCharge: Swift.Double = 0.0,
            maxChargeDepartingFromChargingStation: Swift.Double = 0.0,
            maxChargingCurrent: Swift.Double = 0.0,
            maxChargingVoltage: Swift.Double = 0.0,
            minChargeArrivingAtChargingStation: Swift.Double = 0.0,
            minChargeArrivingAtDestination: Swift.Double = 0.0,
            minChargeArrivingAtFirstChargingStation: Swift.Double = 0.0,
            originCharge: Swift.Double = 0.0,
            trafficConsumptionCurve: [GeoRoutesClientTypes.ConsumptionRateAtSpeed]? = nil
        )
        {
            self.auxiliaryConsumptionRate = auxiliaryConsumptionRate
            self.chargingCurve = chargingCurve
            self.chargingSetupDuration = chargingSetupDuration
            self.connectorTypes = connectorTypes
            self.consumptionRateOnAscent = consumptionRateOnAscent
            self.consumptionRateOnDescent = consumptionRateOnDescent
            self.freeFlowConsumptionCurve = freeFlowConsumptionCurve
            self.makeReachable = makeReachable
            self.maxCharge = maxCharge
            self.maxChargeDepartingFromChargingStation = maxChargeDepartingFromChargingStation
            self.maxChargingCurrent = maxChargingCurrent
            self.maxChargingVoltage = maxChargingVoltage
            self.minChargeArrivingAtChargingStation = minChargeArrivingAtChargingStation
            self.minChargeArrivingAtDestination = minChargeArrivingAtDestination
            self.minChargeArrivingAtFirstChargingStation = minChargeArrivingAtFirstChargingStation
            self.originCharge = originCharge
            self.trafficConsumptionCurve = trafficConsumptionCurve
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to the pedestrian.
    public struct RoutePedestrianOptions: Swift.Sendable {
        /// Walking speed in Kilometers per hour.
        public var speed: Swift.Double?

        public init(
            speed: Swift.Double? = 0.0
        )
        {
            self.speed = speed
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Scooter"
    public struct RouteScooterOptions: Swift.Sendable {
        /// Engine type of the vehicle.
        public var engineType: GeoRoutesClientTypes.RouteEngineType?
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.RouteVehicleLicensePlate?
        /// Maximum speed specified in Kilometers per hour.
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?

        public init(
            engineType: GeoRoutesClientTypes.RouteEngineType? = nil,
            licensePlate: GeoRoutesClientTypes.RouteVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil
        )
        {
            self.engineType = engineType
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteHazardousCargoType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case combustible
        case corrosive
        case explosive
        case flammable
        case gas
        case harmfulToWater
        case organic
        case other
        case poison
        case poisonousInhalation
        case radioactive
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteHazardousCargoType] {
            return [
                .combustible,
                .corrosive,
                .explosive,
                .flammable,
                .gas,
                .harmfulToWater,
                .organic,
                .other,
                .poison,
                .poisonousInhalation,
                .radioactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .combustible: return "Combustible"
            case .corrosive: return "Corrosive"
            case .explosive: return "Explosive"
            case .flammable: return "Flammable"
            case .gas: return "Gas"
            case .harmfulToWater: return "HarmfulToWater"
            case .organic: return "Organic"
            case .other: return "Other"
            case .poison: return "Poison"
            case .poisonousInhalation: return "PoisonousInhalation"
            case .radioactive: return "Radioactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Trailer options corresponding to the vehicle.
    public struct RouteTrailerOptions: Swift.Sendable {
        /// Total number of axles of the vehicle.
        public var axleCount: Swift.Int?
        /// Number of trailers attached to the vehicle. Default Value: 0
        public var trailerCount: Swift.Int?

        public init(
            axleCount: Swift.Int? = nil,
            trailerCount: Swift.Int? = nil
        )
        {
            self.axleCount = axleCount
            self.trailerCount = trailerCount
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTruckType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lightTruck
        case straightTruck
        case tractor
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTruckType] {
            return [
                .lightTruck,
                .straightTruck,
                .tractor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lightTruck: return "LightTruck"
            case .straightTruck: return "StraightTruck"
            case .tractor: return "Tractor"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Truck"
    public struct RouteTruckOptions: Swift.Sendable {
        /// Total number of axles of the vehicle.
        public var axleCount: Swift.Int?
        /// Engine type of the vehicle.
        public var engineType: GeoRoutesClientTypes.RouteEngineType?
        /// Gross weight of the vehicle including trailers, and goods at capacity.
        public var grossWeight: Swift.Int
        /// List of Hazardous cargos contained in the vehicle.
        public var hazardousCargos: [GeoRoutesClientTypes.RouteHazardousCargoType]?
        /// Height of the vehicle in centimeters.
        public var height: Swift.Int
        /// Height of the vehicle above its first axle in centimeters.
        public var heightAboveFirstAxle: Swift.Int
        /// Kingpin to rear axle length of the vehicle in meters.
        public var kpraLength: Swift.Int
        /// Length of the vehicle in meters.
        public var length: Swift.Int
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.RouteVehicleLicensePlate?
        /// Maximum speed specified in Kilometers per hour.
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?
        /// Payload capacity of the vehicle and trailers attached.
        public var payloadCapacity: Swift.Int
        /// Number of tires on the vehicle.
        public var tireCount: Swift.Int?
        /// Trailer options corresponding to the vehicle.
        public var trailer: GeoRoutesClientTypes.RouteTrailerOptions?
        /// Type of the truck.
        public var truckType: GeoRoutesClientTypes.RouteTruckType?
        /// The tunnel restriction code.
        public var tunnelRestrictionCode: Swift.String?
        /// Heaviest weight per axle irrespective of the axle type or the axle group. Meant for usage in countries where the differences in axle types or axle groups are not distinguished. Unit: Kilograms
        public var weightPerAxle: Swift.Int
        /// Specifies the total weight for the specified axle group. Meant for usage in countries that have different regulations based on the axle group type.
        public var weightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup?
        /// Width of the vehicle in centimenters.
        public var width: Swift.Int

        public init(
            axleCount: Swift.Int? = nil,
            engineType: GeoRoutesClientTypes.RouteEngineType? = nil,
            grossWeight: Swift.Int = 0,
            hazardousCargos: [GeoRoutesClientTypes.RouteHazardousCargoType]? = nil,
            height: Swift.Int = 0,
            heightAboveFirstAxle: Swift.Int = 0,
            kpraLength: Swift.Int = 0,
            length: Swift.Int = 0,
            licensePlate: GeoRoutesClientTypes.RouteVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil,
            payloadCapacity: Swift.Int = 0,
            tireCount: Swift.Int? = nil,
            trailer: GeoRoutesClientTypes.RouteTrailerOptions? = nil,
            truckType: GeoRoutesClientTypes.RouteTruckType? = nil,
            tunnelRestrictionCode: Swift.String? = nil,
            weightPerAxle: Swift.Int = 0,
            weightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup? = nil,
            width: Swift.Int = 0
        )
        {
            self.axleCount = axleCount
            self.engineType = engineType
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.heightAboveFirstAxle = heightAboveFirstAxle
            self.kpraLength = kpraLength
            self.length = length
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
            self.payloadCapacity = payloadCapacity
            self.tireCount = tireCount
            self.trailer = trailer
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.weightPerAxle = weightPerAxle
            self.weightPerAxleGroup = weightPerAxleGroup
            self.width = width
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode related options for the provided travel mode.
    public struct RouteTravelModeOptions: Swift.Sendable {
        /// Travel mode options when the provided travel mode is "Car"
        public var car: GeoRoutesClientTypes.RouteCarOptions?
        /// Ev option if the vehicle is electric powered.
        public var ev: GeoRoutesClientTypes.RouteEvOptions?
        /// Travel mode options when the provided travel mode is "Pedestrian"
        public var pedestrian: GeoRoutesClientTypes.RoutePedestrianOptions?
        /// Travel mode options when the provided travel mode is "Scooter"
        public var scooter: GeoRoutesClientTypes.RouteScooterOptions?
        /// Travel mode options when the provided travel mode is "Truck"
        public var truck: GeoRoutesClientTypes.RouteTruckOptions?

        public init(
            car: GeoRoutesClientTypes.RouteCarOptions? = nil,
            ev: GeoRoutesClientTypes.RouteEvOptions? = nil,
            pedestrian: GeoRoutesClientTypes.RoutePedestrianOptions? = nil,
            scooter: GeoRoutesClientTypes.RouteScooterOptions? = nil,
            truck: GeoRoutesClientTypes.RouteTruckOptions? = nil
        )
        {
            self.car = car
            self.ev = ev
            self.pedestrian = pedestrian
            self.scooter = scooter
            self.truck = truck
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case turnByTurn
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTravelStepType] {
            return [
                .default,
                .turnByTurn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "Default"
            case .turnByTurn: return "TurnByTurn"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// List of waypoints between the Origin and Destination.
    public struct RouteWaypoint: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// Avoid u turns for calculation on highways and motorways.
        public var avoidUTurns: Swift.Bool?
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.RouteMatchingOptions?
        /// If the waypoint should be treated as a stop. If yes, the route is split up into different legs around the stop.
        public var passThrough: Swift.Bool?
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreetOptions?
        /// Duration of the stop.
        public var stopDuration: Swift.Int

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            avoidUTurns: Swift.Bool? = nil,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.RouteMatchingOptions? = nil,
            passThrough: Swift.Bool? = nil,
            position: [Swift.Double]? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreetOptions? = nil,
            stopDuration: Swift.Int = 0
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.avoidUTurns = avoidUTurns
            self.heading = heading
            self.matching = matching
            self.passThrough = passThrough
            self.position = position
            self.sideOfStreet = sideOfStreet
            self.stopDuration = stopDuration
        }
    }
}

extension GeoRoutesClientTypes.RouteWaypoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteWaypoint(avoidActionsForDistance: \(Swift.String(describing: avoidActionsForDistance)), avoidUTurns: \(Swift.String(describing: avoidUTurns)), heading: \(Swift.String(describing: heading)), matching: \(Swift.String(describing: matching)), passThrough: \(Swift.String(describing: passThrough)), sideOfStreet: \(Swift.String(describing: sideOfStreet)), stopDuration: \(Swift.String(describing: stopDuration)), position: \"CONTENT_REDACTED\")"}
}

public struct CalculateRoutesInput: Swift.Sendable {
    /// Features that are allowed while calculation.
    public var allow: GeoRoutesClientTypes.RouteAllowOptions?
    /// Time of arrival at the destination. This parameter is returned only if the Destination parameters was provided in the request. Template:YYYY-MM-DDThh:mm:ss.sssZ YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var arrivalTime: Swift.String?
    /// Features that are avoided while calculation. Avoidance is on a best-case basis.If an avoidance cannot be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.
    public var avoid: GeoRoutesClientTypes.RouteAvoidanceOptions?
    /// Uses the current time as the time of departure.
    public var departNow: Swift.Bool?
    /// Time of departure for Origin. Template:YYYY-MM-DDThh:mm:ss.sssZ YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var departureTime: Swift.String?
    /// The finish position for the route. In the World Geodetic System (WGS 84) format: (longitude, latitude).
    /// This member is required.
    public var destination: [Swift.Double]?
    /// Desination related options.
    public var destinationOptions: GeoRoutesClientTypes.RouteDestinationOptions?
    /// Driver related options.
    public var driver: GeoRoutesClientTypes.RouteDriverOptions?
    /// Features to be strictly excluded for calculation.
    public var exclude: GeoRoutesClientTypes.RouteExclusionOptions?
    /// Measurement system to be used for instructions within steps in the response.
    public var instructionsMeasurementSystem: GeoRoutesClientTypes.MeasurementSystem?
    /// Optional: The API key to be used for authorization. Optional, either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// List of languages for instructions within steps in the response.
    public var languages: [Swift.String]?
    public var legAdditionalFeatures: [GeoRoutesClientTypes.RouteLegAdditionalFeature]?
    public var legGeometryFormat: GeoRoutesClientTypes.GeometryFormat?
    /// Maximum number of alternative routes to be provided in the response, if available.
    public var maxAlternatives: Swift.Int?
    /// Specifies the optimization criteria for calculating a route. Default Value: FastestRoute
    public var optimizeRoutingFor: GeoRoutesClientTypes.RoutingObjective?
    /// The start position for the route.
    /// This member is required.
    public var origin: [Swift.Double]?
    /// Origin related options.
    public var originOptions: GeoRoutesClientTypes.RouteOriginOptions?
    public var spanAdditionalFeatures: [GeoRoutesClientTypes.RouteSpanAdditionalFeature]?
    /// Toll related options.
    public var tolls: GeoRoutesClientTypes.RouteTollOptions?
    /// Traffic related options.
    public var traffic: GeoRoutesClientTypes.RouteTrafficOptions?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value:Car
    public var travelMode: GeoRoutesClientTypes.RouteTravelMode?
    /// Travel mode related options for the provided travel mode.
    public var travelModeOptions: GeoRoutesClientTypes.RouteTravelModeOptions?
    /// Type of step required in the response. Default provides basic steps intended for web based applications. TurnByTurn provides detailed instructions with more granularity intended for a turn based system.
    public var travelStepType: GeoRoutesClientTypes.RouteTravelStepType?
    /// List of waypoints between the Origin and Destination.
    public var waypoints: [GeoRoutesClientTypes.RouteWaypoint]?

    public init(
        allow: GeoRoutesClientTypes.RouteAllowOptions? = nil,
        arrivalTime: Swift.String? = nil,
        avoid: GeoRoutesClientTypes.RouteAvoidanceOptions? = nil,
        departNow: Swift.Bool? = nil,
        departureTime: Swift.String? = nil,
        destination: [Swift.Double]? = nil,
        destinationOptions: GeoRoutesClientTypes.RouteDestinationOptions? = nil,
        driver: GeoRoutesClientTypes.RouteDriverOptions? = nil,
        exclude: GeoRoutesClientTypes.RouteExclusionOptions? = nil,
        instructionsMeasurementSystem: GeoRoutesClientTypes.MeasurementSystem? = nil,
        key: Swift.String? = nil,
        languages: [Swift.String]? = nil,
        legAdditionalFeatures: [GeoRoutesClientTypes.RouteLegAdditionalFeature]? = nil,
        legGeometryFormat: GeoRoutesClientTypes.GeometryFormat? = nil,
        maxAlternatives: Swift.Int? = nil,
        optimizeRoutingFor: GeoRoutesClientTypes.RoutingObjective? = nil,
        origin: [Swift.Double]? = nil,
        originOptions: GeoRoutesClientTypes.RouteOriginOptions? = nil,
        spanAdditionalFeatures: [GeoRoutesClientTypes.RouteSpanAdditionalFeature]? = nil,
        tolls: GeoRoutesClientTypes.RouteTollOptions? = nil,
        traffic: GeoRoutesClientTypes.RouteTrafficOptions? = nil,
        travelMode: GeoRoutesClientTypes.RouteTravelMode? = nil,
        travelModeOptions: GeoRoutesClientTypes.RouteTravelModeOptions? = nil,
        travelStepType: GeoRoutesClientTypes.RouteTravelStepType? = nil,
        waypoints: [GeoRoutesClientTypes.RouteWaypoint]? = nil
    )
    {
        self.allow = allow
        self.arrivalTime = arrivalTime
        self.avoid = avoid
        self.departNow = departNow
        self.departureTime = departureTime
        self.destination = destination
        self.destinationOptions = destinationOptions
        self.driver = driver
        self.exclude = exclude
        self.instructionsMeasurementSystem = instructionsMeasurementSystem
        self.key = key
        self.languages = languages
        self.legAdditionalFeatures = legAdditionalFeatures
        self.legGeometryFormat = legGeometryFormat
        self.maxAlternatives = maxAlternatives
        self.optimizeRoutingFor = optimizeRoutingFor
        self.origin = origin
        self.originOptions = originOptions
        self.spanAdditionalFeatures = spanAdditionalFeatures
        self.tolls = tolls
        self.traffic = traffic
        self.travelMode = travelMode
        self.travelModeOptions = travelModeOptions
        self.travelStepType = travelStepType
        self.waypoints = waypoints
    }
}

extension CalculateRoutesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRoutesInput(allow: \(Swift.String(describing: allow)), arrivalTime: \(Swift.String(describing: arrivalTime)), avoid: \(Swift.String(describing: avoid)), departNow: \(Swift.String(describing: departNow)), departureTime: \(Swift.String(describing: departureTime)), destinationOptions: \(Swift.String(describing: destinationOptions)), driver: \(Swift.String(describing: driver)), exclude: \(Swift.String(describing: exclude)), instructionsMeasurementSystem: \(Swift.String(describing: instructionsMeasurementSystem)), languages: \(Swift.String(describing: languages)), legAdditionalFeatures: \(Swift.String(describing: legAdditionalFeatures)), legGeometryFormat: \(Swift.String(describing: legGeometryFormat)), maxAlternatives: \(Swift.String(describing: maxAlternatives)), optimizeRoutingFor: \(Swift.String(describing: optimizeRoutingFor)), originOptions: \(Swift.String(describing: originOptions)), spanAdditionalFeatures: \(Swift.String(describing: spanAdditionalFeatures)), tolls: \(Swift.String(describing: tolls)), traffic: \(Swift.String(describing: traffic)), travelMode: \(Swift.String(describing: travelMode)), travelModeOptions: \(Swift.String(describing: travelModeOptions)), travelStepType: \(Swift.String(describing: travelStepType)), waypoints: \(Swift.String(describing: waypoints)), destination: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", origin: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    public enum RouteResponseNoticeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mainLanguageNotFound
        case other
        case travelTimeExceedsDriverWorkHours
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteResponseNoticeCode] {
            return [
                .mainLanguageNotFound,
                .other,
                .travelTimeExceedsDriverWorkHours
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mainLanguageNotFound: return "MainLanguageNotFound"
            case .other: return "Other"
            case .travelTimeExceedsDriverWorkHours: return "TravelTimeExceedsDriverWorkHours"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteNoticeImpact: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteNoticeImpact] {
            return [
                .high,
                .low
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .low: return "Low"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Notices are additional information returned that indicate issues that occurred during route calculation.
    public struct RouteResponseNotice: Swift.Sendable {
        /// Code corresponding to the issue.
        /// This member is required.
        public var code: GeoRoutesClientTypes.RouteResponseNoticeCode?
        /// Impact corresponding to the issue. While Low impact notices can be safely ignored, High impact notices must be evaluated furtherâ€¦
        public var impact: GeoRoutesClientTypes.RouteNoticeImpact?

        public init(
            code: GeoRoutesClientTypes.RouteResponseNoticeCode? = nil,
            impact: GeoRoutesClientTypes.RouteNoticeImpact? = nil
        )
        {
            self.code = code
            self.impact = impact
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteFerryAfterTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deboard
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteFerryAfterTravelStepType] {
            return [
                .deboard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deboard: return "Deboard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that must be performed after the travel portion of the leg.
    public struct RouteFerryAfterTravelStep: Swift.Sendable {
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int
        /// Brief description of the step in the requested language.
        public var instruction: Swift.String?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RouteFerryAfterTravelStepType?

        public init(
            duration: Swift.Int = 0,
            instruction: Swift.String? = nil,
            type: GeoRoutesClientTypes.RouteFerryAfterTravelStepType? = nil
        )
        {
            self.duration = duration
            self.instruction = instruction
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    /// Position provided in the request, if the place corresponds to a waypoint.
    public struct RouteFerryPlace: Swift.Sendable {
        /// The name of the resource.
        public var name: Swift.String?
        /// Position provided in the request, if the place corresponds to a waypoint.
        public var originalPosition: [Swift.Double]?
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?
        /// Index of the waypoint in the request, if the place corresponds to a waypoint.
        public var waypointIndex: Swift.Int?

        public init(
            name: Swift.String? = nil,
            originalPosition: [Swift.Double]? = nil,
            position: [Swift.Double]? = nil,
            waypointIndex: Swift.Int? = nil
        )
        {
            self.name = name
            self.originalPosition = originalPosition
            self.position = position
            self.waypointIndex = waypointIndex
        }
    }
}

extension GeoRoutesClientTypes.RouteFerryPlace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteFerryPlace(name: \(Swift.String(describing: name)), waypointIndex: \(Swift.String(describing: waypointIndex)), originalPosition: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Details corresponding to the arrival for the leg.
    public struct RouteFerryArrival: Swift.Sendable {
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RouteFerryPlace?
        /// The time.
        public var time: Swift.String?

        public init(
            place: GeoRoutesClientTypes.RouteFerryPlace? = nil,
            time: Swift.String? = nil
        )
        {
            self.place = place
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteFerryBeforeTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case board
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteFerryBeforeTravelStepType] {
            return [
                .board
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .board: return "Board"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that must be performed before the travel portion of the leg.
    public struct RouteFerryBeforeTravelStep: Swift.Sendable {
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int
        /// Brief description of the step in the requested language.
        public var instruction: Swift.String?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RouteFerryBeforeTravelStepType?

        public init(
            duration: Swift.Int = 0,
            instruction: Swift.String? = nil,
            type: GeoRoutesClientTypes.RouteFerryBeforeTravelStepType? = nil
        )
        {
            self.duration = duration
            self.instruction = instruction
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details corresponding to the departure for the leg.
    public struct RouteFerryDeparture: Swift.Sendable {
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RouteFerryPlace?
        /// The time.
        public var time: Swift.String?

        public init(
            place: GeoRoutesClientTypes.RouteFerryPlace? = nil,
            time: Swift.String? = nil
        )
        {
            self.place = place
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteFerryNoticeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accuratePolylineUnavailable
        case noSchedule
        case other
        case violatedAvoidFerry
        case violatedAvoidRailFerry
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteFerryNoticeCode] {
            return [
                .accuratePolylineUnavailable,
                .noSchedule,
                .other,
                .violatedAvoidFerry,
                .violatedAvoidRailFerry
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accuratePolylineUnavailable: return "AccuratePolylineUnavailable"
            case .noSchedule: return "NoSchedule"
            case .other: return "Other"
            case .violatedAvoidFerry: return "ViolatedAvoidFerry"
            case .violatedAvoidRailFerry: return "ViolatedAvoidRailFerry"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Notices are additional information returned that indicate issues that occurred during route calculation.
    public struct RouteFerryNotice: Swift.Sendable {
        /// Code corresponding to the issue.
        /// This member is required.
        public var code: GeoRoutesClientTypes.RouteFerryNoticeCode?
        /// Impact corresponding to the issue. While Low impact notices can be safely ignored, High impact notices must be evaluated furtherâ€¦
        public var impact: GeoRoutesClientTypes.RouteNoticeImpact?

        public init(
            code: GeoRoutesClientTypes.RouteFerryNoticeCode? = nil,
            impact: GeoRoutesClientTypes.RouteNoticeImpact? = nil
        )
        {
            self.code = code
            self.impact = impact
        }
    }
}

extension GeoRoutesClientTypes {

    /// The place where the waypoiny is treated as a stop. If yes, the route is split up into different legs around the stop.
    public struct RoutePassThroughPlace: Swift.Sendable {
        /// Position provided in the request, if the place corresponds to a waypoint.
        public var originalPosition: [Swift.Double]?
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?
        /// Index of the waypoint in the request, if the place corresponds to a waypoint.
        public var waypointIndex: Swift.Int?

        public init(
            originalPosition: [Swift.Double]? = nil,
            position: [Swift.Double]? = nil,
            waypointIndex: Swift.Int? = nil
        )
        {
            self.originalPosition = originalPosition
            self.position = position
            self.waypointIndex = waypointIndex
        }
    }
}

extension GeoRoutesClientTypes.RoutePassThroughPlace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoutePassThroughPlace(waypointIndex: \(Swift.String(describing: waypointIndex)), originalPosition: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// If the waypoint should be treated as a stop. If yes, the route is split up into different legs around the stop.
    public struct RoutePassThroughWaypoint: Swift.Sendable {
        /// Offset in the leg geometry corresponding to the start of this step.
        public var geometryOffset: Swift.Int?
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RoutePassThroughPlace?

        public init(
            geometryOffset: Swift.Int? = nil,
            place: GeoRoutesClientTypes.RoutePassThroughPlace? = nil
        )
        {
            self.geometryOffset = geometryOffset
            self.place = place
        }
    }
}

extension GeoRoutesClientTypes {

    /// The localized string.
    public struct LocalizedString: Swift.Sendable {
        /// A list of BCP 47 compliant language codes for the results to be rendered in. The request uses the regional default as the fallback if the requested language cannot be provided.
        public var language: Swift.String?
        /// The value of the localized string.
        /// This member is required.
        public var value: Swift.String?

        public init(
            language: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.language = language
            self.value = value
        }
    }
}

extension GeoRoutesClientTypes {

    public struct RouteFerrySpan: Swift.Sendable {
        public var country: Swift.String?
        public var distance: Swift.Int
        public var duration: Swift.Int
        public var geometryOffset: Swift.Int?
        public var names: [GeoRoutesClientTypes.LocalizedString]?
        public var region: Swift.String?

        public init(
            country: Swift.String? = nil,
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            geometryOffset: Swift.Int? = nil,
            names: [GeoRoutesClientTypes.LocalizedString]? = nil,
            region: Swift.String? = nil
        )
        {
            self.country = country
            self.distance = distance
            self.duration = duration
            self.geometryOffset = geometryOffset
            self.names = names
            self.region = region
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details of the leg.
    public struct RouteFerryOverviewSummary: Swift.Sendable {
        /// Distance of the step.
        /// This member is required.
        public var distance: Swift.Int
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int

        public init(
            distance: Swift.Int = 0,
            duration: Swift.Int = 0
        )
        {
            self.distance = distance
            self.duration = duration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is the same as the Distance within the Overview summary.
    public struct RouteFerryTravelOnlySummary: Swift.Sendable {
        /// Total duration.
        /// This member is required.
        public var duration: Swift.Int

        public init(
            duration: Swift.Int = 0
        )
        {
            self.duration = duration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is the same as the Distance within the Overview summary.
    public struct RouteFerrySummary: Swift.Sendable {
        /// Summarized details for the leg including before travel, travel and after travel steps.
        public var overview: GeoRoutesClientTypes.RouteFerryOverviewSummary?
        /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is in meters
        public var travelOnly: GeoRoutesClientTypes.RouteFerryTravelOnlySummary?

        public init(
            overview: GeoRoutesClientTypes.RouteFerryOverviewSummary? = nil,
            travelOnly: GeoRoutesClientTypes.RouteFerryTravelOnlySummary? = nil
        )
        {
            self.overview = overview
            self.travelOnly = travelOnly
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteFerryTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arrive
        case `continue`
        case depart
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteFerryTravelStepType] {
            return [
                .arrive,
                .continue,
                .depart
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arrive: return "Arrive"
            case .continue: return "Continue"
            case .depart: return "Depart"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that must be performed during the travel portion of the leg.
    public struct RouteFerryTravelStep: Swift.Sendable {
        /// Distance of the step.
        public var distance: Swift.Int
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int
        /// Offset in the leg geometry corresponding to the start of this step.
        public var geometryOffset: Swift.Int?
        /// Brief description of the step in the requested language.
        public var instruction: Swift.String?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RouteFerryTravelStepType?

        public init(
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            geometryOffset: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            type: GeoRoutesClientTypes.RouteFerryTravelStepType? = nil
        )
        {
            self.distance = distance
            self.duration = duration
            self.geometryOffset = geometryOffset
            self.instruction = instruction
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    /// FerryLegDetails is populated when the Leg type is Ferry, and provides additional information that is specifify
    public struct RouteFerryLegDetails: Swift.Sendable {
        /// Steps of a leg that must be performed after the travel portion of the leg.
        /// This member is required.
        public var afterTravelSteps: [GeoRoutesClientTypes.RouteFerryAfterTravelStep]?
        /// Details corresponding to the departure for the leg.
        /// This member is required.
        public var arrival: GeoRoutesClientTypes.RouteFerryArrival?
        /// Steps of a leg that must be performed before the travel portion of the leg.
        /// This member is required.
        public var beforeTravelSteps: [GeoRoutesClientTypes.RouteFerryBeforeTravelStep]?
        /// Details corresponding to the departure for the leg.
        /// This member is required.
        public var departure: GeoRoutesClientTypes.RouteFerryDeparture?
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        /// This member is required.
        public var notices: [GeoRoutesClientTypes.RouteFerryNotice]?
        /// Waypoints that were passed through during the leg. This includes the waypoints that were configured with the PassThrough option.
        /// This member is required.
        public var passThroughWaypoints: [GeoRoutesClientTypes.RoutePassThroughWaypoint]?
        /// Route name of the ferry line.
        public var routeName: Swift.String?
        /// This member is required.
        public var spans: [GeoRoutesClientTypes.RouteFerrySpan]?
        /// Summarized details of the leg.
        public var summary: GeoRoutesClientTypes.RouteFerrySummary?
        /// Steps of a leg that must be performed before the travel portion of the leg.
        /// This member is required.
        public var travelSteps: [GeoRoutesClientTypes.RouteFerryTravelStep]?

        public init(
            afterTravelSteps: [GeoRoutesClientTypes.RouteFerryAfterTravelStep]? = nil,
            arrival: GeoRoutesClientTypes.RouteFerryArrival? = nil,
            beforeTravelSteps: [GeoRoutesClientTypes.RouteFerryBeforeTravelStep]? = nil,
            departure: GeoRoutesClientTypes.RouteFerryDeparture? = nil,
            notices: [GeoRoutesClientTypes.RouteFerryNotice]? = nil,
            passThroughWaypoints: [GeoRoutesClientTypes.RoutePassThroughWaypoint]? = nil,
            routeName: Swift.String? = nil,
            spans: [GeoRoutesClientTypes.RouteFerrySpan]? = nil,
            summary: GeoRoutesClientTypes.RouteFerrySummary? = nil,
            travelSteps: [GeoRoutesClientTypes.RouteFerryTravelStep]? = nil
        )
        {
            self.afterTravelSteps = afterTravelSteps
            self.arrival = arrival
            self.beforeTravelSteps = beforeTravelSteps
            self.departure = departure
            self.notices = notices
            self.passThroughWaypoints = passThroughWaypoints
            self.routeName = routeName
            self.spans = spans
            self.summary = summary
            self.travelSteps = travelSteps
        }
    }
}

extension GeoRoutesClientTypes {

    /// The returned Route leg geometry.
    public struct RouteLegGeometry: Swift.Sendable {
        /// An ordered list of positions used to plot a route on a map. LineString and Polyline are mutually exclusive properties.
        public var lineString: [[Swift.Double]]?
        /// An ordered list of positions used to plot a route on a map in a lossy compression format. LineString and Polyline are mutually exclusive properties.
        public var polyline: Swift.String?

        public init(
            lineString: [[Swift.Double]]? = nil,
            polyline: Swift.String? = nil
        )
        {
            self.lineString = lineString
            self.polyline = polyline
        }
    }
}

extension GeoRoutesClientTypes.RouteLegGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteLegGeometry(lineString: \"CONTENT_REDACTED\", polyline: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    public enum RoutePedestrianAfterTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case wait
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutePedestrianAfterTravelStepType] {
            return [
                .wait
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .wait: return "Wait"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that must be performed after the travel portion of the leg.
    public struct RoutePedestrianAfterTravelStep: Swift.Sendable {
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int
        /// Brief description of the step in the requested language.
        public var instruction: Swift.String?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RoutePedestrianAfterTravelStepType?

        public init(
            duration: Swift.Int = 0,
            instruction: Swift.String? = nil,
            type: GeoRoutesClientTypes.RoutePedestrianAfterTravelStepType? = nil
        )
        {
            self.duration = duration
            self.instruction = instruction
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSideOfStreet: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `left`
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSideOfStreet] {
            return [
                .left,
                .right
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .left: return "Left"
            case .right: return "Right"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Place details of departure for the leg.
    public struct RoutePedestrianPlace: Swift.Sendable {
        /// The name of the resource.
        public var name: Swift.String?
        /// Position provided in the request, if the place corresponds to a waypoint.
        public var originalPosition: [Swift.Double]?
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreet?
        /// Index of the waypoint in the request, if the place corresponds to a waypoint.
        public var waypointIndex: Swift.Int?

        public init(
            name: Swift.String? = nil,
            originalPosition: [Swift.Double]? = nil,
            position: [Swift.Double]? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreet? = nil,
            waypointIndex: Swift.Int? = nil
        )
        {
            self.name = name
            self.originalPosition = originalPosition
            self.position = position
            self.sideOfStreet = sideOfStreet
            self.waypointIndex = waypointIndex
        }
    }
}

extension GeoRoutesClientTypes.RoutePedestrianPlace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoutePedestrianPlace(name: \(Swift.String(describing: name)), sideOfStreet: \(Swift.String(describing: sideOfStreet)), waypointIndex: \(Swift.String(describing: waypointIndex)), originalPosition: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Time of arrival at the destination.
    public struct RoutePedestrianArrival: Swift.Sendable {
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RoutePedestrianPlace?
        /// The time.
        public var time: Swift.String?

        public init(
            place: GeoRoutesClientTypes.RoutePedestrianPlace? = nil,
            time: Swift.String? = nil
        )
        {
            self.place = place
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    /// Time of departure for Origin. Template:YYYY-MM-DDThh:mm:ss.sssZ YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public struct RoutePedestrianDeparture: Swift.Sendable {
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RoutePedestrianPlace?
        /// The time.
        public var time: Swift.String?

        public init(
            place: GeoRoutesClientTypes.RoutePedestrianPlace? = nil,
            time: Swift.String? = nil
        )
        {
            self.place = place
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RoutePedestrianNoticeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accuratePolylineUnavailable
        case other
        case violatedAvoidDirtRoad
        case violatedAvoidTunnel
        case violatedPedestrianOption
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutePedestrianNoticeCode] {
            return [
                .accuratePolylineUnavailable,
                .other,
                .violatedAvoidDirtRoad,
                .violatedAvoidTunnel,
                .violatedPedestrianOption
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accuratePolylineUnavailable: return "AccuratePolylineUnavailable"
            case .other: return "Other"
            case .violatedAvoidDirtRoad: return "ViolatedAvoidDirtRoad"
            case .violatedAvoidTunnel: return "ViolatedAvoidTunnel"
            case .violatedPedestrianOption: return "ViolatedPedestrianOption"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Notices are additional information returned that indicate issues that occurred during route calculation.
    public struct RoutePedestrianNotice: Swift.Sendable {
        /// Code corresponding to the issue.
        /// This member is required.
        public var code: GeoRoutesClientTypes.RoutePedestrianNoticeCode?
        /// Impact corresponding to the issue. While Low impact notices can be safely ignored, High impact notices must be evaluated furtherâ€¦
        public var impact: GeoRoutesClientTypes.RouteNoticeImpact?

        public init(
            code: GeoRoutesClientTypes.RoutePedestrianNoticeCode? = nil,
            impact: GeoRoutesClientTypes.RouteNoticeImpact? = nil
        )
        {
            self.code = code
            self.impact = impact
        }
    }
}

extension GeoRoutesClientTypes {

    public struct RouteSpanDynamicSpeedDetails: Swift.Sendable {
        public var bestCaseSpeed: Swift.Double
        public var turnDuration: Swift.Int
        public var typicalSpeed: Swift.Double

        public init(
            bestCaseSpeed: Swift.Double = 0.0,
            turnDuration: Swift.Int = 0,
            typicalSpeed: Swift.Double = 0.0
        )
        {
            self.bestCaseSpeed = bestCaseSpeed
            self.turnDuration = turnDuration
            self.typicalSpeed = typicalSpeed
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanPedestrianAccessAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowed
        case indoors
        case noThroughTraffic
        case park
        case stairs
        case tollRoad
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanPedestrianAccessAttribute] {
            return [
                .allowed,
                .indoors,
                .noThroughTraffic,
                .park,
                .stairs,
                .tollRoad
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "Allowed"
            case .indoors: return "Indoors"
            case .noThroughTraffic: return "NoThroughTraffic"
            case .park: return "Park"
            case .stairs: return "Stairs"
            case .tollRoad: return "TollRoad"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanRoadAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bridge
        case builtUpArea
        case controlledAccessHighway
        case dirtRoad
        case dividedRoad
        case motorway
        case privateRoad
        case ramp
        case rightHandTraffic
        case roundabout
        case tunnel
        case underConstruction
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanRoadAttribute] {
            return [
                .bridge,
                .builtUpArea,
                .controlledAccessHighway,
                .dirtRoad,
                .dividedRoad,
                .motorway,
                .privateRoad,
                .ramp,
                .rightHandTraffic,
                .roundabout,
                .tunnel,
                .underConstruction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bridge: return "Bridge"
            case .builtUpArea: return "BuiltUpArea"
            case .controlledAccessHighway: return "ControlledAccessHighway"
            case .dirtRoad: return "DirtRoad"
            case .dividedRoad: return "DividedRoad"
            case .motorway: return "Motorway"
            case .privateRoad: return "PrivateRoad"
            case .ramp: return "Ramp"
            case .rightHandTraffic: return "RightHandTraffic"
            case .roundabout: return "Roundabout"
            case .tunnel: return "Tunnel"
            case .underConstruction: return "UnderConstruction"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteDirection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case east
        case north
        case south
        case west
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteDirection] {
            return [
                .east,
                .north,
                .south,
                .west
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .east: return "East"
            case .north: return "North"
            case .south: return "South"
            case .west: return "West"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The route number.
    public struct RouteNumber: Swift.Sendable {
        public var direction: GeoRoutesClientTypes.RouteDirection?
        /// List of languages for instructions within steps in the response.
        public var language: Swift.String?
        /// Exact price, if not a range.
        /// This member is required.
        public var value: Swift.String?

        public init(
            direction: GeoRoutesClientTypes.RouteDirection? = nil,
            language: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.direction = direction
            self.language = language
            self.value = value
        }
    }
}

extension GeoRoutesClientTypes {

    public struct RouteSpanSpeedLimitDetails: Swift.Sendable {
        public var maxSpeed: Swift.Double
        public var unlimited: Swift.Bool?

        public init(
            maxSpeed: Swift.Double = 0.0,
            unlimited: Swift.Bool? = nil
        )
        {
            self.maxSpeed = maxSpeed
            self.unlimited = unlimited
        }
    }
}

extension GeoRoutesClientTypes {

    public struct RoutePedestrianSpan: Swift.Sendable {
        public var bestCaseDuration: Swift.Int
        public var country: Swift.String?
        public var distance: Swift.Int
        public var duration: Swift.Int
        public var dynamicSpeed: GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails?
        public var functionalClassification: Swift.Int?
        public var geometryOffset: Swift.Int?
        public var incidents: [Swift.Int]?
        public var names: [GeoRoutesClientTypes.LocalizedString]?
        public var pedestrianAccess: [GeoRoutesClientTypes.RouteSpanPedestrianAccessAttribute]?
        public var region: Swift.String?
        public var roadAttributes: [GeoRoutesClientTypes.RouteSpanRoadAttribute]?
        public var routeNumbers: [GeoRoutesClientTypes.RouteNumber]?
        public var speedLimit: GeoRoutesClientTypes.RouteSpanSpeedLimitDetails?
        public var typicalDuration: Swift.Int

        public init(
            bestCaseDuration: Swift.Int = 0,
            country: Swift.String? = nil,
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            dynamicSpeed: GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails? = nil,
            functionalClassification: Swift.Int? = nil,
            geometryOffset: Swift.Int? = nil,
            incidents: [Swift.Int]? = nil,
            names: [GeoRoutesClientTypes.LocalizedString]? = nil,
            pedestrianAccess: [GeoRoutesClientTypes.RouteSpanPedestrianAccessAttribute]? = nil,
            region: Swift.String? = nil,
            roadAttributes: [GeoRoutesClientTypes.RouteSpanRoadAttribute]? = nil,
            routeNumbers: [GeoRoutesClientTypes.RouteNumber]? = nil,
            speedLimit: GeoRoutesClientTypes.RouteSpanSpeedLimitDetails? = nil,
            typicalDuration: Swift.Int = 0
        )
        {
            self.bestCaseDuration = bestCaseDuration
            self.country = country
            self.distance = distance
            self.duration = duration
            self.dynamicSpeed = dynamicSpeed
            self.functionalClassification = functionalClassification
            self.geometryOffset = geometryOffset
            self.incidents = incidents
            self.names = names
            self.pedestrianAccess = pedestrianAccess
            self.region = region
            self.roadAttributes = roadAttributes
            self.routeNumbers = routeNumbers
            self.speedLimit = speedLimit
            self.typicalDuration = typicalDuration
        }
    }
}

extension GeoRoutesClientTypes {

    ///
    public struct RoutePedestrianOverviewSummary: Swift.Sendable {
        /// Distance of the step.
        /// This member is required.
        public var distance: Swift.Int
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int

        public init(
            distance: Swift.Int = 0,
            duration: Swift.Int = 0
        )
        {
            self.distance = distance
            self.duration = duration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details for the leg including travel steps.
    public struct RoutePedestrianTravelOnlySummary: Swift.Sendable {
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int

        public init(
            duration: Swift.Int = 0
        )
        {
            self.duration = duration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details for the leg including before travel, travel and after travel steps.
    public struct RoutePedestrianSummary: Swift.Sendable {
        /// Summarized details for the leg including before travel, travel and after travel steps.
        public var overview: GeoRoutesClientTypes.RoutePedestrianOverviewSummary?
        /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is in meters
        public var travelOnly: GeoRoutesClientTypes.RoutePedestrianTravelOnlySummary?

        public init(
            overview: GeoRoutesClientTypes.RoutePedestrianOverviewSummary? = nil,
            travelOnly: GeoRoutesClientTypes.RoutePedestrianTravelOnlySummary? = nil
        )
        {
            self.overview = overview
            self.travelOnly = travelOnly
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the continue step.
    public struct RouteContinueStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil
        )
        {
            self.intersection = intersection
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteRoadType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case highway
        case rural
        case urban
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteRoadType] {
            return [
                .highway,
                .rural,
                .urban
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .highway: return "Highway"
            case .rural: return "Rural"
            case .urban: return "Urban"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The road on the route.
    public struct RouteRoad: Swift.Sendable {
        /// Name of the road (localized).
        /// This member is required.
        public var roadName: [GeoRoutesClientTypes.LocalizedString]?
        /// Route number of the road.
        /// This member is required.
        public var routeNumber: [GeoRoutesClientTypes.RouteNumber]?
        /// Names of destinations that can be reached when traveling on the road.
        /// This member is required.
        public var towards: [GeoRoutesClientTypes.LocalizedString]?
        /// The type of road.
        public var type: GeoRoutesClientTypes.RouteRoadType?

        public init(
            roadName: [GeoRoutesClientTypes.LocalizedString]? = nil,
            routeNumber: [GeoRoutesClientTypes.RouteNumber]? = nil,
            towards: [GeoRoutesClientTypes.LocalizedString]? = nil,
            type: GeoRoutesClientTypes.RouteRoadType? = nil
        )
        {
            self.roadName = roadName
            self.routeNumber = routeNumber
            self.towards = towards
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSteeringDirection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `left`
        case `right`
        case straight
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSteeringDirection] {
            return [
                .left,
                .right,
                .straight
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .left: return "Left"
            case .right: return "Right"
            case .straight: return "Straight"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTurnIntensity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sharp
        case slight
        case typical
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTurnIntensity] {
            return [
                .sharp,
                .slight,
                .typical
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sharp: return "Sharp"
            case .slight: return "Slight"
            case .typical: return "Typical"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the exit step.
    public struct RouteExitStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Exit to be taken.
        public var relativeExit: Swift.Int?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            relativeExit: Swift.Int? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.relativeExit = relativeExit
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details that are specific to a Keep step.
    public struct RouteKeepStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details that are specific to a ramp step.
    public struct RouteRampStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details about the roundabout leg.
    public struct RouteRoundaboutEnterStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details about the roundabout step.
    public struct RouteRoundaboutExitStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Exit to be taken.
        public var relativeExit: Swift.Int?
        /// Angle of the roundabout.
        public var roundaboutAngle: Swift.Double
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            relativeExit: Swift.Int? = nil,
            roundaboutAngle: Swift.Double = 0.0,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.relativeExit = relativeExit
            self.roundaboutAngle = roundaboutAngle
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details about the step.
    public struct RouteRoundaboutPassStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Important labels including names and route numbers that differentiate the current route from the alternatives presented.
    public struct RouteSignpostLabel: Swift.Sendable {
        /// Route number of the road.
        public var routeNumber: GeoRoutesClientTypes.RouteNumber?
        /// The Signpost text.
        public var text: GeoRoutesClientTypes.LocalizedString?

        public init(
            routeNumber: GeoRoutesClientTypes.RouteNumber? = nil,
            text: GeoRoutesClientTypes.LocalizedString? = nil
        )
        {
            self.routeNumber = routeNumber
            self.text = text
        }
    }
}

extension GeoRoutesClientTypes {

    /// Sign post information of the action, applicable only for TurnByTurn steps. See RouteSignpost for details of sub-attributes.
    public struct RouteSignpost: Swift.Sendable {
        /// Labels present on the sign post.
        /// This member is required.
        public var labels: [GeoRoutesClientTypes.RouteSignpostLabel]?

        public init(
            labels: [GeoRoutesClientTypes.RouteSignpostLabel]? = nil
        )
        {
            self.labels = labels
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the turn step.
    public struct RouteTurnStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RoutePedestrianTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arrive
        case `continue`
        case depart
        case exit
        case keep
        case ramp
        case roundaboutEnter
        case roundaboutExit
        case roundaboutPass
        case turn
        case uTurn
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutePedestrianTravelStepType] {
            return [
                .arrive,
                .continue,
                .depart,
                .exit,
                .keep,
                .ramp,
                .roundaboutEnter,
                .roundaboutExit,
                .roundaboutPass,
                .turn,
                .uTurn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arrive: return "Arrive"
            case .continue: return "Continue"
            case .depart: return "Depart"
            case .exit: return "Exit"
            case .keep: return "Keep"
            case .ramp: return "Ramp"
            case .roundaboutEnter: return "RoundaboutEnter"
            case .roundaboutExit: return "RoundaboutExit"
            case .roundaboutPass: return "RoundaboutPass"
            case .turn: return "Turn"
            case .uTurn: return "UTurn"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the UTurn step.
    public struct RouteUTurnStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that must be performed during the travel portion of the leg.
    public struct RoutePedestrianTravelStep: Swift.Sendable {
        /// Details related to the contiue step.
        public var continueStepDetails: GeoRoutesClientTypes.RouteContinueStepDetails?
        /// The current road.
        public var currentRoad: GeoRoutesClientTypes.RouteRoad?
        /// Distance of the step.
        public var distance: Swift.Int
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int
        /// Exit number of the road exit, if applicable.
        public var exitNumber: [GeoRoutesClientTypes.LocalizedString]?
        /// Details that are specific to a Roundabout Exit step.
        public var exitStepDetails: GeoRoutesClientTypes.RouteExitStepDetails?
        /// Offset in the leg geometry corresponding to the start of this step.
        public var geometryOffset: Swift.Int?
        /// Brief description of the step in the requested language.
        public var instruction: Swift.String?
        /// Details that are specific to a Keep step.
        public var keepStepDetails: GeoRoutesClientTypes.RouteKeepStepDetails?
        /// Details of the next road. See RouteRoad for details of sub-attributes.
        public var nextRoad: GeoRoutesClientTypes.RouteRoad?
        /// Details that are specific to a Ramp step.
        public var rampStepDetails: GeoRoutesClientTypes.RouteRampStepDetails?
        /// Details that are specific to a Roundabout Enter step.
        public var roundaboutEnterStepDetails: GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails?
        /// Details that are specific to a Roundabout Exit step.
        public var roundaboutExitStepDetails: GeoRoutesClientTypes.RouteRoundaboutExitStepDetails?
        /// Details that are specific to a Roundabout Pass step.
        public var roundaboutPassStepDetails: GeoRoutesClientTypes.RouteRoundaboutPassStepDetails?
        /// Sign post information of the action, applicable only for TurnByTurn steps. See RouteSignpost for details of sub-attributes.
        public var signpost: GeoRoutesClientTypes.RouteSignpost?
        /// Details that are specific to a turn step.
        public var turnStepDetails: GeoRoutesClientTypes.RouteTurnStepDetails?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RoutePedestrianTravelStepType?
        /// Details that are specific to a UTurn step.
        public var uTurnStepDetails: GeoRoutesClientTypes.RouteUTurnStepDetails?

        public init(
            continueStepDetails: GeoRoutesClientTypes.RouteContinueStepDetails? = nil,
            currentRoad: GeoRoutesClientTypes.RouteRoad? = nil,
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            exitNumber: [GeoRoutesClientTypes.LocalizedString]? = nil,
            exitStepDetails: GeoRoutesClientTypes.RouteExitStepDetails? = nil,
            geometryOffset: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            keepStepDetails: GeoRoutesClientTypes.RouteKeepStepDetails? = nil,
            nextRoad: GeoRoutesClientTypes.RouteRoad? = nil,
            rampStepDetails: GeoRoutesClientTypes.RouteRampStepDetails? = nil,
            roundaboutEnterStepDetails: GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails? = nil,
            roundaboutExitStepDetails: GeoRoutesClientTypes.RouteRoundaboutExitStepDetails? = nil,
            roundaboutPassStepDetails: GeoRoutesClientTypes.RouteRoundaboutPassStepDetails? = nil,
            signpost: GeoRoutesClientTypes.RouteSignpost? = nil,
            turnStepDetails: GeoRoutesClientTypes.RouteTurnStepDetails? = nil,
            type: GeoRoutesClientTypes.RoutePedestrianTravelStepType? = nil,
            uTurnStepDetails: GeoRoutesClientTypes.RouteUTurnStepDetails? = nil
        )
        {
            self.continueStepDetails = continueStepDetails
            self.currentRoad = currentRoad
            self.distance = distance
            self.duration = duration
            self.exitNumber = exitNumber
            self.exitStepDetails = exitStepDetails
            self.geometryOffset = geometryOffset
            self.instruction = instruction
            self.keepStepDetails = keepStepDetails
            self.nextRoad = nextRoad
            self.rampStepDetails = rampStepDetails
            self.roundaboutEnterStepDetails = roundaboutEnterStepDetails
            self.roundaboutExitStepDetails = roundaboutExitStepDetails
            self.roundaboutPassStepDetails = roundaboutPassStepDetails
            self.signpost = signpost
            self.turnStepDetails = turnStepDetails
            self.type = type
            self.uTurnStepDetails = uTurnStepDetails
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details that are specific to a pedestrian step.
    public struct RoutePedestrianLegDetails: Swift.Sendable {
        /// Steps of a leg that must be performed after the travel portion of the leg.
        /// This member is required.
        public var afterTravelSteps: [GeoRoutesClientTypes.RoutePedestrianAfterTravelStep]?
        /// Details corresponding to the departure for the leg.
        /// This member is required.
        public var arrival: GeoRoutesClientTypes.RoutePedestrianArrival?
        /// Details corresponding to the departure for the leg.
        /// This member is required.
        public var departure: GeoRoutesClientTypes.RoutePedestrianDeparture?
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        /// This member is required.
        public var notices: [GeoRoutesClientTypes.RoutePedestrianNotice]?
        /// Waypoints that were passed through during the leg. This includes the waypoints that were configured with the PassThrough option.
        /// This member is required.
        public var passThroughWaypoints: [GeoRoutesClientTypes.RoutePassThroughWaypoint]?
        /// This member is required.
        public var spans: [GeoRoutesClientTypes.RoutePedestrianSpan]?
        /// Summarized details of the leg.
        public var summary: GeoRoutesClientTypes.RoutePedestrianSummary?
        /// Steps of a leg that must be performed before the travel portion of the leg.
        /// This member is required.
        public var travelSteps: [GeoRoutesClientTypes.RoutePedestrianTravelStep]?

        public init(
            afterTravelSteps: [GeoRoutesClientTypes.RoutePedestrianAfterTravelStep]? = nil,
            arrival: GeoRoutesClientTypes.RoutePedestrianArrival? = nil,
            departure: GeoRoutesClientTypes.RoutePedestrianDeparture? = nil,
            notices: [GeoRoutesClientTypes.RoutePedestrianNotice]? = nil,
            passThroughWaypoints: [GeoRoutesClientTypes.RoutePassThroughWaypoint]? = nil,
            spans: [GeoRoutesClientTypes.RoutePedestrianSpan]? = nil,
            summary: GeoRoutesClientTypes.RoutePedestrianSummary? = nil,
            travelSteps: [GeoRoutesClientTypes.RoutePedestrianTravelStep]? = nil
        )
        {
            self.afterTravelSteps = afterTravelSteps
            self.arrival = arrival
            self.departure = departure
            self.notices = notices
            self.passThroughWaypoints = passThroughWaypoints
            self.spans = spans
            self.summary = summary
            self.travelSteps = travelSteps
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteLegTravelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case car
        case ferry
        case pedestrian
        case scooter
        case truck
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteLegTravelMode] {
            return [
                .car,
                .ferry,
                .pedestrian,
                .scooter,
                .truck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .ferry: return "Ferry"
            case .pedestrian: return "Pedestrian"
            case .scooter: return "Scooter"
            case .truck: return "Truck"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteLegType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ferry
        case pedestrian
        case vehicle
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteLegType] {
            return [
                .ferry,
                .pedestrian,
                .vehicle
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ferry: return "Ferry"
            case .pedestrian: return "Pedestrian"
            case .vehicle: return "Vehicle"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details about the EV charge at the current step.
    public struct RouteChargeStepDetails: Swift.Sendable {
        /// Estimated vehicle battery charge before this step (in kWh).
        public var arrivalCharge: Swift.Double
        /// Maximum charging power available to the vehicle. Unit: KwH
        public var consumablePower: Swift.Double
        /// Details that are specific to a Charge step. Unit: KwH
        public var desiredCharge: Swift.Double

        public init(
            arrivalCharge: Swift.Double = 0.0,
            consumablePower: Swift.Double = 0.0,
            desiredCharge: Swift.Double = 0.0
        )
        {
            self.arrivalCharge = arrivalCharge
            self.consumablePower = consumablePower
            self.desiredCharge = desiredCharge
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteVehicleAfterTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case charge
        case chargeSetup
        case wait
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteVehicleAfterTravelStepType] {
            return [
                .charge,
                .chargeSetup,
                .wait
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .charge: return "Charge"
            case .chargeSetup: return "ChargeSetup"
            case .wait: return "Wait"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that must be performed after the travel portion of the leg.
    public struct RouteVehicleAfterTravelStep: Swift.Sendable {
        /// Details that are specific to a Charge step. Unit: KwH
        public var chargeStepDetails: GeoRoutesClientTypes.RouteChargeStepDetails?
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int
        /// Brief description of the step in the requested language.
        public var instruction: Swift.String?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RouteVehicleAfterTravelStepType?

        public init(
            chargeStepDetails: GeoRoutesClientTypes.RouteChargeStepDetails? = nil,
            duration: Swift.Int = 0,
            instruction: Swift.String? = nil,
            type: GeoRoutesClientTypes.RouteVehicleAfterTravelStepType? = nil
        )
        {
            self.chargeStepDetails = chargeStepDetails
            self.duration = duration
            self.instruction = instruction
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    /// The charging station brand.
    public struct RouteChargingStationBrand: Swift.Sendable {
        /// The name of the brand.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension GeoRoutesClientTypes {

    /// Charge point operator (CPO) on the route.
    public struct RouteChargePointOperator: Swift.Sendable {
        /// The name of the resource.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteChargingSupplyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acSingle
        case acThree
        case dc
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteChargingSupplyType] {
            return [
                .acSingle,
                .acThree,
                .dc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acSingle: return "AcSingle"
            case .acThree: return "AcThree"
            case .dc: return "Dc"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The charging connector.
    public struct RouteChargingConnector: Swift.Sendable {
        /// Connector types that are compatible with the vehicle. ChargingTime in the response is based on the connector type with the highest power rating, if multiple connector types are specified.
        /// This member is required.
        public var connectorType: GeoRoutesClientTypes.RouteChargingConnectorType?
        /// Current supported by the battery. Unit: amperes
        public var current: Swift.Double
        /// Power supported by the battery. Power supported by the battery.
        /// This member is required.
        public var power: Swift.Double
        /// The Supply type of the connector.
        /// This member is required.
        public var supplyType: GeoRoutesClientTypes.RouteChargingSupplyType?
        /// Voltage supported by the battery. Unit: volts
        public var voltage: Swift.Double

        public init(
            connectorType: GeoRoutesClientTypes.RouteChargingConnectorType? = nil,
            current: Swift.Double = 0.0,
            power: Swift.Double = 0.0,
            supplyType: GeoRoutesClientTypes.RouteChargingSupplyType? = nil,
            voltage: Swift.Double = 0.0
        )
        {
            self.connectorType = connectorType
            self.current = current
            self.power = power
            self.supplyType = supplyType
            self.voltage = voltage
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the charging station.
    public struct RouteChargingStationDetails: Swift.Sendable {
        /// The charging station brand.
        public var brand: GeoRoutesClientTypes.RouteChargingStationBrand?
        /// The charging station operator.
        public var chargePointOperator: GeoRoutesClientTypes.RouteChargePointOperator?
        /// Connector types that are compatible with the vehicle. ChargingTime in the response is based on the connector type with the highest power rating, if multiple connector types are specified.
        public var connector: GeoRoutesClientTypes.RouteChargingConnector?

        public init(
            brand: GeoRoutesClientTypes.RouteChargingStationBrand? = nil,
            chargePointOperator: GeoRoutesClientTypes.RouteChargePointOperator? = nil,
            connector: GeoRoutesClientTypes.RouteChargingConnector? = nil
        )
        {
            self.brand = brand
            self.chargePointOperator = chargePointOperator
            self.connector = connector
        }
    }
}

extension GeoRoutesClientTypes {

    /// Place details for the vehicle.
    public struct RouteVehiclePlace: Swift.Sendable {
        /// Estimated vehicle battery charge before this step (in kWh).
        public var chargingStation: Swift.Bool?
        /// Details about the charging station.
        public var chargingStationDetails: GeoRoutesClientTypes.RouteChargingStationDetails?
        /// The name of the resource.
        public var name: Swift.String?
        /// Position provided in the request, if the place corresponds to a waypoint.
        public var originalPosition: [Swift.Double]?
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreet?
        /// Index of the waypoint in the request, if the place corresponds to a waypoint.
        public var waypointIndex: Swift.Int?

        public init(
            chargingStation: Swift.Bool? = nil,
            chargingStationDetails: GeoRoutesClientTypes.RouteChargingStationDetails? = nil,
            name: Swift.String? = nil,
            originalPosition: [Swift.Double]? = nil,
            position: [Swift.Double]? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreet? = nil,
            waypointIndex: Swift.Int? = nil
        )
        {
            self.chargingStation = chargingStation
            self.chargingStationDetails = chargingStationDetails
            self.name = name
            self.originalPosition = originalPosition
            self.position = position
            self.sideOfStreet = sideOfStreet
            self.waypointIndex = waypointIndex
        }
    }
}

extension GeoRoutesClientTypes.RouteVehiclePlace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteVehiclePlace(chargingStation: \(Swift.String(describing: chargingStation)), chargingStationDetails: \(Swift.String(describing: chargingStationDetails)), name: \(Swift.String(describing: name)), sideOfStreet: \(Swift.String(describing: sideOfStreet)), waypointIndex: \(Swift.String(describing: waypointIndex)), originalPosition: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Time of arrival at the destination. This parameter is returned only if the Destination parameters was provided in the request. Template:YYYY-MM-DDThh:mm:ss.sssZ YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public struct RouteVehicleArrival: Swift.Sendable {
        /// Charge at the origin.
        public var charge: Swift.Double
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RouteVehiclePlace?
        /// The time.
        public var time: Swift.String?

        public init(
            charge: Swift.Double = 0.0,
            place: GeoRoutesClientTypes.RouteVehiclePlace? = nil,
            time: Swift.String? = nil
        )
        {
            self.charge = charge
            self.place = place
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details corresponding to the departure for the leg.
    public struct RouteVehicleDeparture: Swift.Sendable {
        /// Charge at the origin.
        public var charge: Swift.Double
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RouteVehiclePlace?
        /// The departure time.
        public var time: Swift.String?

        public init(
            charge: Swift.Double = 0.0,
            place: GeoRoutesClientTypes.RouteVehiclePlace? = nil,
            time: Swift.String? = nil
        )
        {
            self.charge = charge
            self.place = place
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteVehicleIncidentSeverity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteVehicleIncidentSeverity] {
            return [
                .critical,
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "Critical"
            case .high: return "High"
            case .low: return "Low"
            case .medium: return "Medium"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteVehicleIncidentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accident
        case congestion
        case construction
        case disabledVehicle
        case laneRestriction
        case massTransit
        case other
        case plannedEvent
        case roadClosure
        case roadHazard
        case weather
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteVehicleIncidentType] {
            return [
                .accident,
                .congestion,
                .construction,
                .disabledVehicle,
                .laneRestriction,
                .massTransit,
                .other,
                .plannedEvent,
                .roadClosure,
                .roadHazard,
                .weather
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accident: return "Accident"
            case .congestion: return "Congestion"
            case .construction: return "Construction"
            case .disabledVehicle: return "DisabledVehicle"
            case .laneRestriction: return "LaneRestriction"
            case .massTransit: return "MassTransit"
            case .other: return "Other"
            case .plannedEvent: return "PlannedEvent"
            case .roadClosure: return "RoadClosure"
            case .roadHazard: return "RoadHazard"
            case .weather: return "Weather"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Incidents corresponding to this leg of the route.
    public struct RouteVehicleIncident: Swift.Sendable {
        /// Brief readable description of the incident.
        public var description: Swift.String?
        /// End timestamp of the incident.
        public var endTime: Swift.String?
        /// Severity of the incident Critical - The part of the route the incident affects is unusable. Major- Major impact on the leg duration, e.g. stop and go Minor- Minor impact on the leg duration, e.g. traffic jam Low - Low on duration, e.g. slightly increased traffic
        public var severity: GeoRoutesClientTypes.RouteVehicleIncidentSeverity?
        /// Start time of the incident.
        public var startTime: Swift.String?
        /// Type of the step.
        public var type: GeoRoutesClientTypes.RouteVehicleIncidentType?

        public init(
            description: Swift.String? = nil,
            endTime: Swift.String? = nil,
            severity: GeoRoutesClientTypes.RouteVehicleIncidentSeverity? = nil,
            startTime: Swift.String? = nil,
            type: GeoRoutesClientTypes.RouteVehicleIncidentType? = nil
        )
        {
            self.description = description
            self.endTime = endTime
            self.severity = severity
            self.startTime = startTime
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteVehicleNoticeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accuratePolylineUnavailable
        case other
        case potentialViolatedAvoidTollRoadUsage
        case potentialViolatedCarpoolUsage
        case potentialViolatedTurnRestrictionUsage
        case potentialViolatedVehicleRestrictionUsage
        case potentialViolatedZoneRestrictionUsage
        case seasonalClosure
        case tollsDataTemporarilyUnavailable
        case tollsDataUnavailable
        case tollTransponder
        case violatedAvoidControlledAccessHighway
        case violatedAvoidDifficultTurns
        case violatedAvoidDirtRoad
        case violatedAvoidSeasonalClosure
        case violatedAvoidTollRoad
        case violatedAvoidTollTransponder
        case violatedAvoidTruckRoadType
        case violatedAvoidTunnel
        case violatedAvoidUTurns
        case violatedBlockedRoad
        case violatedCarpool
        case violatedChargingStationOpeningHours
        case violatedEmergencyGate
        case violatedStartDirection
        case violatedTurnRestriction
        case violatedVehicleRestriction
        case violatedZoneRestriction
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteVehicleNoticeCode] {
            return [
                .accuratePolylineUnavailable,
                .other,
                .potentialViolatedAvoidTollRoadUsage,
                .potentialViolatedCarpoolUsage,
                .potentialViolatedTurnRestrictionUsage,
                .potentialViolatedVehicleRestrictionUsage,
                .potentialViolatedZoneRestrictionUsage,
                .seasonalClosure,
                .tollsDataTemporarilyUnavailable,
                .tollsDataUnavailable,
                .tollTransponder,
                .violatedAvoidControlledAccessHighway,
                .violatedAvoidDifficultTurns,
                .violatedAvoidDirtRoad,
                .violatedAvoidSeasonalClosure,
                .violatedAvoidTollRoad,
                .violatedAvoidTollTransponder,
                .violatedAvoidTruckRoadType,
                .violatedAvoidTunnel,
                .violatedAvoidUTurns,
                .violatedBlockedRoad,
                .violatedCarpool,
                .violatedChargingStationOpeningHours,
                .violatedEmergencyGate,
                .violatedStartDirection,
                .violatedTurnRestriction,
                .violatedVehicleRestriction,
                .violatedZoneRestriction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accuratePolylineUnavailable: return "AccuratePolylineUnavailable"
            case .other: return "Other"
            case .potentialViolatedAvoidTollRoadUsage: return "PotentialViolatedAvoidTollRoadUsage"
            case .potentialViolatedCarpoolUsage: return "PotentialViolatedCarpoolUsage"
            case .potentialViolatedTurnRestrictionUsage: return "PotentialViolatedTurnRestrictionUsage"
            case .potentialViolatedVehicleRestrictionUsage: return "PotentialViolatedVehicleRestrictionUsage"
            case .potentialViolatedZoneRestrictionUsage: return "PotentialViolatedZoneRestrictionUsage"
            case .seasonalClosure: return "SeasonalClosure"
            case .tollsDataTemporarilyUnavailable: return "TollsDataTemporarilyUnavailable"
            case .tollsDataUnavailable: return "TollsDataUnavailable"
            case .tollTransponder: return "TollTransponder"
            case .violatedAvoidControlledAccessHighway: return "ViolatedAvoidControlledAccessHighway"
            case .violatedAvoidDifficultTurns: return "ViolatedAvoidDifficultTurns"
            case .violatedAvoidDirtRoad: return "ViolatedAvoidDirtRoad"
            case .violatedAvoidSeasonalClosure: return "ViolatedAvoidSeasonalClosure"
            case .violatedAvoidTollRoad: return "ViolatedAvoidTollRoad"
            case .violatedAvoidTollTransponder: return "ViolatedAvoidTollTransponder"
            case .violatedAvoidTruckRoadType: return "ViolatedAvoidTruckRoadType"
            case .violatedAvoidTunnel: return "ViolatedAvoidTunnel"
            case .violatedAvoidUTurns: return "ViolatedAvoidUTurns"
            case .violatedBlockedRoad: return "ViolatedBlockedRoad"
            case .violatedCarpool: return "ViolatedCarpool"
            case .violatedChargingStationOpeningHours: return "ViolatedChargingStationOpeningHours"
            case .violatedEmergencyGate: return "ViolatedEmergencyGate"
            case .violatedStartDirection: return "ViolatedStartDirection"
            case .violatedTurnRestriction: return "ViolatedTurnRestriction"
            case .violatedVehicleRestriction: return "ViolatedVehicleRestriction"
            case .violatedZoneRestriction: return "ViolatedZoneRestriction"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Price range with a minimum and maximum value, if a range.
    public struct RouteNoticeDetailRange: Swift.Sendable {
        /// Maximum price.
        public var max: Swift.Int?
        /// Minimum price.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteWeightConstraintType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case current
        case gross
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteWeightConstraintType] {
            return [
                .current,
                .gross,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .current: return "Current"
            case .gross: return "Gross"
            case .unknown: return "Unknown"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public struct RouteWeightConstraint: Swift.Sendable {
        /// This member is required.
        public var type: GeoRoutesClientTypes.RouteWeightConstraintType?
        /// This member is required.
        public var value: Swift.Int

        public init(
            type: GeoRoutesClientTypes.RouteWeightConstraintType? = nil,
            value: Swift.Int = 0
        )
        {
            self.type = type
            self.value = value
        }
    }
}

extension GeoRoutesClientTypes {

    /// This property contains a summary of violated constraints.
    public struct RouteViolatedConstraints: Swift.Sendable {
        /// This restriction applies to truck cargo, where the resulting route excludes roads on which hazardous materials are prohibited from being transported.
        public var allHazardsRestricted: Swift.Bool?
        /// Total number of axles of the vehicle.
        public var axleCount: GeoRoutesClientTypes.RouteNoticeDetailRange?
        /// List of Hazardous cargos contained in the vehicle.
        /// This member is required.
        public var hazardousCargos: [GeoRoutesClientTypes.RouteHazardousCargoType]?
        /// The maximum height of the vehicle.
        public var maxHeight: Swift.Int
        /// The maximum Kpra length of the vehicle.
        public var maxKpraLength: Swift.Int
        /// The maximum length of the vehicle.
        public var maxLength: Swift.Int
        /// The maximum load capacity of the vehicle.
        public var maxPayloadCapacity: Swift.Int
        public var maxWeight: GeoRoutesClientTypes.RouteWeightConstraint?
        /// The maximum weight per axle of the vehicle.
        public var maxWeightPerAxle: Swift.Int
        /// The maximum weight per axle group of the vehicle.
        public var maxWeightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup?
        /// The maximum width of the vehicle.
        public var maxWidth: Swift.Int
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: GeoRoutesClientTypes.RouteNoticeDetailRange?
        /// The opening hours.
        public var openingHours: Swift.String?
        /// Access radiusestrictions based on time.
        public var restrictedTimes: Swift.String?
        /// The time dependent constraint.
        public var timeDependent: Swift.Bool?
        /// Number of trailers attached to the vehicle. Default Value: 0
        public var trailerCount: GeoRoutesClientTypes.RouteNoticeDetailRange?
        public var travelMode: Swift.Bool?
        /// Truck road type identifiers to be avoided. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico. There are currently no other supported values as of 26th April 2024.
        public var truckRoadType: Swift.String?
        /// Type of the truck.
        public var truckType: GeoRoutesClientTypes.RouteTruckType?
        /// The tunnel restriction code.
        public var tunnelRestrictionCode: Swift.String?

        public init(
            allHazardsRestricted: Swift.Bool? = nil,
            axleCount: GeoRoutesClientTypes.RouteNoticeDetailRange? = nil,
            hazardousCargos: [GeoRoutesClientTypes.RouteHazardousCargoType]? = nil,
            maxHeight: Swift.Int = 0,
            maxKpraLength: Swift.Int = 0,
            maxLength: Swift.Int = 0,
            maxPayloadCapacity: Swift.Int = 0,
            maxWeight: GeoRoutesClientTypes.RouteWeightConstraint? = nil,
            maxWeightPerAxle: Swift.Int = 0,
            maxWeightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup? = nil,
            maxWidth: Swift.Int = 0,
            occupancy: GeoRoutesClientTypes.RouteNoticeDetailRange? = nil,
            openingHours: Swift.String? = nil,
            restrictedTimes: Swift.String? = nil,
            timeDependent: Swift.Bool? = nil,
            trailerCount: GeoRoutesClientTypes.RouteNoticeDetailRange? = nil,
            travelMode: Swift.Bool? = nil,
            truckRoadType: Swift.String? = nil,
            truckType: GeoRoutesClientTypes.RouteTruckType? = nil,
            tunnelRestrictionCode: Swift.String? = nil
        )
        {
            self.allHazardsRestricted = allHazardsRestricted
            self.axleCount = axleCount
            self.hazardousCargos = hazardousCargos
            self.maxHeight = maxHeight
            self.maxKpraLength = maxKpraLength
            self.maxLength = maxLength
            self.maxPayloadCapacity = maxPayloadCapacity
            self.maxWeight = maxWeight
            self.maxWeightPerAxle = maxWeightPerAxle
            self.maxWeightPerAxleGroup = maxWeightPerAxleGroup
            self.maxWidth = maxWidth
            self.occupancy = occupancy
            self.openingHours = openingHours
            self.restrictedTimes = restrictedTimes
            self.timeDependent = timeDependent
            self.trailerCount = trailerCount
            self.travelMode = travelMode
            self.truckRoadType = truckRoadType
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
        }
    }
}

extension GeoRoutesClientTypes {

    /// Additional details of the notice.
    public struct RouteVehicleNoticeDetail: Swift.Sendable {
        /// The notice title.
        public var title: Swift.String?
        /// Any violated constraints.
        public var violatedConstraints: GeoRoutesClientTypes.RouteViolatedConstraints?

        public init(
            title: Swift.String? = nil,
            violatedConstraints: GeoRoutesClientTypes.RouteViolatedConstraints? = nil
        )
        {
            self.title = title
            self.violatedConstraints = violatedConstraints
        }
    }
}

extension GeoRoutesClientTypes {

    /// Notices are additional information returned that indicate issues that occurred during route calculation.
    public struct RouteVehicleNotice: Swift.Sendable {
        /// Code corresponding to the issue.
        /// This member is required.
        public var code: GeoRoutesClientTypes.RouteVehicleNoticeCode?
        /// Additional details of the notice.
        /// This member is required.
        public var details: [GeoRoutesClientTypes.RouteVehicleNoticeDetail]?
        /// Impact corresponding to the issue. While Low impact notices can be safely ignored, High impact notices must be evaluated furtherâ€¦
        public var impact: GeoRoutesClientTypes.RouteNoticeImpact?

        public init(
            code: GeoRoutesClientTypes.RouteVehicleNoticeCode? = nil,
            details: [GeoRoutesClientTypes.RouteVehicleNoticeDetail]? = nil,
            impact: GeoRoutesClientTypes.RouteNoticeImpact? = nil
        )
        {
            self.code = code
            self.details = details
            self.impact = impact
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanCarAccessAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowed
        case noThroughTraffic
        case tollRoad
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanCarAccessAttribute] {
            return [
                .allowed,
                .noThroughTraffic,
                .tollRoad
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "Allowed"
            case .noThroughTraffic: return "NoThroughTraffic"
            case .tollRoad: return "TollRoad"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanGateAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case emergency
        case keyAccess
        case permissionRequired
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanGateAttribute] {
            return [
                .emergency,
                .keyAccess,
                .permissionRequired
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .emergency: return "Emergency"
            case .keyAccess: return "KeyAccess"
            case .permissionRequired: return "PermissionRequired"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanRailwayCrossingAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case protected
        case unprotected
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanRailwayCrossingAttribute] {
            return [
                .protected,
                .unprotected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .protected: return "Protected"
            case .unprotected: return "Unprotected"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanScooterAccessAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowed
        case noThroughTraffic
        case tollRoad
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanScooterAccessAttribute] {
            return [
                .allowed,
                .noThroughTraffic,
                .tollRoad
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "Allowed"
            case .noThroughTraffic: return "NoThroughTraffic"
            case .tollRoad: return "TollRoad"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanTruckAccessAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowed
        case noThroughTraffic
        case tollRoad
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanTruckAccessAttribute] {
            return [
                .allowed,
                .noThroughTraffic,
                .tollRoad
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "Allowed"
            case .noThroughTraffic: return "NoThroughTraffic"
            case .tollRoad: return "TollRoad"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public struct RouteVehicleSpan: Swift.Sendable {
        public var bestCaseDuration: Swift.Int
        public var carAccess: [GeoRoutesClientTypes.RouteSpanCarAccessAttribute]?
        public var consumption: Swift.Double?
        public var country: Swift.String?
        public var distance: Swift.Int
        public var duration: Swift.Int
        public var dynamicSpeed: GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails?
        public var functionalClassification: Swift.Int?
        public var gate: GeoRoutesClientTypes.RouteSpanGateAttribute?
        public var geometryOffset: Swift.Int?
        public var incidents: [Swift.Int]?
        public var names: [GeoRoutesClientTypes.LocalizedString]?
        public var notices: [Swift.Int]?
        public var railwayCrossing: GeoRoutesClientTypes.RouteSpanRailwayCrossingAttribute?
        public var region: Swift.String?
        public var roadAttributes: [GeoRoutesClientTypes.RouteSpanRoadAttribute]?
        public var routeNumbers: [GeoRoutesClientTypes.RouteNumber]?
        public var scooterAccess: [GeoRoutesClientTypes.RouteSpanScooterAccessAttribute]?
        public var speedLimit: GeoRoutesClientTypes.RouteSpanSpeedLimitDetails?
        public var tollSystems: [Swift.Int]?
        public var truckAccess: [GeoRoutesClientTypes.RouteSpanTruckAccessAttribute]?
        public var truckRoadTypes: [Swift.Int]?
        public var typicalDuration: Swift.Int
        public var zones: [Swift.Int]?

        public init(
            bestCaseDuration: Swift.Int = 0,
            carAccess: [GeoRoutesClientTypes.RouteSpanCarAccessAttribute]? = nil,
            consumption: Swift.Double? = nil,
            country: Swift.String? = nil,
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            dynamicSpeed: GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails? = nil,
            functionalClassification: Swift.Int? = nil,
            gate: GeoRoutesClientTypes.RouteSpanGateAttribute? = nil,
            geometryOffset: Swift.Int? = nil,
            incidents: [Swift.Int]? = nil,
            names: [GeoRoutesClientTypes.LocalizedString]? = nil,
            notices: [Swift.Int]? = nil,
            railwayCrossing: GeoRoutesClientTypes.RouteSpanRailwayCrossingAttribute? = nil,
            region: Swift.String? = nil,
            roadAttributes: [GeoRoutesClientTypes.RouteSpanRoadAttribute]? = nil,
            routeNumbers: [GeoRoutesClientTypes.RouteNumber]? = nil,
            scooterAccess: [GeoRoutesClientTypes.RouteSpanScooterAccessAttribute]? = nil,
            speedLimit: GeoRoutesClientTypes.RouteSpanSpeedLimitDetails? = nil,
            tollSystems: [Swift.Int]? = nil,
            truckAccess: [GeoRoutesClientTypes.RouteSpanTruckAccessAttribute]? = nil,
            truckRoadTypes: [Swift.Int]? = nil,
            typicalDuration: Swift.Int = 0,
            zones: [Swift.Int]? = nil
        )
        {
            self.bestCaseDuration = bestCaseDuration
            self.carAccess = carAccess
            self.consumption = consumption
            self.country = country
            self.distance = distance
            self.duration = duration
            self.dynamicSpeed = dynamicSpeed
            self.functionalClassification = functionalClassification
            self.gate = gate
            self.geometryOffset = geometryOffset
            self.incidents = incidents
            self.names = names
            self.notices = notices
            self.railwayCrossing = railwayCrossing
            self.region = region
            self.roadAttributes = roadAttributes
            self.routeNumbers = routeNumbers
            self.scooterAccess = scooterAccess
            self.speedLimit = speedLimit
            self.tollSystems = tollSystems
            self.truckAccess = truckAccess
            self.truckRoadTypes = truckRoadTypes
            self.typicalDuration = typicalDuration
            self.zones = zones
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details of the leg.
    public struct RouteVehicleOverviewSummary: Swift.Sendable {
        /// Total duration in free flowing traffic, which is the best case or shortest duration possible to cover the leg.
        public var bestCaseDuration: Swift.Int
        /// Consumption to be used for the calculation. Units: Watt-hours for EV, and meters/Time for distance.
        public var consumption: Swift.Double?
        /// Distance of the step.
        /// This member is required.
        public var distance: Swift.Int
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int
        public var typicalDuration: Swift.Int

        public init(
            bestCaseDuration: Swift.Int = 0,
            consumption: Swift.Double? = nil,
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            typicalDuration: Swift.Int = 0
        )
        {
            self.bestCaseDuration = bestCaseDuration
            self.consumption = consumption
            self.distance = distance
            self.duration = duration
            self.typicalDuration = typicalDuration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details of the route.
    public struct RouteVehicleTravelOnlySummary: Swift.Sendable {
        /// Total duration in free flowing traffic, which is the best case or shortest duration possible to cover the leg.
        public var bestCaseDuration: Swift.Int
        /// Consumption to be used for the calculation. Units: Watt-hours for EV, and meters/Time for distance.
        public var consumption: Swift.Double?
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int
        public var typicalDuration: Swift.Int

        public init(
            bestCaseDuration: Swift.Int = 0,
            consumption: Swift.Double? = nil,
            duration: Swift.Int = 0,
            typicalDuration: Swift.Int = 0
        )
        {
            self.bestCaseDuration = bestCaseDuration
            self.consumption = consumption
            self.duration = duration
            self.typicalDuration = typicalDuration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details of the route.
    public struct RouteVehicleSummary: Swift.Sendable {
        /// Summarized details for the leg including before travel, travel and after travel steps.
        public var overview: GeoRoutesClientTypes.RouteVehicleOverviewSummary?
        /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is in meters
        public var travelOnly: GeoRoutesClientTypes.RouteVehicleTravelOnlySummary?

        public init(
            overview: GeoRoutesClientTypes.RouteVehicleOverviewSummary? = nil,
            travelOnly: GeoRoutesClientTypes.RouteVehicleTravelOnlySummary? = nil
        )
        {
            self.overview = overview
            self.travelOnly = travelOnly
        }
    }
}

extension GeoRoutesClientTypes {

    /// Locations or sites where the toll fare is collected.
    public struct RouteTollPaymentSite: Swift.Sendable {
        /// Name of the payment site.
        public var name: Swift.String?
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?

        public init(
            name: Swift.String? = nil,
            position: [Swift.Double]? = nil
        )
        {
            self.name = name
            self.position = position
        }
    }
}

extension GeoRoutesClientTypes.RouteTollPaymentSite: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteTollPaymentSite(name: \(Swift.String(describing: name)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Price range with a minimum and maximum value, if a range.
    public struct RouteTollPriceValueRange: Swift.Sendable {
        /// Maximum price.
        /// This member is required.
        public var max: Swift.Double?
        /// Minimum price.
        /// This member is required.
        public var min: Swift.Double?

        public init(
            max: Swift.Double? = nil,
            min: Swift.Double? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }
}

extension GeoRoutesClientTypes {

    /// The toll price.
    public struct RouteTollPrice: Swift.Sendable {
        /// Currency code corresponding to the price. This is the same as Currency specified in the request.
        /// This member is required.
        public var currency: Swift.String?
        /// If the price price is an estimate or an exact value. If any of the toll fares making up theâ€¦
        /// This member is required.
        public var estimate: Swift.Bool?
        /// Duration for which the price corresponds to.
        public var perDuration: Swift.Int
        /// If the price is a range or an exact value. If any of the toll fares making up the route is a range, the overall price is also a range.
        /// This member is required.
        public var range: Swift.Bool?
        /// Price range with a minimum and maximum value, if a range.
        public var rangeValue: GeoRoutesClientTypes.RouteTollPriceValueRange?
        /// Exact price, if not a range.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            currency: Swift.String? = nil,
            estimate: Swift.Bool? = nil,
            perDuration: Swift.Int = 0,
            range: Swift.Bool? = nil,
            rangeValue: GeoRoutesClientTypes.RouteTollPriceValueRange? = nil,
            value: Swift.Double? = nil
        )
        {
            self.currency = currency
            self.estimate = estimate
            self.perDuration = perDuration
            self.range = range
            self.rangeValue = rangeValue
            self.value = value
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTollPassValidityPeriodType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case annual
        case days
        case extendedAnnual
        case minutes
        case months
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTollPassValidityPeriodType] {
            return [
                .annual,
                .days,
                .extendedAnnual,
                .minutes,
                .months
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .annual: return "Annual"
            case .days: return "Days"
            case .extendedAnnual: return "ExtendedAnnual"
            case .minutes: return "Minutes"
            case .months: return "Months"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Period for which the pass is valid.
    public struct RouteTollPassValidityPeriod: Swift.Sendable {
        /// Validity period.
        /// This member is required.
        public var period: GeoRoutesClientTypes.RouteTollPassValidityPeriodType?
        /// Counts for the validity period.
        public var periodCount: Swift.Int?

        public init(
            period: GeoRoutesClientTypes.RouteTollPassValidityPeriodType? = nil,
            periodCount: Swift.Int? = nil
        )
        {
            self.period = period
            self.periodCount = periodCount
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details if the toll rate can be a pass that supports multiple trips.
    public struct RouteTollPass: Swift.Sendable {
        /// If the pass includes the rate for the return leg of the trip.
        public var includesReturnTrip: Swift.Bool?
        /// If the pass is only valid for senior persons.
        public var seniorPass: Swift.Bool?
        /// If the toll pass can be transferred, and how many times.
        public var transferCount: Swift.Int?
        /// Number of trips the pass is valid for.
        public var tripCount: Swift.Int?
        /// Period for which the pass is valid.
        public var validityPeriod: GeoRoutesClientTypes.RouteTollPassValidityPeriod?

        public init(
            includesReturnTrip: Swift.Bool? = nil,
            seniorPass: Swift.Bool? = nil,
            transferCount: Swift.Int? = nil,
            tripCount: Swift.Int? = nil,
            validityPeriod: GeoRoutesClientTypes.RouteTollPassValidityPeriod? = nil
        )
        {
            self.includesReturnTrip = includesReturnTrip
            self.seniorPass = seniorPass
            self.transferCount = transferCount
            self.tripCount = tripCount
            self.validityPeriod = validityPeriod
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTollPaymentMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bankCard
        case cash
        case cashExact
        case creditCard
        case passSubscription
        case transponder
        case travelCard
        case videoToll
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTollPaymentMethod] {
            return [
                .bankCard,
                .cash,
                .cashExact,
                .creditCard,
                .passSubscription,
                .transponder,
                .travelCard,
                .videoToll
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bankCard: return "BankCard"
            case .cash: return "Cash"
            case .cashExact: return "CashExact"
            case .creditCard: return "CreditCard"
            case .passSubscription: return "PassSubscription"
            case .transponder: return "Transponder"
            case .travelCard: return "TravelCard"
            case .videoToll: return "VideoToll"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Transponders for which this toll can be applied.
    public struct RouteTransponder: Swift.Sendable {
        /// Names of the toll system collecting the toll.
        public var systemName: Swift.String?

        public init(
            systemName: Swift.String? = nil
        )
        {
            self.systemName = systemName
        }
    }
}

extension GeoRoutesClientTypes {

    /// The toll rate.
    public struct RouteTollRate: Swift.Sendable {
        /// Time when the rate is valid.
        public var applicableTimes: Swift.String?
        /// Price in the converted currency as specified in the request.
        public var convertedPrice: GeoRoutesClientTypes.RouteTollPrice?
        /// The resource Id.
        /// This member is required.
        public var id: Swift.String?
        /// Price in the local regional currency.
        /// This member is required.
        public var localPrice: GeoRoutesClientTypes.RouteTollPrice?
        /// The name of the resource.
        /// This member is required.
        public var name: Swift.String?
        /// Details if the toll rate can be a pass that supports multiple trips.
        public var pass: GeoRoutesClientTypes.RouteTollPass?
        /// Accepted payment methods at the toll.
        /// This member is required.
        public var paymentMethods: [GeoRoutesClientTypes.RouteTollPaymentMethod]?
        /// Transponders for which this toll can be applied.
        /// This member is required.
        public var transponders: [GeoRoutesClientTypes.RouteTransponder]?

        public init(
            applicableTimes: Swift.String? = nil,
            convertedPrice: GeoRoutesClientTypes.RouteTollPrice? = nil,
            id: Swift.String? = nil,
            localPrice: GeoRoutesClientTypes.RouteTollPrice? = nil,
            name: Swift.String? = nil,
            pass: GeoRoutesClientTypes.RouteTollPass? = nil,
            paymentMethods: [GeoRoutesClientTypes.RouteTollPaymentMethod]? = nil,
            transponders: [GeoRoutesClientTypes.RouteTransponder]? = nil
        )
        {
            self.applicableTimes = applicableTimes
            self.convertedPrice = convertedPrice
            self.id = id
            self.localPrice = localPrice
            self.name = name
            self.pass = pass
            self.paymentMethods = paymentMethods
            self.transponders = transponders
        }
    }
}

extension GeoRoutesClientTypes {

    ///
    public struct RouteToll: Swift.Sendable {
        /// The alpha-2 or alpha-3 character code for the country.
        public var country: Swift.String?
        /// Locations or sites where the toll fare is collected.
        /// This member is required.
        public var paymentSites: [GeoRoutesClientTypes.RouteTollPaymentSite]?
        /// Toll rates that need to be paid to travel this leg of the route.
        /// This member is required.
        public var rates: [GeoRoutesClientTypes.RouteTollRate]?
        /// This member is required.
        public var systems: [Swift.Int]?

        public init(
            country: Swift.String? = nil,
            paymentSites: [GeoRoutesClientTypes.RouteTollPaymentSite]? = nil,
            rates: [GeoRoutesClientTypes.RouteTollRate]? = nil,
            systems: [Swift.Int]? = nil
        )
        {
            self.country = country
            self.paymentSites = paymentSites
            self.rates = rates
            self.systems = systems
        }
    }
}

extension GeoRoutesClientTypes {

    public struct RouteTollSystem: Swift.Sendable {
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the continue highway step.
    public struct RouteContinueHighwayStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the enter highway step.
    public struct RouteEnterHighwayStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RoutesVehicleTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arrive
        case `continue`
        case continueHighway
        case depart
        case enterHighway
        case exit
        case keep
        case ramp
        case roundaboutEnter
        case roundaboutExit
        case roundaboutPass
        case turn
        case uTurn
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutesVehicleTravelStepType] {
            return [
                .arrive,
                .continue,
                .continueHighway,
                .depart,
                .enterHighway,
                .exit,
                .keep,
                .ramp,
                .roundaboutEnter,
                .roundaboutExit,
                .roundaboutPass,
                .turn,
                .uTurn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arrive: return "Arrive"
            case .continue: return "Continue"
            case .continueHighway: return "ContinueHighway"
            case .depart: return "Depart"
            case .enterHighway: return "EnterHighway"
            case .exit: return "Exit"
            case .keep: return "Keep"
            case .ramp: return "Ramp"
            case .roundaboutEnter: return "RoundaboutEnter"
            case .roundaboutExit: return "RoundaboutExit"
            case .roundaboutPass: return "RoundaboutPass"
            case .turn: return "Turn"
            case .uTurn: return "UTurn"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that correspond to the the travel portion of the leg.
    public struct RouteVehicleTravelStep: Swift.Sendable {
        /// Details that are specific to a Continue Highway step.
        public var continueHighwayStepDetails: GeoRoutesClientTypes.RouteContinueHighwayStepDetails?
        /// Details that are specific to a Continue step.
        public var continueStepDetails: GeoRoutesClientTypes.RouteContinueStepDetails?
        /// Details of the current road.
        public var currentRoad: GeoRoutesClientTypes.RouteRoad?
        /// Distance of the step.
        public var distance: Swift.Int
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int
        /// Details that are specific to a Enter Highway step.
        public var enterHighwayStepDetails: GeoRoutesClientTypes.RouteEnterHighwayStepDetails?
        /// Exit number of the road exit, if applicable.
        public var exitNumber: [GeoRoutesClientTypes.LocalizedString]?
        /// Details that are specific to a Roundabout Exit step.
        public var exitStepDetails: GeoRoutesClientTypes.RouteExitStepDetails?
        /// Offset in the leg geometry corresponding to the start of this step.
        public var geometryOffset: Swift.Int?
        /// Brief description of the step in the requested language.
        public var instruction: Swift.String?
        /// Details that are specific to a Keep step.
        public var keepStepDetails: GeoRoutesClientTypes.RouteKeepStepDetails?
        /// Details of the next road. See RouteRoad for details of sub-attributes.
        public var nextRoad: GeoRoutesClientTypes.RouteRoad?
        /// Details that are specific to a Ramp step.
        public var rampStepDetails: GeoRoutesClientTypes.RouteRampStepDetails?
        /// Details that are specific to a Roundabout Enter step.
        public var roundaboutEnterStepDetails: GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails?
        /// Details that are specific to a Roundabout Exit step.
        public var roundaboutExitStepDetails: GeoRoutesClientTypes.RouteRoundaboutExitStepDetails?
        /// Details that are specific to a Roundabout Pass step.
        public var roundaboutPassStepDetails: GeoRoutesClientTypes.RouteRoundaboutPassStepDetails?
        /// Sign post information of the action, applicable only for TurnByTurn steps. See RouteSignpost for details of sub-attributes.
        public var signpost: GeoRoutesClientTypes.RouteSignpost?
        /// Details that are specific to a Turn step.
        public var turnStepDetails: GeoRoutesClientTypes.RouteTurnStepDetails?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RoutesVehicleTravelStepType?
        /// Details that are specific to a Turn step.
        public var uTurnStepDetails: GeoRoutesClientTypes.RouteUTurnStepDetails?

        public init(
            continueHighwayStepDetails: GeoRoutesClientTypes.RouteContinueHighwayStepDetails? = nil,
            continueStepDetails: GeoRoutesClientTypes.RouteContinueStepDetails? = nil,
            currentRoad: GeoRoutesClientTypes.RouteRoad? = nil,
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            enterHighwayStepDetails: GeoRoutesClientTypes.RouteEnterHighwayStepDetails? = nil,
            exitNumber: [GeoRoutesClientTypes.LocalizedString]? = nil,
            exitStepDetails: GeoRoutesClientTypes.RouteExitStepDetails? = nil,
            geometryOffset: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            keepStepDetails: GeoRoutesClientTypes.RouteKeepStepDetails? = nil,
            nextRoad: GeoRoutesClientTypes.RouteRoad? = nil,
            rampStepDetails: GeoRoutesClientTypes.RouteRampStepDetails? = nil,
            roundaboutEnterStepDetails: GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails? = nil,
            roundaboutExitStepDetails: GeoRoutesClientTypes.RouteRoundaboutExitStepDetails? = nil,
            roundaboutPassStepDetails: GeoRoutesClientTypes.RouteRoundaboutPassStepDetails? = nil,
            signpost: GeoRoutesClientTypes.RouteSignpost? = nil,
            turnStepDetails: GeoRoutesClientTypes.RouteTurnStepDetails? = nil,
            type: GeoRoutesClientTypes.RoutesVehicleTravelStepType? = nil,
            uTurnStepDetails: GeoRoutesClientTypes.RouteUTurnStepDetails? = nil
        )
        {
            self.continueHighwayStepDetails = continueHighwayStepDetails
            self.continueStepDetails = continueStepDetails
            self.currentRoad = currentRoad
            self.distance = distance
            self.duration = duration
            self.enterHighwayStepDetails = enterHighwayStepDetails
            self.exitNumber = exitNumber
            self.exitStepDetails = exitStepDetails
            self.geometryOffset = geometryOffset
            self.instruction = instruction
            self.keepStepDetails = keepStepDetails
            self.nextRoad = nextRoad
            self.rampStepDetails = rampStepDetails
            self.roundaboutEnterStepDetails = roundaboutEnterStepDetails
            self.roundaboutExitStepDetails = roundaboutExitStepDetails
            self.roundaboutPassStepDetails = roundaboutPassStepDetails
            self.signpost = signpost
            self.turnStepDetails = turnStepDetails
            self.type = type
            self.uTurnStepDetails = uTurnStepDetails
        }
    }
}

extension GeoRoutesClientTypes {

    /// The zone.
    public struct RouteZone: Swift.Sendable {
        /// The zone category.
        public var category: GeoRoutesClientTypes.RouteZoneCategory?
        /// The name of the zone.
        public var name: Swift.String?

        public init(
            category: GeoRoutesClientTypes.RouteZoneCategory? = nil,
            name: Swift.String? = nil
        )
        {
            self.category = category
            self.name = name
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that correspond to the the travel portion of the leg.
    public struct RouteVehicleLegDetails: Swift.Sendable {
        /// Steps of a leg that must be performed after the travel portion of the leg.
        /// This member is required.
        public var afterTravelSteps: [GeoRoutesClientTypes.RouteVehicleAfterTravelStep]?
        /// Details corresponding to the departure for the leg.
        /// This member is required.
        public var arrival: GeoRoutesClientTypes.RouteVehicleArrival?
        /// Details corresponding to the departure for the leg.
        /// This member is required.
        public var departure: GeoRoutesClientTypes.RouteVehicleDeparture?
        /// Incidents corresponding to this leg of the route.
        /// This member is required.
        public var incidents: [GeoRoutesClientTypes.RouteVehicleIncident]?
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        /// This member is required.
        public var notices: [GeoRoutesClientTypes.RouteVehicleNotice]?
        /// Waypoints that were passed through during the leg. This includes the waypoints that were configured with the PassThrough option.
        /// This member is required.
        public var passThroughWaypoints: [GeoRoutesClientTypes.RoutePassThroughWaypoint]?
        /// This member is required.
        public var spans: [GeoRoutesClientTypes.RouteVehicleSpan]?
        /// Summarized details of the leg.
        public var summary: GeoRoutesClientTypes.RouteVehicleSummary?
        /// This member is required.
        public var tollSystems: [GeoRoutesClientTypes.RouteTollSystem]?
        /// Toll related options.
        /// This member is required.
        public var tolls: [GeoRoutesClientTypes.RouteToll]?
        /// Steps of a leg that must be performed before the travel portion of the leg.
        /// This member is required.
        public var travelSteps: [GeoRoutesClientTypes.RouteVehicleTravelStep]?
        /// Truck road type identifiers to be avoided. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico. There are currently no other supported values as of 26th April 2024.
        /// This member is required.
        public var truckRoadTypes: [Swift.String]?
        /// Zones corresponding to this leg of the route.
        /// This member is required.
        public var zones: [GeoRoutesClientTypes.RouteZone]?

        public init(
            afterTravelSteps: [GeoRoutesClientTypes.RouteVehicleAfterTravelStep]? = nil,
            arrival: GeoRoutesClientTypes.RouteVehicleArrival? = nil,
            departure: GeoRoutesClientTypes.RouteVehicleDeparture? = nil,
            incidents: [GeoRoutesClientTypes.RouteVehicleIncident]? = nil,
            notices: [GeoRoutesClientTypes.RouteVehicleNotice]? = nil,
            passThroughWaypoints: [GeoRoutesClientTypes.RoutePassThroughWaypoint]? = nil,
            spans: [GeoRoutesClientTypes.RouteVehicleSpan]? = nil,
            summary: GeoRoutesClientTypes.RouteVehicleSummary? = nil,
            tollSystems: [GeoRoutesClientTypes.RouteTollSystem]? = nil,
            tolls: [GeoRoutesClientTypes.RouteToll]? = nil,
            travelSteps: [GeoRoutesClientTypes.RouteVehicleTravelStep]? = nil,
            truckRoadTypes: [Swift.String]? = nil,
            zones: [GeoRoutesClientTypes.RouteZone]? = nil
        )
        {
            self.afterTravelSteps = afterTravelSteps
            self.arrival = arrival
            self.departure = departure
            self.incidents = incidents
            self.notices = notices
            self.passThroughWaypoints = passThroughWaypoints
            self.spans = spans
            self.summary = summary
            self.tollSystems = tollSystems
            self.tolls = tolls
            self.travelSteps = travelSteps
            self.truckRoadTypes = truckRoadTypes
            self.zones = zones
        }
    }
}

extension GeoRoutesClientTypes {

    /// A leg is a section of a route from one waypoint to the next. A leg could be of type Vehicle, Pedestrian or Ferry. Legs of different types could occur together within a single route. For example, a car employing the use of a Ferry will contain Vehicle legs corresponding to journey on land, and Ferry legs corresponding to the journey via Ferry.
    public struct RouteLeg: Swift.Sendable {
        /// FerryLegDetails is populated when the Leg type is Ferry, and provides additional information that is specifify
        public var ferryLegDetails: GeoRoutesClientTypes.RouteFerryLegDetails?
        /// Geometry of the area to be avoided.
        /// This member is required.
        public var geometry: GeoRoutesClientTypes.RouteLegGeometry?
        /// List of languages for instructions within steps in the response.
        public var language: Swift.String?
        /// Details related to the pedestrian leg.
        public var pedestrianLegDetails: GeoRoutesClientTypes.RoutePedestrianLegDetails?
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value:Car
        /// This member is required.
        public var travelMode: GeoRoutesClientTypes.RouteLegTravelMode?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RouteLegType?
        /// Details related to the vehicle leg.
        public var vehicleLegDetails: GeoRoutesClientTypes.RouteVehicleLegDetails?

        public init(
            ferryLegDetails: GeoRoutesClientTypes.RouteFerryLegDetails? = nil,
            geometry: GeoRoutesClientTypes.RouteLegGeometry? = nil,
            language: Swift.String? = nil,
            pedestrianLegDetails: GeoRoutesClientTypes.RoutePedestrianLegDetails? = nil,
            travelMode: GeoRoutesClientTypes.RouteLegTravelMode? = nil,
            type: GeoRoutesClientTypes.RouteLegType? = nil,
            vehicleLegDetails: GeoRoutesClientTypes.RouteVehicleLegDetails? = nil
        )
        {
            self.ferryLegDetails = ferryLegDetails
            self.geometry = geometry
            self.language = language
            self.pedestrianLegDetails = pedestrianLegDetails
            self.travelMode = travelMode
            self.type = type
            self.vehicleLegDetails = vehicleLegDetails
        }
    }
}

extension GeoRoutesClientTypes {

    /// Important labels including names and route numbers that differentiate the current route from the alternatives presented.
    public struct RouteMajorRoadLabel: Swift.Sendable {
        /// Name of the road (localized).
        public var roadName: GeoRoutesClientTypes.LocalizedString?
        /// Route number of the road.
        public var routeNumber: GeoRoutesClientTypes.RouteNumber?

        public init(
            roadName: GeoRoutesClientTypes.LocalizedString? = nil,
            routeNumber: GeoRoutesClientTypes.RouteNumber? = nil
        )
        {
            self.roadName = roadName
            self.routeNumber = routeNumber
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summary of the route and toll price.
    public struct RouteTollPriceSummary: Swift.Sendable {
        /// Currency code corresponding to the price. This is the same as Currency specified in the request.
        /// This member is required.
        public var currency: Swift.String?
        /// If the price price is an estimate or an exact value. If any of the toll fares making up theâ€¦
        /// This member is required.
        public var estimate: Swift.Bool?
        /// If the price is a range or an exact value. If any of the toll fares making up the route is a range, the overall price is also a range.
        /// This member is required.
        public var range: Swift.Bool?
        /// Price range with a minimum and maximum value, if a range.
        public var rangeValue: GeoRoutesClientTypes.RouteTollPriceValueRange?
        /// Exact price, if not a range.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            currency: Swift.String? = nil,
            estimate: Swift.Bool? = nil,
            range: Swift.Bool? = nil,
            rangeValue: GeoRoutesClientTypes.RouteTollPriceValueRange? = nil,
            value: Swift.Double? = nil
        )
        {
            self.currency = currency
            self.estimate = estimate
            self.range = range
            self.rangeValue = rangeValue
            self.value = value
        }
    }
}

extension GeoRoutesClientTypes {

    /// The toll summarization for the complete route.
    public struct RouteTollSummary: Swift.Sendable {
        /// Total toll summarization for the complete route. Total is the only summarization available today.
        public var total: GeoRoutesClientTypes.RouteTollPriceSummary?

        public init(
            total: GeoRoutesClientTypes.RouteTollPriceSummary? = nil
        )
        {
            self.total = total
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details of the route.
    public struct RouteSummary: Swift.Sendable {
        /// Distance of the step.
        /// This member is required.
        public var distance: Swift.Int
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int
        /// Toll summarization for the complete route.
        public var tolls: GeoRoutesClientTypes.RouteTollSummary?

        public init(
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            tolls: GeoRoutesClientTypes.RouteTollSummary? = nil
        )
        {
            self.distance = distance
            self.duration = duration
            self.tolls = tolls
        }
    }
}

extension GeoRoutesClientTypes {

    /// The route.
    public struct Route: Swift.Sendable {
        /// A leg is a section of a route from one waypoint to the next. A leg could be of type Vehicle, Pedestrian or Ferry. Legs of different types could occur together within a single route. For example, a car employing the use of a Ferry will contain Vehicle legs corresponding to journey on land, and Ferry legs corresponding to the journey via Ferry.
        /// This member is required.
        public var legs: [GeoRoutesClientTypes.RouteLeg]?
        /// Important labels including names and route numbers that differentiate the current route from the alternatives presented.
        /// This member is required.
        public var majorRoadLabels: [GeoRoutesClientTypes.RouteMajorRoadLabel]?
        /// Summarized details of the leg.
        public var summary: GeoRoutesClientTypes.RouteSummary?

        public init(
            legs: [GeoRoutesClientTypes.RouteLeg]? = nil,
            majorRoadLabels: [GeoRoutesClientTypes.RouteMajorRoadLabel]? = nil,
            summary: GeoRoutesClientTypes.RouteSummary? = nil
        )
        {
            self.legs = legs
            self.majorRoadLabels = majorRoadLabels
            self.summary = summary
        }
    }
}

public struct CalculateRoutesOutput: Swift.Sendable {
    /// This member is required.
    public var legGeometryFormat: GeoRoutesClientTypes.GeometryFormat?
    /// Notices are additional information returned that indicate issues that occurred during route calculation.
    /// This member is required.
    public var notices: [GeoRoutesClientTypes.RouteResponseNotice]?
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// The path from the origin to the destination.
    /// This member is required.
    public var routes: [GeoRoutesClientTypes.Route]?

    public init(
        legGeometryFormat: GeoRoutesClientTypes.GeometryFormat? = nil,
        notices: [GeoRoutesClientTypes.RouteResponseNotice]? = nil,
        pricingBucket: Swift.String? = nil,
        routes: [GeoRoutesClientTypes.Route]? = nil
    )
    {
        self.legGeometryFormat = legGeometryFormat
        self.notices = notices
        self.pricingBucket = pricingBucket
        self.routes = routes
    }
}

extension GeoRoutesClientTypes {

    public enum DayOfWeek: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "Friday"
            case .monday: return "Monday"
            case .saturday: return "Saturday"
            case .sunday: return "Sunday"
            case .thursday: return "Thursday"
            case .tuesday: return "Tuesday"
            case .wednesday: return "Wednesday"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Geometry of the area to be avoided.
    public struct WaypointOptimizationAvoidanceAreaGeometry: Swift.Sendable {
        /// Gometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public var boundingBox: [Swift.Double]?

        public init(
            boundingBox: [Swift.Double]? = nil
        )
        {
            self.boundingBox = boundingBox
        }
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationAvoidanceAreaGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WaypointOptimizationAvoidanceAreaGeometry(boundingBox: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// The area to be avoided.
    public struct WaypointOptimizationAvoidanceArea: Swift.Sendable {
        /// Geometry of the area to be avoided.
        /// This member is required.
        public var geometry: GeoRoutesClientTypes.WaypointOptimizationAvoidanceAreaGeometry?

        public init(
            geometry: GeoRoutesClientTypes.WaypointOptimizationAvoidanceAreaGeometry? = nil
        )
        {
            self.geometry = geometry
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options for WaypointOptimizationAvoidance.
    public struct WaypointOptimizationAvoidanceOptions: Swift.Sendable {
        /// Areas to be avoided.
        public var areas: [GeoRoutesClientTypes.WaypointOptimizationAvoidanceArea]?
        public var carShuttleTrains: Swift.Bool?
        /// Avoid controlled access highways for calculation.
        public var controlledAccessHighways: Swift.Bool?
        /// Avoid dirt roads for calculation.
        public var dirtRoads: Swift.Bool?
        public var ferries: Swift.Bool?
        /// Avoid toll roads for calculation.
        public var tollRoads: Swift.Bool?
        /// Avoid tunnels for calculation.
        public var tunnels: Swift.Bool?
        /// Avoid u turns for calculation on highways and motorways.
        public var uTurns: Swift.Bool?

        public init(
            areas: [GeoRoutesClientTypes.WaypointOptimizationAvoidanceArea]? = nil,
            carShuttleTrains: Swift.Bool? = nil,
            controlledAccessHighways: Swift.Bool? = nil,
            dirtRoads: Swift.Bool? = nil,
            ferries: Swift.Bool? = nil,
            tollRoads: Swift.Bool? = nil,
            tunnels: Swift.Bool? = nil,
            uTurns: Swift.Bool? = nil
        )
        {
            self.areas = areas
            self.carShuttleTrains = carShuttleTrains
            self.controlledAccessHighways = controlledAccessHighways
            self.dirtRoads = dirtRoads
            self.ferries = ferries
            self.tollRoads = tollRoads
            self.tunnels = tunnels
            self.uTurns = uTurns
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationClusteringAlgorithm: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case drivingDistance
        case topologySegment
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationClusteringAlgorithm] {
            return [
                .drivingDistance,
                .topologySegment
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .drivingDistance: return "DrivingDistance"
            case .topologySegment: return "TopologySegment"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Driving distance related options.
    public struct WaypointOptimizationDrivingDistanceOptions: Swift.Sendable {
        /// DrivingDistance assigns all the waypoints that are within driving distance of each other into a single cluster.
        /// This member is required.
        public var drivingDistance: Swift.Int

        public init(
            drivingDistance: Swift.Int = 0
        )
        {
            self.drivingDistance = drivingDistance
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options for WaypointOptimizationClustering.
    public struct WaypointOptimizationClusteringOptions: Swift.Sendable {
        /// The algorithm to be used. DrivingDistance assigns all the waypoints that are within driving distance of each other into a single cluster. TopologySegment assigns all the waypoints that are within the same topology segment into a single cluster. A Topology segment is a linear stretch of road between two junctions.
        /// This member is required.
        public var algorithm: GeoRoutesClientTypes.WaypointOptimizationClusteringAlgorithm?
        /// Driving distance options to be used when the clustering algorithm is DrivingDistance.
        public var drivingDistanceOptions: GeoRoutesClientTypes.WaypointOptimizationDrivingDistanceOptions?

        public init(
            algorithm: GeoRoutesClientTypes.WaypointOptimizationClusteringAlgorithm? = nil,
            drivingDistanceOptions: GeoRoutesClientTypes.WaypointOptimizationDrivingDistanceOptions? = nil
        )
        {
            self.algorithm = algorithm
            self.drivingDistanceOptions = drivingDistanceOptions
        }
    }
}

extension GeoRoutesClientTypes {

    /// Hours of entry.
    public struct WaypointOptimizationAccessHoursEntry: Swift.Sendable {
        /// Day of the week.
        /// This member is required.
        public var dayOfWeek: GeoRoutesClientTypes.DayOfWeek?
        /// Time of the day.
        /// This member is required.
        public var timeOfDay: Swift.String?

        public init(
            dayOfWeek: GeoRoutesClientTypes.DayOfWeek? = nil,
            timeOfDay: Swift.String? = nil
        )
        {
            self.dayOfWeek = dayOfWeek
            self.timeOfDay = timeOfDay
        }
    }
}

extension GeoRoutesClientTypes {

    /// Access hours corresponding to when a destination can be visited.
    public struct WaypointOptimizationAccessHours: Swift.Sendable {
        /// From when the destination can be visited.
        /// This member is required.
        public var from: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry?
        /// To when the destination can be visited
        /// This member is required.
        public var to: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry?

        public init(
            from: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry? = nil,
            to: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry? = nil
        )
        {
            self.from = from
            self.to = to
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options to configure matching the provided position to a side of the street.
    public struct WaypointOptimizationSideOfStreetOptions: Swift.Sendable {
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?
        /// Strategy that defines when the side of street position should be used. AnyStreet will always use the provided position. Default Value: DividedStreetOnly
        public var useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy?

        public init(
            position: [Swift.Double]? = nil,
            useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy? = nil
        )
        {
            self.position = position
            self.useWith = useWith
        }
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WaypointOptimizationSideOfStreetOptions(useWith: \(Swift.String(describing: useWith)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Desination related options.
    public struct WaypointOptimizationDestinationOptions: Swift.Sendable {
        /// Access hours corresponding to when a waypoint can be visited.
        public var accessHours: GeoRoutesClientTypes.WaypointOptimizationAccessHours?
        /// Appointment time at the destination.
        public var appointmentTime: Swift.String?
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// The resource Id.
        public var id: Swift.String?
        /// Service time spent at the destination. At an appointment, the service time should be the appointment duration.
        public var serviceDuration: Swift.Int
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions?

        public init(
            accessHours: GeoRoutesClientTypes.WaypointOptimizationAccessHours? = nil,
            appointmentTime: Swift.String? = nil,
            heading: Swift.Double = 0.0,
            id: Swift.String? = nil,
            serviceDuration: Swift.Int = 0,
            sideOfStreet: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions? = nil
        )
        {
            self.accessHours = accessHours
            self.appointmentTime = appointmentTime
            self.heading = heading
            self.id = id
            self.serviceDuration = serviceDuration
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes {

    /// Driver work-rest schedules defined by a short and long cycle. A rest needs to be taken after the short work duration. The short cycle can be repeated until you hit the long work duration, at which point the long rest duration should be taken before restarting.
    public struct WaypointOptimizationRestCycleDurations: Swift.Sendable {
        /// Resting phase of the cycle.
        /// This member is required.
        public var restDuration: Swift.Int
        /// Working phase of the cycle.
        /// This member is required.
        public var workDuration: Swift.Int

        public init(
            restDuration: Swift.Int = 0,
            workDuration: Swift.Int = 0
        )
        {
            self.restDuration = restDuration
            self.workDuration = workDuration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Resting phase of the cycle.
    public struct WaypointOptimizationRestCycles: Swift.Sendable {
        /// Long cycle for a driver work-rest schedule.
        /// This member is required.
        public var longCycle: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations?
        /// Short cycle for a driver work-rest schedule
        /// This member is required.
        public var shortCycle: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations?

        public init(
            longCycle: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations? = nil,
            shortCycle: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations? = nil
        )
        {
            self.longCycle = longCycle
            self.shortCycle = shortCycle
        }
    }
}

extension GeoRoutesClientTypes {

    /// Pre defined rest profiles for a driver shcedule. The only currently supported profile is EU.
    public struct WaypointOptimizationRestProfile: Swift.Sendable {
        /// Pre defined rest profiles for a driver shcedule. The only currently supported profile is EU.
        /// This member is required.
        public var profile: Swift.String?

        public init(
            profile: Swift.String? = nil
        )
        {
            self.profile = profile
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationServiceTimeTreatment: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case rest
        case work
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationServiceTimeTreatment] {
            return [
                .rest,
                .work
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rest: return "Rest"
            case .work: return "Work"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Driver related options.
    public struct WaypointOptimizationDriverOptions: Swift.Sendable {
        /// Driver work-rest schedules defined by a short and long cycle. A rest needs to be taken after the short work duration. The short cycle can be repeated until you hit the long work duration, at which point the long rest duration should be taken before restarting.
        public var restCycles: GeoRoutesClientTypes.WaypointOptimizationRestCycles?
        /// Pre defined rest profiles for a driver shcedule. The only currently supported profile is EU.
        public var restProfile: GeoRoutesClientTypes.WaypointOptimizationRestProfile?
        /// If the service time provided at a waypoint/destination should be considered as rest or work. This contributes to the total time breakdown returned within the response.
        public var treatServiceTimeAs: GeoRoutesClientTypes.WaypointOptimizationServiceTimeTreatment?

        public init(
            restCycles: GeoRoutesClientTypes.WaypointOptimizationRestCycles? = nil,
            restProfile: GeoRoutesClientTypes.WaypointOptimizationRestProfile? = nil,
            treatServiceTimeAs: GeoRoutesClientTypes.WaypointOptimizationServiceTimeTreatment? = nil
        )
        {
            self.restCycles = restCycles
            self.restProfile = restProfile
            self.treatServiceTimeAs = treatServiceTimeAs
        }
    }
}

extension GeoRoutesClientTypes {

    /// Exclusion options.
    public struct WaypointOptimizationExclusionOptions: Swift.Sendable {
        /// List of countries to be avoided defined by two-letter or three-letter country codes.
        /// This member is required.
        public var countries: [Swift.String]?

        public init(
            countries: [Swift.String]? = nil
        )
        {
            self.countries = countries
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationSequencingObjective: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fastestRoute
        case shortestRoute
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationSequencingObjective] {
            return [
                .fastestRoute,
                .shortestRoute
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fastestRoute: return "FastestRoute"
            case .shortestRoute: return "ShortestRoute"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to the origin.
    public struct WaypointOptimizationOriginOptions: Swift.Sendable {
        /// The resource Id.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to traffic.
    public struct WaypointOptimizationTrafficOptions: Swift.Sendable {
        /// Determines if traffic should be used or ignored for calculation. Default Value: UseTrafficData
        public var usage: GeoRoutesClientTypes.TrafficUsage?

        public init(
            usage: GeoRoutesClientTypes.TrafficUsage? = nil
        )
        {
            self.usage = usage
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationTravelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case car
        case pedestrian
        case scooter
        case truck
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationTravelMode] {
            return [
                .car,
                .pedestrian,
                .scooter,
                .truck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .pedestrian: return "Pedestrian"
            case .scooter: return "Scooter"
            case .truck: return "Truck"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Charging time if the vehicle is electric.
    public struct WaypointOptimizationChargingTime: Swift.Sendable {
        /// Charging time if the vehicle is electric.
        /// This member is required.
        public var chargingTime: Swift.Int
        /// Distance that can be covered when the battery is charged for ChargingTime.
        /// This member is required.
        public var rangeIncrease: Swift.Int

        public init(
            chargingTime: Swift.Int = 0,
            rangeIncrease: Swift.Int = 0
        )
        {
            self.chargingTime = chargingTime
            self.rangeIncrease = rangeIncrease
        }
    }
}

extension GeoRoutesClientTypes {

    /// Electric vehicle related options.
    public struct WaypointOptimizationEvOptions: Swift.Sendable {
        /// Charging time if the vehicle is electric.
        public var chargingTime: GeoRoutesClientTypes.WaypointOptimizationChargingTime?

        public init(
            chargingTime: GeoRoutesClientTypes.WaypointOptimizationChargingTime? = nil
        )
        {
            self.chargingTime = chargingTime
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to a pedestrian.
    public struct WaypointOptimizationPedestrianOptions: Swift.Sendable {
        /// Walking speed in Kilometers per hour.
        public var speed: Swift.Double?

        public init(
            speed: Swift.Double? = 0.0
        )
        {
            self.speed = speed
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationHazardousCargoType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case combustible
        case corrosive
        case explosive
        case flammable
        case gas
        case harmfulToWater
        case organic
        case other
        case poison
        case poisonousInhalation
        case radioactive
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationHazardousCargoType] {
            return [
                .combustible,
                .corrosive,
                .explosive,
                .flammable,
                .gas,
                .harmfulToWater,
                .organic,
                .other,
                .poison,
                .poisonousInhalation,
                .radioactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .combustible: return "Combustible"
            case .corrosive: return "Corrosive"
            case .explosive: return "Explosive"
            case .flammable: return "Flammable"
            case .gas: return "Gas"
            case .harmfulToWater: return "HarmfulToWater"
            case .organic: return "Organic"
            case .other: return "Other"
            case .poison: return "Poison"
            case .poisonousInhalation: return "PoisonousInhalation"
            case .radioactive: return "Radioactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Trailer options corresponding to the vehicle.
    public struct WaypointOptimizationTrailerOptions: Swift.Sendable {
        /// Number of trailers attached to the vehicle. Default Value: 0
        public var trailerCount: Swift.Int?

        public init(
            trailerCount: Swift.Int? = nil
        )
        {
            self.trailerCount = trailerCount
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationTruckType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case straightTruck
        case tractor
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationTruckType] {
            return [
                .straightTruck,
                .tractor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .straightTruck: return "StraightTruck"
            case .tractor: return "Tractor"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Truck"
    public struct WaypointOptimizationTruckOptions: Swift.Sendable {
        /// Gross weight of the vehicle including trailers, and goods at capacity.
        public var grossWeight: Swift.Int
        /// List of Hazardous cargos contained in the vehicle.
        public var hazardousCargos: [GeoRoutesClientTypes.WaypointOptimizationHazardousCargoType]?
        /// Height of the vehicle in centimeters.
        public var height: Swift.Int
        /// Length of the vehicle in meters.
        public var length: Swift.Int
        /// Trailer options corresponding to the vehicle.
        public var trailer: GeoRoutesClientTypes.WaypointOptimizationTrailerOptions?
        /// Type of the truck.
        public var truckType: GeoRoutesClientTypes.WaypointOptimizationTruckType?
        /// The tunnel restriction code.
        public var tunnelRestrictionCode: Swift.String?
        /// Heaviest weight per axle irrespective of the axle type or the axle group. Meant for usage in countries where the differences in axle types or axle groups are not distinguished. Unit: Kilograms
        public var weightPerAxle: Swift.Int
        /// Width of the vehicle in centimenters.
        public var width: Swift.Int

        public init(
            grossWeight: Swift.Int = 0,
            hazardousCargos: [GeoRoutesClientTypes.WaypointOptimizationHazardousCargoType]? = nil,
            height: Swift.Int = 0,
            length: Swift.Int = 0,
            trailer: GeoRoutesClientTypes.WaypointOptimizationTrailerOptions? = nil,
            truckType: GeoRoutesClientTypes.WaypointOptimizationTruckType? = nil,
            tunnelRestrictionCode: Swift.String? = nil,
            weightPerAxle: Swift.Int = 0,
            width: Swift.Int = 0
        )
        {
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.length = length
            self.trailer = trailer
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.weightPerAxle = weightPerAxle
            self.width = width
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode related options for the provided travel mode.
    public struct WaypointOptimizationTravelModeOptions: Swift.Sendable {
        /// Ev option if the vehicle is electric powered.
        public var ev: GeoRoutesClientTypes.WaypointOptimizationEvOptions?
        /// Travel mode options when the provided travel mode is "Pedestrian"
        public var pedestrian: GeoRoutesClientTypes.WaypointOptimizationPedestrianOptions?
        /// Travel mode options when the provided travel mode is "Truck"
        public var truck: GeoRoutesClientTypes.WaypointOptimizationTruckOptions?

        public init(
            ev: GeoRoutesClientTypes.WaypointOptimizationEvOptions? = nil,
            pedestrian: GeoRoutesClientTypes.WaypointOptimizationPedestrianOptions? = nil,
            truck: GeoRoutesClientTypes.WaypointOptimizationTruckOptions? = nil
        )
        {
            self.ev = ev
            self.pedestrian = pedestrian
            self.truck = truck
        }
    }
}

extension GeoRoutesClientTypes {

    /// List of waypoints between the Origin and Destination.
    public struct WaypointOptimizationWaypoint: Swift.Sendable {
        /// Access hours corresponding to when a waypoint can be visited.
        public var accessHours: GeoRoutesClientTypes.WaypointOptimizationAccessHours?
        /// Appointment time at the destination.
        public var appointmentTime: Swift.String?
        /// Constraint defining what waypoints are to be visited after this waypoint.
        public var before: [Swift.Int]?
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// The resource Id.
        public var id: Swift.String?
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?
        /// Service time spent at the destination. At an appointment, the service time should be the appointment duration.
        public var serviceDuration: Swift.Int
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions?

        public init(
            accessHours: GeoRoutesClientTypes.WaypointOptimizationAccessHours? = nil,
            appointmentTime: Swift.String? = nil,
            before: [Swift.Int]? = nil,
            heading: Swift.Double = 0.0,
            id: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            serviceDuration: Swift.Int = 0,
            sideOfStreet: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions? = nil
        )
        {
            self.accessHours = accessHours
            self.appointmentTime = appointmentTime
            self.before = before
            self.heading = heading
            self.id = id
            self.position = position
            self.serviceDuration = serviceDuration
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationWaypoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WaypointOptimizationWaypoint(accessHours: \(Swift.String(describing: accessHours)), appointmentTime: \(Swift.String(describing: appointmentTime)), before: \(Swift.String(describing: before)), heading: \(Swift.String(describing: heading)), id: \(Swift.String(describing: id)), serviceDuration: \(Swift.String(describing: serviceDuration)), sideOfStreet: \(Swift.String(describing: sideOfStreet)), position: \"CONTENT_REDACTED\")"}
}

public struct OptimizeWaypointsInput: Swift.Sendable {
    /// Features that are avoided while calculation. Avoidance is on a best-case basis. If an avoidance cannot be satisfied for a particular case, this setting is ignored.
    public var avoid: GeoRoutesClientTypes.WaypointOptimizationAvoidanceOptions?
    /// Clustering allows you to specify how nearby waypoints can be clustered to improve the optimized sequence.
    public var clustering: GeoRoutesClientTypes.WaypointOptimizationClusteringOptions?
    /// Departure time from the waypoint. Template:YYYY-MM-DDThh:mm:ss.sssZ YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var departureTime: Swift.String?
    /// The finish position for the route. In the World Geodetic System (WGS 84) format: (longitude, latitude).
    public var destination: [Swift.Double]?
    /// Desination related options.
    public var destinationOptions: GeoRoutesClientTypes.WaypointOptimizationDestinationOptions?
    /// Driver related options.
    public var driver: GeoRoutesClientTypes.WaypointOptimizationDriverOptions?
    /// Features to be strictly excluded for calculation.
    public var exclude: GeoRoutesClientTypes.WaypointOptimizationExclusionOptions?
    /// Optional: The API key to be used for authorization. Optional, either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// Specifies the optimization criteria for the calculated sequence. Default Value: FastestRoute
    public var optimizeSequencingFor: GeoRoutesClientTypes.WaypointOptimizationSequencingObjective?
    /// The start position for the route.
    /// This member is required.
    public var origin: [Swift.Double]?
    /// Origin related options.
    public var originOptions: GeoRoutesClientTypes.WaypointOptimizationOriginOptions?
    /// Traffic related options.
    public var traffic: GeoRoutesClientTypes.WaypointOptimizationTrafficOptions?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value:Car
    public var travelMode: GeoRoutesClientTypes.WaypointOptimizationTravelMode?
    /// Travel mode related options for the provided travel mode.
    public var travelModeOptions: GeoRoutesClientTypes.WaypointOptimizationTravelModeOptions?
    /// List of waypoints between the Origin and Destination.
    public var waypoints: [GeoRoutesClientTypes.WaypointOptimizationWaypoint]?

    public init(
        avoid: GeoRoutesClientTypes.WaypointOptimizationAvoidanceOptions? = nil,
        clustering: GeoRoutesClientTypes.WaypointOptimizationClusteringOptions? = nil,
        departureTime: Swift.String? = nil,
        destination: [Swift.Double]? = nil,
        destinationOptions: GeoRoutesClientTypes.WaypointOptimizationDestinationOptions? = nil,
        driver: GeoRoutesClientTypes.WaypointOptimizationDriverOptions? = nil,
        exclude: GeoRoutesClientTypes.WaypointOptimizationExclusionOptions? = nil,
        key: Swift.String? = nil,
        optimizeSequencingFor: GeoRoutesClientTypes.WaypointOptimizationSequencingObjective? = nil,
        origin: [Swift.Double]? = nil,
        originOptions: GeoRoutesClientTypes.WaypointOptimizationOriginOptions? = nil,
        traffic: GeoRoutesClientTypes.WaypointOptimizationTrafficOptions? = nil,
        travelMode: GeoRoutesClientTypes.WaypointOptimizationTravelMode? = nil,
        travelModeOptions: GeoRoutesClientTypes.WaypointOptimizationTravelModeOptions? = nil,
        waypoints: [GeoRoutesClientTypes.WaypointOptimizationWaypoint]? = nil
    )
    {
        self.avoid = avoid
        self.clustering = clustering
        self.departureTime = departureTime
        self.destination = destination
        self.destinationOptions = destinationOptions
        self.driver = driver
        self.exclude = exclude
        self.key = key
        self.optimizeSequencingFor = optimizeSequencingFor
        self.origin = origin
        self.originOptions = originOptions
        self.traffic = traffic
        self.travelMode = travelMode
        self.travelModeOptions = travelModeOptions
        self.waypoints = waypoints
    }
}

extension OptimizeWaypointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptimizeWaypointsInput(avoid: \(Swift.String(describing: avoid)), clustering: \(Swift.String(describing: clustering)), departureTime: \(Swift.String(describing: departureTime)), destinationOptions: \(Swift.String(describing: destinationOptions)), driver: \(Swift.String(describing: driver)), exclude: \(Swift.String(describing: exclude)), optimizeSequencingFor: \(Swift.String(describing: optimizeSequencingFor)), originOptions: \(Swift.String(describing: originOptions)), traffic: \(Swift.String(describing: traffic)), travelMode: \(Swift.String(describing: travelMode)), travelModeOptions: \(Swift.String(describing: travelModeOptions)), waypoints: \(Swift.String(describing: waypoints)), destination: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", origin: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Isolines may contain multiple components, if these components are connected by ferry links. These components are returned as separate polygons while the ferry links are returned as connections.
    public struct WaypointOptimizationConnection: Swift.Sendable {
        /// Distance of the step.
        /// This member is required.
        public var distance: Swift.Int
        /// From when the destination can be visited.
        /// This member is required.
        public var from: Swift.String?
        /// Resting time before the driver can continue driving.
        /// This member is required.
        public var restDuration: Swift.Int
        /// To when the destination can be visited
        /// This member is required.
        public var to: Swift.String?
        /// Total duration.
        /// This member is required.
        public var travelDuration: Swift.Int
        /// Duration of a wait step.
        /// This member is required.
        public var waitDuration: Swift.Int

        public init(
            distance: Swift.Int = 0,
            from: Swift.String? = nil,
            restDuration: Swift.Int = 0,
            to: Swift.String? = nil,
            travelDuration: Swift.Int = 0,
            waitDuration: Swift.Int = 0
        )
        {
            self.distance = distance
            self.from = from
            self.restDuration = restDuration
            self.to = to
            self.travelDuration = travelDuration
            self.waitDuration = waitDuration
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationConstraint: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessHours
        case appointmentTime
        case before
        case heading
        case serviceDuration
        case sideOfStreet
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationConstraint] {
            return [
                .accessHours,
                .appointmentTime,
                .before,
                .heading,
                .serviceDuration,
                .sideOfStreet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessHours: return "AccessHours"
            case .appointmentTime: return "AppointmentTime"
            case .before: return "Before"
            case .heading: return "Heading"
            case .serviceDuration: return "ServiceDuration"
            case .sideOfStreet: return "SideOfStreet"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The failed constraint.
    public struct WaypointOptimizationFailedConstraint: Swift.Sendable {
        /// The failed constraint.
        public var constraint: GeoRoutesClientTypes.WaypointOptimizationConstraint?
        /// Reason for the failed constraint.
        public var reason: Swift.String?

        public init(
            constraint: GeoRoutesClientTypes.WaypointOptimizationConstraint? = nil,
            reason: Swift.String? = nil
        )
        {
            self.constraint = constraint
            self.reason = reason
        }
    }
}

extension GeoRoutesClientTypes {

    /// The impeding waypoint.
    public struct WaypointOptimizationImpedingWaypoint: Swift.Sendable {
        /// Failed constraints for an impeding waypoint.
        /// This member is required.
        public var failedConstraints: [GeoRoutesClientTypes.WaypointOptimizationFailedConstraint]?
        /// The resource Id.
        /// This member is required.
        public var id: Swift.String?
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?

        public init(
            failedConstraints: [GeoRoutesClientTypes.WaypointOptimizationFailedConstraint]? = nil,
            id: Swift.String? = nil,
            position: [Swift.Double]? = nil
        )
        {
            self.failedConstraints = failedConstraints
            self.id = id
            self.position = position
        }
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WaypointOptimizationImpedingWaypoint(failedConstraints: \(Swift.String(describing: failedConstraints)), id: \(Swift.String(describing: id)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// The optimized waypoint.
    public struct WaypointOptimizationOptimizedWaypoint: Swift.Sendable {
        /// Time of arrival at the destination. This parameter is returned only if the Destination parameters was provided in the request. Template:YYYY-MM-DDThh:mm:ss.sssZ YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
        ///     2020-04-22T17:57:24+02:00
        public var arrivalTime: Swift.String?
        public var clusterIndex: Swift.Int
        /// Time of departure for Origin. Template:YYYY-MM-DDThh:mm:ss.sssZ YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
        ///     2020-04-22T17:57:24+02:00
        /// This member is required.
        public var departureTime: Swift.String?
        /// The waypoint Id.
        /// This member is required.
        public var id: Swift.String?
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?

        public init(
            arrivalTime: Swift.String? = nil,
            clusterIndex: Swift.Int = 0,
            departureTime: Swift.String? = nil,
            id: Swift.String? = nil,
            position: [Swift.Double]? = nil
        )
        {
            self.arrivalTime = arrivalTime
            self.clusterIndex = clusterIndex
            self.departureTime = departureTime
            self.id = id
            self.position = position
        }
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WaypointOptimizationOptimizedWaypoint(arrivalTime: \(Swift.String(describing: arrivalTime)), clusterIndex: \(Swift.String(describing: clusterIndex)), departureTime: \(Swift.String(describing: departureTime)), id: \(Swift.String(describing: id)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Time breakdown for the sequence.
    public struct WaypointOptimizationTimeBreakdown: Swift.Sendable {
        /// Resting phase of the cycle.
        /// This member is required.
        public var restDuration: Swift.Int
        /// Service time spent at the destination. At an appointment, the service time should be the appointment duration.
        /// This member is required.
        public var serviceDuration: Swift.Int
        /// Traveling phase of the cycle.
        /// This member is required.
        public var travelDuration: Swift.Int
        /// Waiting phase of the cycle.
        /// This member is required.
        public var waitDuration: Swift.Int

        public init(
            restDuration: Swift.Int = 0,
            serviceDuration: Swift.Int = 0,
            travelDuration: Swift.Int = 0,
            waitDuration: Swift.Int = 0
        )
        {
            self.restDuration = restDuration
            self.serviceDuration = serviceDuration
            self.travelDuration = travelDuration
            self.waitDuration = waitDuration
        }
    }
}

public struct OptimizeWaypointsOutput: Swift.Sendable {
    /// Details about the connection from one waypoint to the next, within the optimized sequence.
    /// This member is required.
    public var connections: [GeoRoutesClientTypes.WaypointOptimizationConnection]?
    /// Overall distance to travel the whole sequence.
    /// This member is required.
    public var distance: Swift.Int
    /// Overall duration to travel the whole sequence.
    /// This member is required.
    public var duration: Swift.Int
    /// Returns waypoints that caused the optimization problem to fail, and the constraints that were unsatisfied leading to the failure.
    /// This member is required.
    public var impedingWaypoints: [GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint]?
    /// Waypoints in the order of the optimized sequence.
    /// This member is required.
    public var optimizedWaypoints: [GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint]?
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// Time breakdown for the sequence.
    /// This member is required.
    public var timeBreakdown: GeoRoutesClientTypes.WaypointOptimizationTimeBreakdown?

    public init(
        connections: [GeoRoutesClientTypes.WaypointOptimizationConnection]? = nil,
        distance: Swift.Int = 0,
        duration: Swift.Int = 0,
        impedingWaypoints: [GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint]? = nil,
        optimizedWaypoints: [GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint]? = nil,
        pricingBucket: Swift.String? = nil,
        timeBreakdown: GeoRoutesClientTypes.WaypointOptimizationTimeBreakdown? = nil
    )
    {
        self.connections = connections
        self.distance = distance
        self.duration = duration
        self.impedingWaypoints = impedingWaypoints
        self.optimizedWaypoints = optimizedWaypoints
        self.pricingBucket = pricingBucket
        self.timeBreakdown = timeBreakdown
    }
}

extension GeoRoutesClientTypes {

    /// TracePoint indices for which the provided notice code corresponds to.
    public struct RoadSnapTracePoint: Swift.Sendable {
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Position defined as longitude, latitude.
        /// This member is required.
        public var position: [Swift.Double]?
        /// Speed at the specified trace point in kilometers per hour.
        public var speed: Swift.Double
        public var timestamp: Swift.String?

        public init(
            heading: Swift.Double = 0.0,
            position: [Swift.Double]? = nil,
            speed: Swift.Double = 0.0,
            timestamp: Swift.String? = nil
        )
        {
            self.heading = heading
            self.position = position
            self.speed = speed
            self.timestamp = timestamp
        }
    }
}

extension GeoRoutesClientTypes.RoadSnapTracePoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoadSnapTracePoint(heading: \(Swift.String(describing: heading)), speed: \(Swift.String(describing: speed)), timestamp: \(Swift.String(describing: timestamp)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    public enum RoadSnapTravelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case car
        case pedestrian
        case scooter
        case truck
        case sdkUnknown(Swift.String)

        public static var allCases: [RoadSnapTravelMode] {
            return [
                .car,
                .pedestrian,
                .scooter,
                .truck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .pedestrian: return "Pedestrian"
            case .scooter: return "Scooter"
            case .truck: return "Truck"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RoadSnapHazardousCargoType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case combustible
        case corrosive
        case explosive
        case flammable
        case gas
        case harmfulToWater
        case organic
        case other
        case poison
        case poisonousInhalation
        case radioactive
        case sdkUnknown(Swift.String)

        public static var allCases: [RoadSnapHazardousCargoType] {
            return [
                .combustible,
                .corrosive,
                .explosive,
                .flammable,
                .gas,
                .harmfulToWater,
                .organic,
                .other,
                .poison,
                .poisonousInhalation,
                .radioactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .combustible: return "Combustible"
            case .corrosive: return "Corrosive"
            case .explosive: return "Explosive"
            case .flammable: return "Flammable"
            case .gas: return "Gas"
            case .harmfulToWater: return "HarmfulToWater"
            case .organic: return "Organic"
            case .other: return "Other"
            case .poison: return "Poison"
            case .poisonousInhalation: return "PoisonousInhalation"
            case .radioactive: return "Radioactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public struct RoadSnapTrailerOptions: Swift.Sendable {
        public var trailerCount: Swift.Int?

        public init(
            trailerCount: Swift.Int? = nil
        )
        {
            self.trailerCount = trailerCount
        }
    }
}

extension GeoRoutesClientTypes {

    public struct RoadSnapTruckOptions: Swift.Sendable {
        public var grossWeight: Swift.Int
        public var hazardousCargos: [GeoRoutesClientTypes.RoadSnapHazardousCargoType]?
        public var height: Swift.Int
        public var length: Swift.Int
        public var trailer: GeoRoutesClientTypes.RoadSnapTrailerOptions?
        public var tunnelRestrictionCode: Swift.String?
        public var width: Swift.Int

        public init(
            grossWeight: Swift.Int = 0,
            hazardousCargos: [GeoRoutesClientTypes.RoadSnapHazardousCargoType]? = nil,
            height: Swift.Int = 0,
            length: Swift.Int = 0,
            trailer: GeoRoutesClientTypes.RoadSnapTrailerOptions? = nil,
            tunnelRestrictionCode: Swift.String? = nil,
            width: Swift.Int = 0
        )
        {
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.length = length
            self.trailer = trailer
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.width = width
        }
    }
}

extension GeoRoutesClientTypes {

    public struct RoadSnapTravelModeOptions: Swift.Sendable {
        public var truck: GeoRoutesClientTypes.RoadSnapTruckOptions?

        public init(
            truck: GeoRoutesClientTypes.RoadSnapTruckOptions? = nil
        )
        {
            self.truck = truck
        }
    }
}

public struct SnapToRoadsInput: Swift.Sendable {
    /// Optional: The API key to be used for authorization. Optional, either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// The radius around the provided tracepoint that is considered for snapping. Unit: meters
    public var snapRadius: Swift.Int?
    /// Chooses what the returned SnappedGeometry format should be. Default Value: FlexiblePolyline
    public var snappedGeometryFormat: GeoRoutesClientTypes.GeometryFormat?
    /// List of trace points to be snapped onto the road network.
    /// This member is required.
    public var tracePoints: [GeoRoutesClientTypes.RoadSnapTracePoint]?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value:Car
    public var travelMode: GeoRoutesClientTypes.RoadSnapTravelMode?
    public var travelModeOptions: GeoRoutesClientTypes.RoadSnapTravelModeOptions?

    public init(
        key: Swift.String? = nil,
        snapRadius: Swift.Int? = 0,
        snappedGeometryFormat: GeoRoutesClientTypes.GeometryFormat? = nil,
        tracePoints: [GeoRoutesClientTypes.RoadSnapTracePoint]? = nil,
        travelMode: GeoRoutesClientTypes.RoadSnapTravelMode? = nil,
        travelModeOptions: GeoRoutesClientTypes.RoadSnapTravelModeOptions? = nil
    )
    {
        self.key = key
        self.snapRadius = snapRadius
        self.snappedGeometryFormat = snappedGeometryFormat
        self.tracePoints = tracePoints
        self.travelMode = travelMode
        self.travelModeOptions = travelModeOptions
    }
}

extension SnapToRoadsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapToRoadsInput(snapRadius: \(Swift.String(describing: snapRadius)), snappedGeometryFormat: \(Swift.String(describing: snappedGeometryFormat)), tracePoints: \(Swift.String(describing: tracePoints)), travelMode: \(Swift.String(describing: travelMode)), travelModeOptions: \(Swift.String(describing: travelModeOptions)), key: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    public enum RoadSnapNoticeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tracePointsHeadingIgnored
        case tracePointsIgnored
        case tracePointsMovedByLargeDistance
        case tracePointsNotMatched
        case tracePointsOutOfSequence
        case tracePointsSpeedEstimated
        case tracePointsSpeedIgnored
        case sdkUnknown(Swift.String)

        public static var allCases: [RoadSnapNoticeCode] {
            return [
                .tracePointsHeadingIgnored,
                .tracePointsIgnored,
                .tracePointsMovedByLargeDistance,
                .tracePointsNotMatched,
                .tracePointsOutOfSequence,
                .tracePointsSpeedEstimated,
                .tracePointsSpeedIgnored
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tracePointsHeadingIgnored: return "TracePointsHeadingIgnored"
            case .tracePointsIgnored: return "TracePointsIgnored"
            case .tracePointsMovedByLargeDistance: return "TracePointsMovedByLargeDistance"
            case .tracePointsNotMatched: return "TracePointsNotMatched"
            case .tracePointsOutOfSequence: return "TracePointsOutOfSequence"
            case .tracePointsSpeedEstimated: return "TracePointsSpeedEstimated"
            case .tracePointsSpeedIgnored: return "TracePointsSpeedIgnored"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Notices provide information around factors that may have influenced snapping in a manner atypical to the standard use cases.
    public struct RoadSnapNotice: Swift.Sendable {
        /// Code corresponding to the issue.
        /// This member is required.
        public var code: GeoRoutesClientTypes.RoadSnapNoticeCode?
        /// The notice title.
        /// This member is required.
        public var title: Swift.String?
        /// TracePoint indices for which the provided notice code corresponds to.
        /// This member is required.
        public var tracePointIndexes: [Swift.Int]?

        public init(
            code: GeoRoutesClientTypes.RoadSnapNoticeCode? = nil,
            title: Swift.String? = nil,
            tracePointIndexes: [Swift.Int]? = nil
        )
        {
            self.code = code
            self.title = title
            self.tracePointIndexes = tracePointIndexes
        }
    }
}

extension GeoRoutesClientTypes {

    /// Interpolated geometry for the snapped route that is overlayable onto a map.
    public struct RoadSnapSnappedGeometry: Swift.Sendable {
        /// An ordered list of positions used to plot a route on a map. LineString and Polyline are mutually exclusive properties.
        public var lineString: [[Swift.Double]]?
        /// An ordered list of positions used to plot a route on a map in a lossy compression format. LineString and Polyline are mutually exclusive properties.
        public var polyline: Swift.String?

        public init(
            lineString: [[Swift.Double]]? = nil,
            polyline: Swift.String? = nil
        )
        {
            self.lineString = lineString
            self.polyline = polyline
        }
    }
}

extension GeoRoutesClientTypes.RoadSnapSnappedGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoadSnapSnappedGeometry(lineString: \"CONTENT_REDACTED\", polyline: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// TracePoints snapped onto the road network.
    public struct RoadSnapSnappedTracePoint: Swift.Sendable {
        /// Confidence value for the correctness of this point match.
        /// This member is required.
        public var confidence: Swift.Double?
        /// Position of the TracePoint provided within the request, at the same index.
        /// This member is required.
        public var originalPosition: [Swift.Double]?
        /// Snapped position of the TracePoint provided within the request, at the same index.
        /// This member is required.
        public var snappedPosition: [Swift.Double]?

        public init(
            confidence: Swift.Double? = nil,
            originalPosition: [Swift.Double]? = nil,
            snappedPosition: [Swift.Double]? = nil
        )
        {
            self.confidence = confidence
            self.originalPosition = originalPosition
            self.snappedPosition = snappedPosition
        }
    }
}

extension GeoRoutesClientTypes.RoadSnapSnappedTracePoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoadSnapSnappedTracePoint(confidence: \(Swift.String(describing: confidence)), originalPosition: \"CONTENT_REDACTED\", snappedPosition: \"CONTENT_REDACTED\")"}
}

public struct SnapToRoadsOutput: Swift.Sendable {
    /// Notices are additional information returned that indicate issues that occurred during route calculation.
    /// This member is required.
    public var notices: [GeoRoutesClientTypes.RoadSnapNotice]?
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// The interpolated geometry for the snapped route onto the road network.
    public var snappedGeometry: GeoRoutesClientTypes.RoadSnapSnappedGeometry?
    /// This member is required.
    public var snappedGeometryFormat: GeoRoutesClientTypes.GeometryFormat?
    /// The trace points snapped onto the road network.
    /// This member is required.
    public var snappedTracePoints: [GeoRoutesClientTypes.RoadSnapSnappedTracePoint]?

    public init(
        notices: [GeoRoutesClientTypes.RoadSnapNotice]? = nil,
        pricingBucket: Swift.String? = nil,
        snappedGeometry: GeoRoutesClientTypes.RoadSnapSnappedGeometry? = nil,
        snappedGeometryFormat: GeoRoutesClientTypes.GeometryFormat? = nil,
        snappedTracePoints: [GeoRoutesClientTypes.RoadSnapSnappedTracePoint]? = nil
    )
    {
        self.notices = notices
        self.pricingBucket = pricingBucket
        self.snappedGeometry = snappedGeometry
        self.snappedGeometryFormat = snappedGeometryFormat
        self.snappedTracePoints = snappedTracePoints
    }
}

extension CalculateIsolinesInput {

    static func urlPathProvider(_ value: CalculateIsolinesInput) -> Swift.String? {
        return "/isolines"
    }
}

extension CalculateIsolinesInput {

    static func queryItemProvider(_ value: CalculateIsolinesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension CalculateRouteMatrixInput {

    static func urlPathProvider(_ value: CalculateRouteMatrixInput) -> Swift.String? {
        return "/route-matrix"
    }
}

extension CalculateRouteMatrixInput {

    static func queryItemProvider(_ value: CalculateRouteMatrixInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension CalculateRoutesInput {

    static func urlPathProvider(_ value: CalculateRoutesInput) -> Swift.String? {
        return "/routes"
    }
}

extension CalculateRoutesInput {

    static func queryItemProvider(_ value: CalculateRoutesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension OptimizeWaypointsInput {

    static func urlPathProvider(_ value: OptimizeWaypointsInput) -> Swift.String? {
        return "/optimize-waypoints"
    }
}

extension OptimizeWaypointsInput {

    static func queryItemProvider(_ value: OptimizeWaypointsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SnapToRoadsInput {

    static func urlPathProvider(_ value: SnapToRoadsInput) -> Swift.String? {
        return "/snap-to-roads"
    }
}

extension SnapToRoadsInput {

    static func queryItemProvider(_ value: SnapToRoadsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension CalculateIsolinesInput {

    static func write(value: CalculateIsolinesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Allow"].write(value.allow, with: GeoRoutesClientTypes.IsolineAllowOptions.write(value:to:))
        try writer["ArrivalTime"].write(value.arrivalTime)
        try writer["Avoid"].write(value.avoid, with: GeoRoutesClientTypes.IsolineAvoidanceOptions.write(value:to:))
        try writer["DepartNow"].write(value.departNow)
        try writer["DepartureTime"].write(value.departureTime)
        try writer["Destination"].writeList(value.destination, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DestinationOptions"].write(value.destinationOptions, with: GeoRoutesClientTypes.IsolineDestinationOptions.write(value:to:))
        try writer["IsolineGeometryFormat"].write(value.isolineGeometryFormat)
        try writer["IsolineGranularity"].write(value.isolineGranularity, with: GeoRoutesClientTypes.IsolineGranularityOptions.write(value:to:))
        try writer["OptimizeIsolineFor"].write(value.optimizeIsolineFor)
        try writer["OptimizeRoutingFor"].write(value.optimizeRoutingFor)
        try writer["Origin"].writeList(value.origin, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OriginOptions"].write(value.originOptions, with: GeoRoutesClientTypes.IsolineOriginOptions.write(value:to:))
        try writer["Thresholds"].write(value.thresholds, with: GeoRoutesClientTypes.IsolineThresholds.write(value:to:))
        try writer["Traffic"].write(value.traffic, with: GeoRoutesClientTypes.IsolineTrafficOptions.write(value:to:))
        try writer["TravelMode"].write(value.travelMode)
        try writer["TravelModeOptions"].write(value.travelModeOptions, with: GeoRoutesClientTypes.IsolineTravelModeOptions.write(value:to:))
    }
}

extension CalculateRouteMatrixInput {

    static func write(value: CalculateRouteMatrixInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Allow"].write(value.allow, with: GeoRoutesClientTypes.RouteMatrixAllowOptions.write(value:to:))
        try writer["Avoid"].write(value.avoid, with: GeoRoutesClientTypes.RouteMatrixAvoidanceOptions.write(value:to:))
        try writer["DepartNow"].write(value.departNow)
        try writer["DepartureTime"].write(value.departureTime)
        try writer["Destinations"].writeList(value.destinations, memberWritingClosure: GeoRoutesClientTypes.RouteMatrixDestination.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Exclude"].write(value.exclude, with: GeoRoutesClientTypes.RouteMatrixExclusionOptions.write(value:to:))
        try writer["OptimizeRoutingFor"].write(value.optimizeRoutingFor)
        try writer["Origins"].writeList(value.origins, memberWritingClosure: GeoRoutesClientTypes.RouteMatrixOrigin.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RoutingBoundary"].write(value.routingBoundary, with: GeoRoutesClientTypes.RouteMatrixBoundary.write(value:to:))
        try writer["Traffic"].write(value.traffic, with: GeoRoutesClientTypes.RouteMatrixTrafficOptions.write(value:to:))
        try writer["TravelMode"].write(value.travelMode)
        try writer["TravelModeOptions"].write(value.travelModeOptions, with: GeoRoutesClientTypes.RouteMatrixTravelModeOptions.write(value:to:))
    }
}

extension CalculateRoutesInput {

    static func write(value: CalculateRoutesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Allow"].write(value.allow, with: GeoRoutesClientTypes.RouteAllowOptions.write(value:to:))
        try writer["ArrivalTime"].write(value.arrivalTime)
        try writer["Avoid"].write(value.avoid, with: GeoRoutesClientTypes.RouteAvoidanceOptions.write(value:to:))
        try writer["DepartNow"].write(value.departNow)
        try writer["DepartureTime"].write(value.departureTime)
        try writer["Destination"].writeList(value.destination, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DestinationOptions"].write(value.destinationOptions, with: GeoRoutesClientTypes.RouteDestinationOptions.write(value:to:))
        try writer["Driver"].write(value.driver, with: GeoRoutesClientTypes.RouteDriverOptions.write(value:to:))
        try writer["Exclude"].write(value.exclude, with: GeoRoutesClientTypes.RouteExclusionOptions.write(value:to:))
        try writer["InstructionsMeasurementSystem"].write(value.instructionsMeasurementSystem)
        try writer["Languages"].writeList(value.languages, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LegAdditionalFeatures"].writeList(value.legAdditionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.RouteLegAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LegGeometryFormat"].write(value.legGeometryFormat)
        try writer["MaxAlternatives"].write(value.maxAlternatives)
        try writer["OptimizeRoutingFor"].write(value.optimizeRoutingFor)
        try writer["Origin"].writeList(value.origin, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OriginOptions"].write(value.originOptions, with: GeoRoutesClientTypes.RouteOriginOptions.write(value:to:))
        try writer["SpanAdditionalFeatures"].writeList(value.spanAdditionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.RouteSpanAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tolls"].write(value.tolls, with: GeoRoutesClientTypes.RouteTollOptions.write(value:to:))
        try writer["Traffic"].write(value.traffic, with: GeoRoutesClientTypes.RouteTrafficOptions.write(value:to:))
        try writer["TravelMode"].write(value.travelMode)
        try writer["TravelModeOptions"].write(value.travelModeOptions, with: GeoRoutesClientTypes.RouteTravelModeOptions.write(value:to:))
        try writer["TravelStepType"].write(value.travelStepType)
        try writer["Waypoints"].writeList(value.waypoints, memberWritingClosure: GeoRoutesClientTypes.RouteWaypoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension OptimizeWaypointsInput {

    static func write(value: OptimizeWaypointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Avoid"].write(value.avoid, with: GeoRoutesClientTypes.WaypointOptimizationAvoidanceOptions.write(value:to:))
        try writer["Clustering"].write(value.clustering, with: GeoRoutesClientTypes.WaypointOptimizationClusteringOptions.write(value:to:))
        try writer["DepartureTime"].write(value.departureTime)
        try writer["Destination"].writeList(value.destination, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DestinationOptions"].write(value.destinationOptions, with: GeoRoutesClientTypes.WaypointOptimizationDestinationOptions.write(value:to:))
        try writer["Driver"].write(value.driver, with: GeoRoutesClientTypes.WaypointOptimizationDriverOptions.write(value:to:))
        try writer["Exclude"].write(value.exclude, with: GeoRoutesClientTypes.WaypointOptimizationExclusionOptions.write(value:to:))
        try writer["OptimizeSequencingFor"].write(value.optimizeSequencingFor)
        try writer["Origin"].writeList(value.origin, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OriginOptions"].write(value.originOptions, with: GeoRoutesClientTypes.WaypointOptimizationOriginOptions.write(value:to:))
        try writer["Traffic"].write(value.traffic, with: GeoRoutesClientTypes.WaypointOptimizationTrafficOptions.write(value:to:))
        try writer["TravelMode"].write(value.travelMode)
        try writer["TravelModeOptions"].write(value.travelModeOptions, with: GeoRoutesClientTypes.WaypointOptimizationTravelModeOptions.write(value:to:))
        try writer["Waypoints"].writeList(value.waypoints, memberWritingClosure: GeoRoutesClientTypes.WaypointOptimizationWaypoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SnapToRoadsInput {

    static func write(value: SnapToRoadsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SnapRadius"].write(value.snapRadius)
        try writer["SnappedGeometryFormat"].write(value.snappedGeometryFormat)
        try writer["TracePoints"].writeList(value.tracePoints, memberWritingClosure: GeoRoutesClientTypes.RoadSnapTracePoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TravelMode"].write(value.travelMode)
        try writer["TravelModeOptions"].write(value.travelModeOptions, with: GeoRoutesClientTypes.RoadSnapTravelModeOptions.write(value:to:))
    }
}

extension CalculateIsolinesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CalculateIsolinesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CalculateIsolinesOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.arrivalTime = try reader["ArrivalTime"].readIfPresent()
        value.departureTime = try reader["DepartureTime"].readIfPresent()
        value.isolineGeometryFormat = try reader["IsolineGeometryFormat"].readIfPresent() ?? .sdkUnknown("")
        value.isolines = try reader["Isolines"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.Isoline.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.snappedDestination = try reader["SnappedDestination"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.snappedOrigin = try reader["SnappedOrigin"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CalculateRouteMatrixOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CalculateRouteMatrixOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CalculateRouteMatrixOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.errorCount = try reader["ErrorCount"].readIfPresent() ?? 0
        value.routeMatrix = try reader["RouteMatrix"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: GeoRoutesClientTypes.RouteMatrixEntry.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        value.routingBoundary = try reader["RoutingBoundary"].readIfPresent(with: GeoRoutesClientTypes.RouteMatrixBoundary.read(from:))
        return value
    }
}

extension CalculateRoutesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CalculateRoutesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CalculateRoutesOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.legGeometryFormat = try reader["LegGeometryFormat"].readIfPresent() ?? .sdkUnknown("")
        value.notices = try reader["Notices"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteResponseNotice.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.routes = try reader["Routes"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension OptimizeWaypointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> OptimizeWaypointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = OptimizeWaypointsOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.connections = try reader["Connections"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.WaypointOptimizationConnection.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.impedingWaypoints = try reader["ImpedingWaypoints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.optimizedWaypoints = try reader["OptimizedWaypoints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timeBreakdown = try reader["TimeBreakdown"].readIfPresent(with: GeoRoutesClientTypes.WaypointOptimizationTimeBreakdown.read(from:))
        return value
    }
}

extension SnapToRoadsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SnapToRoadsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SnapToRoadsOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.notices = try reader["Notices"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoadSnapNotice.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.snappedGeometry = try reader["SnappedGeometry"].readIfPresent(with: GeoRoutesClientTypes.RoadSnapSnappedGeometry.read(from:))
        value.snappedGeometryFormat = try reader["SnappedGeometryFormat"].readIfPresent() ?? .sdkUnknown("")
        value.snappedTracePoints = try reader["SnappedTracePoints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoadSnapSnappedTracePoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

enum CalculateIsolinesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CalculateRouteMatrixOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CalculateRoutesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum OptimizeWaypointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SnapToRoadsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GeoRoutesClientTypes.Isoline {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.Isoline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.Isoline()
        value.connections = try reader["Connections"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.IsolineConnection.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.consumptionThreshold = try reader["ConsumptionThreshold"].readIfPresent()
        value.distanceThreshold = try reader["DistanceThreshold"].readIfPresent() ?? 0
        value.geometries = try reader["Geometries"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.IsolineShapeGeometry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timeThreshold = try reader["TimeThreshold"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.IsolineShapeGeometry {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.IsolineShapeGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.IsolineShapeGeometry()
        value.polylinePolygon = try reader["PolylinePolygon"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.polygon = try reader["Polygon"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoRoutesClientTypes.IsolineConnection {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.IsolineConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.IsolineConnection()
        value.geometry = try reader["Geometry"].readIfPresent(with: GeoRoutesClientTypes.IsolineConnectionGeometry.read(from:))
        value.fromPolygonIndex = try reader["FromPolygonIndex"].readIfPresent() ?? 0
        value.toPolygonIndex = try reader["ToPolygonIndex"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.IsolineConnectionGeometry {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.IsolineConnectionGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.IsolineConnectionGeometry()
        value.lineString = try reader["LineString"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.polyline = try reader["Polyline"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteMatrixEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteMatrixEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteMatrixEntry()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.error = try reader["Error"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteMatrixBoundary {

    static func write(value: GeoRoutesClientTypes.RouteMatrixBoundary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Geometry"].write(value.geometry, with: GeoRoutesClientTypes.RouteMatrixBoundaryGeometry.write(value:to:))
        try writer["Unbounded"].write(value.unbounded)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteMatrixBoundary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteMatrixBoundary()
        value.geometry = try reader["Geometry"].readIfPresent(with: GeoRoutesClientTypes.RouteMatrixBoundaryGeometry.read(from:))
        value.unbounded = try reader["Unbounded"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteMatrixBoundaryGeometry {

    static func write(value: GeoRoutesClientTypes.RouteMatrixBoundaryGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoCircle"].write(value.autoCircle, with: GeoRoutesClientTypes.RouteMatrixAutoCircle.write(value:to:))
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Circle"].write(value.circle, with: GeoRoutesClientTypes.Circle.write(value:to:))
        try writer["Polygon"].writeList(value.polygon, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteMatrixBoundaryGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteMatrixBoundaryGeometry()
        value.autoCircle = try reader["AutoCircle"].readIfPresent(with: GeoRoutesClientTypes.RouteMatrixAutoCircle.read(from:))
        value.circle = try reader["Circle"].readIfPresent(with: GeoRoutesClientTypes.Circle.read(from:))
        value.boundingBox = try reader["BoundingBox"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.polygon = try reader["Polygon"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoRoutesClientTypes.Circle {

    static func write(value: GeoRoutesClientTypes.Circle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Center"].writeList(value.center, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Radius"].write(value.radius)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.Circle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.Circle()
        value.center = try reader["Center"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.radius = try reader["Radius"].readIfPresent() ?? 0.0
        return value
    }
}

extension GeoRoutesClientTypes.RouteMatrixAutoCircle {

    static func write(value: GeoRoutesClientTypes.RouteMatrixAutoCircle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Margin"].write(value.margin)
        try writer["MaxRadius"].write(value.maxRadius)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteMatrixAutoCircle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteMatrixAutoCircle()
        value.margin = try reader["Margin"].readIfPresent() ?? 0
        value.maxRadius = try reader["MaxRadius"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteResponseNotice {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteResponseNotice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteResponseNotice()
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        value.impact = try reader["Impact"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.Route {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.Route {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.Route()
        value.legs = try reader["Legs"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteLeg.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.summary = try reader["Summary"].readIfPresent(with: GeoRoutesClientTypes.RouteSummary.read(from:))
        value.majorRoadLabels = try reader["MajorRoadLabels"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteMajorRoadLabel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteMajorRoadLabel {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteMajorRoadLabel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteMajorRoadLabel()
        value.roadName = try reader["RoadName"].readIfPresent(with: GeoRoutesClientTypes.LocalizedString.read(from:))
        value.routeNumber = try reader["RouteNumber"].readIfPresent(with: GeoRoutesClientTypes.RouteNumber.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteNumber {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteNumber {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteNumber()
        value.direction = try reader["Direction"].readIfPresent()
        value.language = try reader["Language"].readIfPresent()
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension GeoRoutesClientTypes.LocalizedString {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.LocalizedString {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.LocalizedString()
        value.language = try reader["Language"].readIfPresent()
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension GeoRoutesClientTypes.RouteSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteSummary()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.tolls = try reader["Tolls"].readIfPresent(with: GeoRoutesClientTypes.RouteTollSummary.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollSummary()
        value.total = try reader["Total"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPriceSummary.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollPriceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollPriceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollPriceSummary()
        value.currency = try reader["Currency"].readIfPresent() ?? ""
        value.estimate = try reader["Estimate"].readIfPresent() ?? false
        value.range = try reader["Range"].readIfPresent() ?? false
        value.rangeValue = try reader["RangeValue"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPriceValueRange.read(from:))
        value.value = try reader["Value"].readIfPresent() ?? 0.0
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollPriceValueRange {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollPriceValueRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollPriceValueRange()
        value.min = try reader["Min"].readIfPresent() ?? 0.0
        value.max = try reader["Max"].readIfPresent() ?? 0.0
        return value
    }
}

extension GeoRoutesClientTypes.RouteLeg {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteLeg {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteLeg()
        value.ferryLegDetails = try reader["FerryLegDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryLegDetails.read(from:))
        value.geometry = try reader["Geometry"].readIfPresent(with: GeoRoutesClientTypes.RouteLegGeometry.read(from:))
        value.language = try reader["Language"].readIfPresent()
        value.pedestrianLegDetails = try reader["PedestrianLegDetails"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianLegDetails.read(from:))
        value.travelMode = try reader["TravelMode"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.vehicleLegDetails = try reader["VehicleLegDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteVehicleLegDetails.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleLegDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleLegDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleLegDetails()
        value.afterTravelSteps = try reader["AfterTravelSteps"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteVehicleAfterTravelStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.arrival = try reader["Arrival"].readIfPresent(with: GeoRoutesClientTypes.RouteVehicleArrival.read(from:))
        value.departure = try reader["Departure"].readIfPresent(with: GeoRoutesClientTypes.RouteVehicleDeparture.read(from:))
        value.incidents = try reader["Incidents"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteVehicleIncident.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.notices = try reader["Notices"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteVehicleNotice.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.passThroughWaypoints = try reader["PassThroughWaypoints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePassThroughWaypoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.spans = try reader["Spans"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteVehicleSpan.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.summary = try reader["Summary"].readIfPresent(with: GeoRoutesClientTypes.RouteVehicleSummary.read(from:))
        value.tolls = try reader["Tolls"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteToll.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tollSystems = try reader["TollSystems"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteTollSystem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.travelSteps = try reader["TravelSteps"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteVehicleTravelStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.truckRoadTypes = try reader["TruckRoadTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.zones = try reader["Zones"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteZone.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteZone {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteZone {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteZone()
        value.name = try reader["Name"].readIfPresent()
        value.category = try reader["Category"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleTravelStep {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleTravelStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleTravelStep()
        value.continueHighwayStepDetails = try reader["ContinueHighwayStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteContinueHighwayStepDetails.read(from:))
        value.continueStepDetails = try reader["ContinueStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteContinueStepDetails.read(from:))
        value.currentRoad = try reader["CurrentRoad"].readIfPresent(with: GeoRoutesClientTypes.RouteRoad.read(from:))
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.enterHighwayStepDetails = try reader["EnterHighwayStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteEnterHighwayStepDetails.read(from:))
        value.exitNumber = try reader["ExitNumber"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.exitStepDetails = try reader["ExitStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteExitStepDetails.read(from:))
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.instruction = try reader["Instruction"].readIfPresent()
        value.keepStepDetails = try reader["KeepStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteKeepStepDetails.read(from:))
        value.nextRoad = try reader["NextRoad"].readIfPresent(with: GeoRoutesClientTypes.RouteRoad.read(from:))
        value.rampStepDetails = try reader["RampStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRampStepDetails.read(from:))
        value.roundaboutEnterStepDetails = try reader["RoundaboutEnterStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails.read(from:))
        value.roundaboutExitStepDetails = try reader["RoundaboutExitStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRoundaboutExitStepDetails.read(from:))
        value.roundaboutPassStepDetails = try reader["RoundaboutPassStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRoundaboutPassStepDetails.read(from:))
        value.signpost = try reader["Signpost"].readIfPresent(with: GeoRoutesClientTypes.RouteSignpost.read(from:))
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.turnStepDetails = try reader["TurnStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteTurnStepDetails.read(from:))
        value.uTurnStepDetails = try reader["UTurnStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteUTurnStepDetails.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteUTurnStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteUTurnStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteUTurnStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteTurnStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTurnStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTurnStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteSignpost {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteSignpost {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteSignpost()
        value.labels = try reader["Labels"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteSignpostLabel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteSignpostLabel {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteSignpostLabel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteSignpostLabel()
        value.routeNumber = try reader["RouteNumber"].readIfPresent(with: GeoRoutesClientTypes.RouteNumber.read(from:))
        value.text = try reader["Text"].readIfPresent(with: GeoRoutesClientTypes.LocalizedString.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteRoundaboutPassStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteRoundaboutPassStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteRoundaboutPassStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteRoundaboutExitStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteRoundaboutExitStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteRoundaboutExitStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.relativeExit = try reader["RelativeExit"].readIfPresent()
        value.roundaboutAngle = try reader["RoundaboutAngle"].readIfPresent() ?? 0
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteRampStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteRampStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteRampStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteRoad {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteRoad {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteRoad()
        value.roadName = try reader["RoadName"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.routeNumber = try reader["RouteNumber"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteNumber.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.towards = try reader["Towards"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteKeepStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteKeepStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteKeepStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteExitStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteExitStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteExitStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.relativeExit = try reader["RelativeExit"].readIfPresent()
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteEnterHighwayStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteEnterHighwayStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteEnterHighwayStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteContinueStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteContinueStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteContinueStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteContinueHighwayStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteContinueHighwayStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteContinueHighwayStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollSystem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollSystem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollSystem()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteToll {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteToll {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteToll()
        value.country = try reader["Country"].readIfPresent()
        value.paymentSites = try reader["PaymentSites"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteTollPaymentSite.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.rates = try reader["Rates"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteTollRate.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.systems = try reader["Systems"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollRate {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollRate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollRate()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.localPrice = try reader["LocalPrice"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPrice.read(from:))
        value.convertedPrice = try reader["ConvertedPrice"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPrice.read(from:))
        value.paymentMethods = try reader["PaymentMethods"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteTollPaymentMethod>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.pass = try reader["Pass"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPass.read(from:))
        value.applicableTimes = try reader["ApplicableTimes"].readIfPresent()
        value.transponders = try reader["Transponders"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteTransponder.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteTransponder {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTransponder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTransponder()
        value.systemName = try reader["SystemName"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollPass {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollPass {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollPass()
        value.includesReturnTrip = try reader["IncludesReturnTrip"].readIfPresent()
        value.validityPeriod = try reader["ValidityPeriod"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPassValidityPeriod.read(from:))
        value.tripCount = try reader["TripCount"].readIfPresent()
        value.transferCount = try reader["TransferCount"].readIfPresent()
        value.seniorPass = try reader["SeniorPass"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollPassValidityPeriod {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollPassValidityPeriod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollPassValidityPeriod()
        value.period = try reader["Period"].readIfPresent() ?? .sdkUnknown("")
        value.periodCount = try reader["PeriodCount"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollPrice {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollPrice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollPrice()
        value.estimate = try reader["Estimate"].readIfPresent() ?? false
        value.currency = try reader["Currency"].readIfPresent() ?? ""
        value.perDuration = try reader["PerDuration"].readIfPresent() ?? 0
        value.value = try reader["Value"].readIfPresent() ?? 0.0
        value.range = try reader["Range"].readIfPresent() ?? false
        value.rangeValue = try reader["RangeValue"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPriceValueRange.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollPaymentSite {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollPaymentSite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollPaymentSite()
        value.name = try reader["Name"].readIfPresent()
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleSummary()
        value.overview = try reader["Overview"].readIfPresent(with: GeoRoutesClientTypes.RouteVehicleOverviewSummary.read(from:))
        value.travelOnly = try reader["TravelOnly"].readIfPresent(with: GeoRoutesClientTypes.RouteVehicleTravelOnlySummary.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleTravelOnlySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleTravelOnlySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleTravelOnlySummary()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.bestCaseDuration = try reader["BestCaseDuration"].readIfPresent() ?? 0
        value.typicalDuration = try reader["TypicalDuration"].readIfPresent() ?? 0
        value.consumption = try reader["Consumption"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleOverviewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleOverviewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleOverviewSummary()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.bestCaseDuration = try reader["BestCaseDuration"].readIfPresent() ?? 0
        value.typicalDuration = try reader["TypicalDuration"].readIfPresent() ?? 0
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.consumption = try reader["Consumption"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleSpan {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleSpan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleSpan()
        value.bestCaseDuration = try reader["BestCaseDuration"].readIfPresent() ?? 0
        value.carAccess = try reader["CarAccess"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteSpanCarAccessAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.consumption = try reader["Consumption"].readIfPresent()
        value.country = try reader["Country"].readIfPresent()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.dynamicSpeed = try reader["DynamicSpeed"].readIfPresent(with: GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails.read(from:))
        value.functionalClassification = try reader["FunctionalClassification"].readIfPresent()
        value.gate = try reader["Gate"].readIfPresent()
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.incidents = try reader["Incidents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.notices = try reader["Notices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.railwayCrossing = try reader["RailwayCrossing"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.roadAttributes = try reader["RoadAttributes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteSpanRoadAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.routeNumbers = try reader["RouteNumbers"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteNumber.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scooterAccess = try reader["ScooterAccess"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteSpanScooterAccessAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.speedLimit = try reader["SpeedLimit"].readIfPresent(with: GeoRoutesClientTypes.RouteSpanSpeedLimitDetails.read(from:))
        value.tollSystems = try reader["TollSystems"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.truckAccess = try reader["TruckAccess"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteSpanTruckAccessAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.truckRoadTypes = try reader["TruckRoadTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.typicalDuration = try reader["TypicalDuration"].readIfPresent() ?? 0
        value.zones = try reader["Zones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoRoutesClientTypes.RouteSpanSpeedLimitDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteSpanSpeedLimitDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteSpanSpeedLimitDetails()
        value.maxSpeed = try reader["MaxSpeed"].readIfPresent() ?? 0
        value.unlimited = try reader["Unlimited"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails()
        value.bestCaseSpeed = try reader["BestCaseSpeed"].readIfPresent() ?? 0
        value.typicalSpeed = try reader["TypicalSpeed"].readIfPresent() ?? 0
        value.turnDuration = try reader["TurnDuration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RoutePassThroughWaypoint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePassThroughWaypoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePassThroughWaypoint()
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RoutePassThroughPlace.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RoutePassThroughPlace {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePassThroughPlace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePassThroughPlace()
        value.originalPosition = try reader["OriginalPosition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.waypointIndex = try reader["WaypointIndex"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleNotice {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleNotice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleNotice()
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        value.details = try reader["Details"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteVehicleNoticeDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.impact = try reader["Impact"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleNoticeDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleNoticeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleNoticeDetail()
        value.title = try reader["Title"].readIfPresent()
        value.violatedConstraints = try reader["ViolatedConstraints"].readIfPresent(with: GeoRoutesClientTypes.RouteViolatedConstraints.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteViolatedConstraints {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteViolatedConstraints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteViolatedConstraints()
        value.allHazardsRestricted = try reader["AllHazardsRestricted"].readIfPresent()
        value.hazardousCargos = try reader["HazardousCargos"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteHazardousCargoType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.maxWeight = try reader["MaxWeight"].readIfPresent(with: GeoRoutesClientTypes.RouteWeightConstraint.read(from:))
        value.maxWeightPerAxle = try reader["MaxWeightPerAxle"].readIfPresent() ?? 0
        value.maxWeightPerAxleGroup = try reader["MaxWeightPerAxleGroup"].readIfPresent(with: GeoRoutesClientTypes.WeightPerAxleGroup.read(from:))
        value.maxHeight = try reader["MaxHeight"].readIfPresent() ?? 0
        value.maxWidth = try reader["MaxWidth"].readIfPresent() ?? 0
        value.maxLength = try reader["MaxLength"].readIfPresent() ?? 0
        value.axleCount = try reader["AxleCount"].readIfPresent(with: GeoRoutesClientTypes.RouteNoticeDetailRange.read(from:))
        value.tunnelRestrictionCode = try reader["TunnelRestrictionCode"].readIfPresent()
        value.timeDependent = try reader["TimeDependent"].readIfPresent()
        value.truckType = try reader["TruckType"].readIfPresent()
        value.trailerCount = try reader["TrailerCount"].readIfPresent(with: GeoRoutesClientTypes.RouteNoticeDetailRange.read(from:))
        value.occupancy = try reader["Occupancy"].readIfPresent(with: GeoRoutesClientTypes.RouteNoticeDetailRange.read(from:))
        value.restrictedTimes = try reader["RestrictedTimes"].readIfPresent()
        value.maxKpraLength = try reader["MaxKpraLength"].readIfPresent() ?? 0
        value.maxPayloadCapacity = try reader["MaxPayloadCapacity"].readIfPresent() ?? 0
        value.openingHours = try reader["OpeningHours"].readIfPresent()
        value.truckRoadType = try reader["TruckRoadType"].readIfPresent()
        value.travelMode = try reader["TravelMode"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteNoticeDetailRange {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteNoticeDetailRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteNoticeDetailRange()
        value.min = try reader["Min"].readIfPresent()
        value.max = try reader["Max"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.WeightPerAxleGroup {

    static func write(value: GeoRoutesClientTypes.WeightPerAxleGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Quad"].write(value.quad)
        try writer["Quint"].write(value.quint)
        try writer["Single"].write(value.single)
        try writer["Tandem"].write(value.tandem)
        try writer["Triple"].write(value.triple)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.WeightPerAxleGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.WeightPerAxleGroup()
        value.single = try reader["Single"].readIfPresent() ?? 0
        value.tandem = try reader["Tandem"].readIfPresent() ?? 0
        value.triple = try reader["Triple"].readIfPresent() ?? 0
        value.quad = try reader["Quad"].readIfPresent() ?? 0
        value.quint = try reader["Quint"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteWeightConstraint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteWeightConstraint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteWeightConstraint()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["Value"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleIncident {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleIncident {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleIncident()
        value.description = try reader["Description"].readIfPresent()
        value.endTime = try reader["EndTime"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.startTime = try reader["StartTime"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleDeparture {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleDeparture {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleDeparture()
        value.charge = try reader["Charge"].readIfPresent() ?? 0
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RouteVehiclePlace.read(from:))
        value.time = try reader["Time"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehiclePlace {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehiclePlace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehiclePlace()
        value.name = try reader["Name"].readIfPresent()
        value.originalPosition = try reader["OriginalPosition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.sideOfStreet = try reader["SideOfStreet"].readIfPresent()
        value.waypointIndex = try reader["WaypointIndex"].readIfPresent()
        value.chargingStation = try reader["ChargingStation"].readIfPresent()
        value.chargingStationDetails = try reader["ChargingStationDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteChargingStationDetails.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteChargingStationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteChargingStationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteChargingStationDetails()
        value.brand = try reader["Brand"].readIfPresent(with: GeoRoutesClientTypes.RouteChargingStationBrand.read(from:))
        value.chargePointOperator = try reader["ChargePointOperator"].readIfPresent(with: GeoRoutesClientTypes.RouteChargePointOperator.read(from:))
        value.connector = try reader["Connector"].readIfPresent(with: GeoRoutesClientTypes.RouteChargingConnector.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteChargingConnector {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteChargingConnector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteChargingConnector()
        value.power = try reader["Power"].readIfPresent() ?? 0
        value.current = try reader["Current"].readIfPresent() ?? 0
        value.voltage = try reader["Voltage"].readIfPresent() ?? 0
        value.supplyType = try reader["SupplyType"].readIfPresent() ?? .sdkUnknown("")
        value.connectorType = try reader["ConnectorType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GeoRoutesClientTypes.RouteChargePointOperator {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteChargePointOperator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteChargePointOperator()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteChargingStationBrand {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteChargingStationBrand {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteChargingStationBrand()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleArrival {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleArrival {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleArrival()
        value.charge = try reader["Charge"].readIfPresent() ?? 0
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RouteVehiclePlace.read(from:))
        value.time = try reader["Time"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleAfterTravelStep {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleAfterTravelStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleAfterTravelStep()
        value.chargeStepDetails = try reader["ChargeStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteChargeStepDetails.read(from:))
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.instruction = try reader["Instruction"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GeoRoutesClientTypes.RouteChargeStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteChargeStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteChargeStepDetails()
        value.arrivalCharge = try reader["ArrivalCharge"].readIfPresent() ?? 0
        value.consumablePower = try reader["ConsumablePower"].readIfPresent() ?? 0
        value.desiredCharge = try reader["DesiredCharge"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianLegDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianLegDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianLegDetails()
        value.afterTravelSteps = try reader["AfterTravelSteps"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePedestrianAfterTravelStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.arrival = try reader["Arrival"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianArrival.read(from:))
        value.departure = try reader["Departure"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianDeparture.read(from:))
        value.notices = try reader["Notices"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePedestrianNotice.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.passThroughWaypoints = try reader["PassThroughWaypoints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePassThroughWaypoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.summary = try reader["Summary"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianSummary.read(from:))
        value.travelSteps = try reader["TravelSteps"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePedestrianTravelStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.spans = try reader["Spans"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePedestrianSpan.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianSpan {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianSpan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianSpan()
        value.bestCaseDuration = try reader["BestCaseDuration"].readIfPresent() ?? 0
        value.country = try reader["Country"].readIfPresent()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.dynamicSpeed = try reader["DynamicSpeed"].readIfPresent(with: GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails.read(from:))
        value.functionalClassification = try reader["FunctionalClassification"].readIfPresent()
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.incidents = try reader["Incidents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.pedestrianAccess = try reader["PedestrianAccess"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteSpanPedestrianAccessAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.region = try reader["Region"].readIfPresent()
        value.roadAttributes = try reader["RoadAttributes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteSpanRoadAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.routeNumbers = try reader["RouteNumbers"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteNumber.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.speedLimit = try reader["SpeedLimit"].readIfPresent(with: GeoRoutesClientTypes.RouteSpanSpeedLimitDetails.read(from:))
        value.typicalDuration = try reader["TypicalDuration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianTravelStep {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianTravelStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianTravelStep()
        value.continueStepDetails = try reader["ContinueStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteContinueStepDetails.read(from:))
        value.currentRoad = try reader["CurrentRoad"].readIfPresent(with: GeoRoutesClientTypes.RouteRoad.read(from:))
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.exitNumber = try reader["ExitNumber"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.exitStepDetails = try reader["ExitStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteExitStepDetails.read(from:))
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.instruction = try reader["Instruction"].readIfPresent()
        value.keepStepDetails = try reader["KeepStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteKeepStepDetails.read(from:))
        value.nextRoad = try reader["NextRoad"].readIfPresent(with: GeoRoutesClientTypes.RouteRoad.read(from:))
        value.rampStepDetails = try reader["RampStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRampStepDetails.read(from:))
        value.roundaboutEnterStepDetails = try reader["RoundaboutEnterStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails.read(from:))
        value.roundaboutExitStepDetails = try reader["RoundaboutExitStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRoundaboutExitStepDetails.read(from:))
        value.roundaboutPassStepDetails = try reader["RoundaboutPassStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRoundaboutPassStepDetails.read(from:))
        value.signpost = try reader["Signpost"].readIfPresent(with: GeoRoutesClientTypes.RouteSignpost.read(from:))
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.turnStepDetails = try reader["TurnStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteTurnStepDetails.read(from:))
        value.uTurnStepDetails = try reader["UTurnStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteUTurnStepDetails.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianSummary()
        value.overview = try reader["Overview"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianOverviewSummary.read(from:))
        value.travelOnly = try reader["TravelOnly"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianTravelOnlySummary.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianTravelOnlySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianTravelOnlySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianTravelOnlySummary()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianOverviewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianOverviewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianOverviewSummary()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianNotice {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianNotice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianNotice()
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        value.impact = try reader["Impact"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianDeparture {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianDeparture {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianDeparture()
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianPlace.read(from:))
        value.time = try reader["Time"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianPlace {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianPlace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianPlace()
        value.name = try reader["Name"].readIfPresent()
        value.originalPosition = try reader["OriginalPosition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.sideOfStreet = try reader["SideOfStreet"].readIfPresent()
        value.waypointIndex = try reader["WaypointIndex"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianArrival {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianArrival {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianArrival()
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianPlace.read(from:))
        value.time = try reader["Time"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianAfterTravelStep {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianAfterTravelStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianAfterTravelStep()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.instruction = try reader["Instruction"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GeoRoutesClientTypes.RouteLegGeometry {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteLegGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteLegGeometry()
        value.lineString = try reader["LineString"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.polyline = try reader["Polyline"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryLegDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryLegDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryLegDetails()
        value.afterTravelSteps = try reader["AfterTravelSteps"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteFerryAfterTravelStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.arrival = try reader["Arrival"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryArrival.read(from:))
        value.departure = try reader["Departure"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryDeparture.read(from:))
        value.notices = try reader["Notices"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteFerryNotice.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.passThroughWaypoints = try reader["PassThroughWaypoints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePassThroughWaypoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.beforeTravelSteps = try reader["BeforeTravelSteps"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteFerryBeforeTravelStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.travelSteps = try reader["TravelSteps"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteFerryTravelStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.summary = try reader["Summary"].readIfPresent(with: GeoRoutesClientTypes.RouteFerrySummary.read(from:))
        value.routeName = try reader["RouteName"].readIfPresent()
        value.spans = try reader["Spans"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteFerrySpan.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerrySpan {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerrySpan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerrySpan()
        value.country = try reader["Country"].readIfPresent()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerrySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerrySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerrySummary()
        value.overview = try reader["Overview"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryOverviewSummary.read(from:))
        value.travelOnly = try reader["TravelOnly"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryTravelOnlySummary.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryTravelOnlySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryTravelOnlySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryTravelOnlySummary()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryOverviewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryOverviewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryOverviewSummary()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryTravelStep {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryTravelStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryTravelStep()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.instruction = try reader["Instruction"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryBeforeTravelStep {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryBeforeTravelStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryBeforeTravelStep()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.instruction = try reader["Instruction"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryNotice {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryNotice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryNotice()
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        value.impact = try reader["Impact"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryDeparture {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryDeparture {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryDeparture()
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryPlace.read(from:))
        value.time = try reader["Time"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryPlace {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryPlace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryPlace()
        value.name = try reader["Name"].readIfPresent()
        value.originalPosition = try reader["OriginalPosition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.waypointIndex = try reader["WaypointIndex"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryArrival {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryArrival {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryArrival()
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryPlace.read(from:))
        value.time = try reader["Time"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryAfterTravelStep {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryAfterTravelStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryAfterTravelStep()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.instruction = try reader["Instruction"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationConnection {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.WaypointOptimizationConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.WaypointOptimizationConnection()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.from = try reader["From"].readIfPresent() ?? ""
        value.restDuration = try reader["RestDuration"].readIfPresent() ?? 0
        value.to = try reader["To"].readIfPresent() ?? ""
        value.travelDuration = try reader["TravelDuration"].readIfPresent() ?? 0
        value.waitDuration = try reader["WaitDuration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint()
        value.failedConstraints = try reader["FailedConstraints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.WaypointOptimizationFailedConstraint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationFailedConstraint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.WaypointOptimizationFailedConstraint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.WaypointOptimizationFailedConstraint()
        value.constraint = try reader["Constraint"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint()
        value.arrivalTime = try reader["ArrivalTime"].readIfPresent()
        value.clusterIndex = try reader["ClusterIndex"].readIfPresent() ?? 0
        value.departureTime = try reader["DepartureTime"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationTimeBreakdown {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.WaypointOptimizationTimeBreakdown {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.WaypointOptimizationTimeBreakdown()
        value.restDuration = try reader["RestDuration"].readIfPresent() ?? 0
        value.serviceDuration = try reader["ServiceDuration"].readIfPresent() ?? 0
        value.travelDuration = try reader["TravelDuration"].readIfPresent() ?? 0
        value.waitDuration = try reader["WaitDuration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RoadSnapNotice {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoadSnapNotice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoadSnapNotice()
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.tracePointIndexes = try reader["TracePointIndexes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RoadSnapSnappedGeometry {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoadSnapSnappedGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoadSnapSnappedGeometry()
        value.lineString = try reader["LineString"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.polyline = try reader["Polyline"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RoadSnapSnappedTracePoint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoadSnapSnappedTracePoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoadSnapSnappedTracePoint()
        value.confidence = try reader["Confidence"].readIfPresent() ?? 0.0
        value.originalPosition = try reader["OriginalPosition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.snappedPosition = try reader["SnappedPosition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension GeoRoutesClientTypes.IsolineAllowOptions {

    static func write(value: GeoRoutesClientTypes.IsolineAllowOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hot"].write(value.hot)
        try writer["Hov"].write(value.hov)
    }
}

extension GeoRoutesClientTypes.IsolineAvoidanceOptions {

    static func write(value: GeoRoutesClientTypes.IsolineAvoidanceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Areas"].writeList(value.areas, memberWritingClosure: GeoRoutesClientTypes.IsolineAvoidanceArea.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CarShuttleTrains"].write(value.carShuttleTrains)
        try writer["ControlledAccessHighways"].write(value.controlledAccessHighways)
        try writer["DirtRoads"].write(value.dirtRoads)
        try writer["Ferries"].write(value.ferries)
        try writer["SeasonalClosure"].write(value.seasonalClosure)
        try writer["TollRoads"].write(value.tollRoads)
        try writer["TollTransponders"].write(value.tollTransponders)
        try writer["TruckRoadTypes"].writeList(value.truckRoadTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tunnels"].write(value.tunnels)
        try writer["UTurns"].write(value.uTurns)
        try writer["ZoneCategories"].writeList(value.zoneCategories, memberWritingClosure: GeoRoutesClientTypes.IsolineAvoidanceZoneCategory.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.IsolineAvoidanceZoneCategory {

    static func write(value: GeoRoutesClientTypes.IsolineAvoidanceZoneCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category)
    }
}

extension GeoRoutesClientTypes.IsolineAvoidanceArea {

    static func write(value: GeoRoutesClientTypes.IsolineAvoidanceArea?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Except"].writeList(value.except, memberWritingClosure: GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Geometry"].write(value.geometry, with: GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry.write(value:to:))
    }
}

extension GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry {

    static func write(value: GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Corridor"].write(value.corridor, with: GeoRoutesClientTypes.Corridor.write(value:to:))
        try writer["Polygon"].writeList(value.polygon, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["PolylineCorridor"].write(value.polylineCorridor, with: GeoRoutesClientTypes.PolylineCorridor.write(value:to:))
        try writer["PolylinePolygon"].writeList(value.polylinePolygon, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.PolylineCorridor {

    static func write(value: GeoRoutesClientTypes.PolylineCorridor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Polyline"].write(value.polyline)
        try writer["Radius"].write(value.radius)
    }
}

extension GeoRoutesClientTypes.Corridor {

    static func write(value: GeoRoutesClientTypes.Corridor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LineString"].writeList(value.lineString, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Radius"].write(value.radius)
    }
}

extension GeoRoutesClientTypes.IsolineDestinationOptions {

    static func write(value: GeoRoutesClientTypes.IsolineDestinationOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.IsolineMatchingOptions.write(value:to:))
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.IsolineSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.IsolineSideOfStreetOptions {

    static func write(value: GeoRoutesClientTypes.IsolineSideOfStreetOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UseWith"].write(value.useWith)
    }
}

extension GeoRoutesClientTypes.IsolineMatchingOptions {

    static func write(value: GeoRoutesClientTypes.IsolineMatchingOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NameHint"].write(value.nameHint)
        try writer["OnRoadThreshold"].write(value.onRoadThreshold)
        try writer["Radius"].write(value.radius)
        try writer["Strategy"].write(value.strategy)
    }
}

extension GeoRoutesClientTypes.IsolineGranularityOptions {

    static func write(value: GeoRoutesClientTypes.IsolineGranularityOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxPoints"].write(value.maxPoints)
        try writer["MaxResolution"].write(value.maxResolution)
    }
}

extension GeoRoutesClientTypes.IsolineOriginOptions {

    static func write(value: GeoRoutesClientTypes.IsolineOriginOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.IsolineMatchingOptions.write(value:to:))
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.IsolineSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.IsolineThresholds {

    static func write(value: GeoRoutesClientTypes.IsolineThresholds?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Consumption"].writeList(value.consumption, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Distance"].writeList(value.distance, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Time"].writeList(value.time, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.IsolineTrafficOptions {

    static func write(value: GeoRoutesClientTypes.IsolineTrafficOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FlowEventThresholdOverride"].write(value.flowEventThresholdOverride)
        try writer["Usage"].write(value.usage)
    }
}

extension GeoRoutesClientTypes.IsolineTravelModeOptions {

    static func write(value: GeoRoutesClientTypes.IsolineTravelModeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Car"].write(value.car, with: GeoRoutesClientTypes.IsolineCarOptions.write(value:to:))
        try writer["Ev"].write(value.ev, with: GeoRoutesClientTypes.IsolineEvOptions.write(value:to:))
        try writer["Scooter"].write(value.scooter, with: GeoRoutesClientTypes.IsolineScooterOptions.write(value:to:))
        try writer["Truck"].write(value.truck, with: GeoRoutesClientTypes.IsolineTruckOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.IsolineTruckOptions {

    static func write(value: GeoRoutesClientTypes.IsolineTruckOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxleCount"].write(value.axleCount)
        try writer["EngineType"].write(value.engineType)
        try writer["GrossWeight"].write(value.grossWeight)
        try writer["HazardousCargos"].writeList(value.hazardousCargos, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.IsolineHazardousCargoType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Height"].write(value.height)
        try writer["HeightAboveFirstAxle"].write(value.heightAboveFirstAxle)
        try writer["KpraLength"].write(value.kpraLength)
        try writer["Length"].write(value.length)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.IsolineVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
        try writer["PayloadCapacity"].write(value.payloadCapacity)
        try writer["TireCount"].write(value.tireCount)
        try writer["Trailer"].write(value.trailer, with: GeoRoutesClientTypes.IsolineTrailerOptions.write(value:to:))
        try writer["TruckType"].write(value.truckType)
        try writer["TunnelRestrictionCode"].write(value.tunnelRestrictionCode)
        try writer["WeightPerAxle"].write(value.weightPerAxle)
        try writer["WeightPerAxleGroup"].write(value.weightPerAxleGroup, with: GeoRoutesClientTypes.WeightPerAxleGroup.write(value:to:))
        try writer["Width"].write(value.width)
    }
}

extension GeoRoutesClientTypes.IsolineTrailerOptions {

    static func write(value: GeoRoutesClientTypes.IsolineTrailerOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxleCount"].write(value.axleCount)
        try writer["TrailerCount"].write(value.trailerCount)
    }
}

extension GeoRoutesClientTypes.IsolineVehicleLicensePlate {

    static func write(value: GeoRoutesClientTypes.IsolineVehicleLicensePlate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LastCharacter"].write(value.lastCharacter)
    }
}

extension GeoRoutesClientTypes.IsolineScooterOptions {

    static func write(value: GeoRoutesClientTypes.IsolineScooterOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineType"].write(value.engineType)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.IsolineVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
    }
}

extension GeoRoutesClientTypes.IsolineEvOptions {

    static func write(value: GeoRoutesClientTypes.IsolineEvOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuxiliaryConsumptionRate"].write(value.auxiliaryConsumptionRate)
        try writer["ConsumptionRateOnAscent"].write(value.consumptionRateOnAscent)
        try writer["ConsumptionRateOnDescent"].write(value.consumptionRateOnDescent)
        try writer["FreeFlowConsumptionCurve"].writeList(value.freeFlowConsumptionCurve, memberWritingClosure: GeoRoutesClientTypes.IsolineConsumptionRateAtSpeed.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TrafficConsumptionCurve"].writeList(value.trafficConsumptionCurve, memberWritingClosure: GeoRoutesClientTypes.IsolineConsumptionRateAtSpeed.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.IsolineConsumptionRateAtSpeed {

    static func write(value: GeoRoutesClientTypes.IsolineConsumptionRateAtSpeed?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConsumptionRate"].write(value.consumptionRate)
        try writer["Speed"].write(value.speed)
    }
}

extension GeoRoutesClientTypes.IsolineCarOptions {

    static func write(value: GeoRoutesClientTypes.IsolineCarOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineType"].write(value.engineType)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.IsolineVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
    }
}

extension GeoRoutesClientTypes.RouteMatrixAllowOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixAllowOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hot"].write(value.hot)
        try writer["Hov"].write(value.hov)
    }
}

extension GeoRoutesClientTypes.RouteMatrixAvoidanceOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixAvoidanceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Areas"].writeList(value.areas, memberWritingClosure: GeoRoutesClientTypes.RouteMatrixAvoidanceArea.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CarShuttleTrains"].write(value.carShuttleTrains)
        try writer["ControlledAccessHighways"].write(value.controlledAccessHighways)
        try writer["DirtRoads"].write(value.dirtRoads)
        try writer["Ferries"].write(value.ferries)
        try writer["TollRoads"].write(value.tollRoads)
        try writer["TollTransponders"].write(value.tollTransponders)
        try writer["TruckRoadTypes"].writeList(value.truckRoadTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tunnels"].write(value.tunnels)
        try writer["UTurns"].write(value.uTurns)
        try writer["ZoneCategories"].writeList(value.zoneCategories, memberWritingClosure: GeoRoutesClientTypes.RouteMatrixAvoidanceZoneCategory.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteMatrixAvoidanceZoneCategory {

    static func write(value: GeoRoutesClientTypes.RouteMatrixAvoidanceZoneCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category)
    }
}

extension GeoRoutesClientTypes.RouteMatrixAvoidanceArea {

    static func write(value: GeoRoutesClientTypes.RouteMatrixAvoidanceArea?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Geometry"].write(value.geometry, with: GeoRoutesClientTypes.RouteMatrixAvoidanceAreaGeometry.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteMatrixAvoidanceAreaGeometry {

    static func write(value: GeoRoutesClientTypes.RouteMatrixAvoidanceAreaGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Polygon"].writeList(value.polygon, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["PolylinePolygon"].writeList(value.polylinePolygon, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteMatrixDestination {

    static func write(value: GeoRoutesClientTypes.RouteMatrixDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Options"].write(value.options, with: GeoRoutesClientTypes.RouteMatrixDestinationOptions.write(value:to:))
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteMatrixDestinationOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixDestinationOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.RouteMatrixMatchingOptions.write(value:to:))
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UseWith"].write(value.useWith)
    }
}

extension GeoRoutesClientTypes.RouteMatrixMatchingOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixMatchingOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NameHint"].write(value.nameHint)
        try writer["OnRoadThreshold"].write(value.onRoadThreshold)
        try writer["Radius"].write(value.radius)
        try writer["Strategy"].write(value.strategy)
    }
}

extension GeoRoutesClientTypes.RouteMatrixExclusionOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixExclusionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Countries"].writeList(value.countries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteMatrixOrigin {

    static func write(value: GeoRoutesClientTypes.RouteMatrixOrigin?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Options"].write(value.options, with: GeoRoutesClientTypes.RouteMatrixOriginOptions.write(value:to:))
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteMatrixOriginOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixOriginOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.RouteMatrixMatchingOptions.write(value:to:))
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteMatrixTrafficOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixTrafficOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FlowEventThresholdOverride"].write(value.flowEventThresholdOverride)
        try writer["Usage"].write(value.usage)
    }
}

extension GeoRoutesClientTypes.RouteMatrixTravelModeOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixTravelModeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Car"].write(value.car, with: GeoRoutesClientTypes.RouteMatrixCarOptions.write(value:to:))
        try writer["Scooter"].write(value.scooter, with: GeoRoutesClientTypes.RouteMatrixScooterOptions.write(value:to:))
        try writer["Truck"].write(value.truck, with: GeoRoutesClientTypes.RouteMatrixTruckOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteMatrixTruckOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixTruckOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxleCount"].write(value.axleCount)
        try writer["GrossWeight"].write(value.grossWeight)
        try writer["HazardousCargos"].writeList(value.hazardousCargos, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.RouteMatrixHazardousCargoType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Height"].write(value.height)
        try writer["KpraLength"].write(value.kpraLength)
        try writer["Length"].write(value.length)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
        try writer["PayloadCapacity"].write(value.payloadCapacity)
        try writer["Trailer"].write(value.trailer, with: GeoRoutesClientTypes.RouteMatrixTrailerOptions.write(value:to:))
        try writer["TruckType"].write(value.truckType)
        try writer["TunnelRestrictionCode"].write(value.tunnelRestrictionCode)
        try writer["WeightPerAxle"].write(value.weightPerAxle)
        try writer["WeightPerAxleGroup"].write(value.weightPerAxleGroup, with: GeoRoutesClientTypes.WeightPerAxleGroup.write(value:to:))
        try writer["Width"].write(value.width)
    }
}

extension GeoRoutesClientTypes.RouteMatrixTrailerOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixTrailerOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrailerCount"].write(value.trailerCount)
    }
}

extension GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate {

    static func write(value: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LastCharacter"].write(value.lastCharacter)
    }
}

extension GeoRoutesClientTypes.RouteMatrixScooterOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixScooterOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
    }
}

extension GeoRoutesClientTypes.RouteMatrixCarOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixCarOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
    }
}

extension GeoRoutesClientTypes.RouteAllowOptions {

    static func write(value: GeoRoutesClientTypes.RouteAllowOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hot"].write(value.hot)
        try writer["Hov"].write(value.hov)
    }
}

extension GeoRoutesClientTypes.RouteAvoidanceOptions {

    static func write(value: GeoRoutesClientTypes.RouteAvoidanceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Areas"].writeList(value.areas, memberWritingClosure: GeoRoutesClientTypes.RouteAvoidanceArea.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CarShuttleTrains"].write(value.carShuttleTrains)
        try writer["ControlledAccessHighways"].write(value.controlledAccessHighways)
        try writer["DirtRoads"].write(value.dirtRoads)
        try writer["Ferries"].write(value.ferries)
        try writer["SeasonalClosure"].write(value.seasonalClosure)
        try writer["TollRoads"].write(value.tollRoads)
        try writer["TollTransponders"].write(value.tollTransponders)
        try writer["TruckRoadTypes"].writeList(value.truckRoadTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tunnels"].write(value.tunnels)
        try writer["UTurns"].write(value.uTurns)
        try writer["ZoneCategories"].writeList(value.zoneCategories, memberWritingClosure: GeoRoutesClientTypes.RouteAvoidanceZoneCategory.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteAvoidanceZoneCategory {

    static func write(value: GeoRoutesClientTypes.RouteAvoidanceZoneCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category)
    }
}

extension GeoRoutesClientTypes.RouteAvoidanceArea {

    static func write(value: GeoRoutesClientTypes.RouteAvoidanceArea?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Except"].writeList(value.except, memberWritingClosure: GeoRoutesClientTypes.RouteAvoidanceAreaGeometry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Geometry"].write(value.geometry, with: GeoRoutesClientTypes.RouteAvoidanceAreaGeometry.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteAvoidanceAreaGeometry {

    static func write(value: GeoRoutesClientTypes.RouteAvoidanceAreaGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Corridor"].write(value.corridor, with: GeoRoutesClientTypes.Corridor.write(value:to:))
        try writer["Polygon"].writeList(value.polygon, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["PolylineCorridor"].write(value.polylineCorridor, with: GeoRoutesClientTypes.PolylineCorridor.write(value:to:))
        try writer["PolylinePolygon"].writeList(value.polylinePolygon, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteDestinationOptions {

    static func write(value: GeoRoutesClientTypes.RouteDestinationOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["AvoidUTurns"].write(value.avoidUTurns)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.RouteMatchingOptions.write(value:to:))
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.RouteSideOfStreetOptions.write(value:to:))
        try writer["StopDuration"].write(value.stopDuration)
    }
}

extension GeoRoutesClientTypes.RouteSideOfStreetOptions {

    static func write(value: GeoRoutesClientTypes.RouteSideOfStreetOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UseWith"].write(value.useWith)
    }
}

extension GeoRoutesClientTypes.RouteMatchingOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatchingOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NameHint"].write(value.nameHint)
        try writer["OnRoadThreshold"].write(value.onRoadThreshold)
        try writer["Radius"].write(value.radius)
        try writer["Strategy"].write(value.strategy)
    }
}

extension GeoRoutesClientTypes.RouteDriverOptions {

    static func write(value: GeoRoutesClientTypes.RouteDriverOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Schedule"].writeList(value.schedule, memberWritingClosure: GeoRoutesClientTypes.RouteDriverScheduleInterval.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteDriverScheduleInterval {

    static func write(value: GeoRoutesClientTypes.RouteDriverScheduleInterval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DriveDuration"].write(value.driveDuration)
        try writer["RestDuration"].write(value.restDuration)
    }
}

extension GeoRoutesClientTypes.RouteExclusionOptions {

    static func write(value: GeoRoutesClientTypes.RouteExclusionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Countries"].writeList(value.countries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteOriginOptions {

    static func write(value: GeoRoutesClientTypes.RouteOriginOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["AvoidUTurns"].write(value.avoidUTurns)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.RouteMatchingOptions.write(value:to:))
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.RouteSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteTollOptions {

    static func write(value: GeoRoutesClientTypes.RouteTollOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllTransponders"].write(value.allTransponders)
        try writer["AllVignettes"].write(value.allVignettes)
        try writer["Currency"].write(value.currency)
        try writer["EmissionType"].write(value.emissionType, with: GeoRoutesClientTypes.RouteEmissionType.write(value:to:))
        try writer["VehicleCategory"].write(value.vehicleCategory)
    }
}

extension GeoRoutesClientTypes.RouteEmissionType {

    static func write(value: GeoRoutesClientTypes.RouteEmissionType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Co2EmissionClass"].write(value.co2EmissionClass)
        try writer["Type"].write(value.type)
    }
}

extension GeoRoutesClientTypes.RouteTrafficOptions {

    static func write(value: GeoRoutesClientTypes.RouteTrafficOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FlowEventThresholdOverride"].write(value.flowEventThresholdOverride)
        try writer["Usage"].write(value.usage)
    }
}

extension GeoRoutesClientTypes.RouteTravelModeOptions {

    static func write(value: GeoRoutesClientTypes.RouteTravelModeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Car"].write(value.car, with: GeoRoutesClientTypes.RouteCarOptions.write(value:to:))
        try writer["Ev"].write(value.ev, with: GeoRoutesClientTypes.RouteEvOptions.write(value:to:))
        try writer["Pedestrian"].write(value.pedestrian, with: GeoRoutesClientTypes.RoutePedestrianOptions.write(value:to:))
        try writer["Scooter"].write(value.scooter, with: GeoRoutesClientTypes.RouteScooterOptions.write(value:to:))
        try writer["Truck"].write(value.truck, with: GeoRoutesClientTypes.RouteTruckOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteTruckOptions {

    static func write(value: GeoRoutesClientTypes.RouteTruckOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxleCount"].write(value.axleCount)
        try writer["EngineType"].write(value.engineType)
        try writer["GrossWeight"].write(value.grossWeight)
        try writer["HazardousCargos"].writeList(value.hazardousCargos, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.RouteHazardousCargoType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Height"].write(value.height)
        try writer["HeightAboveFirstAxle"].write(value.heightAboveFirstAxle)
        try writer["KpraLength"].write(value.kpraLength)
        try writer["Length"].write(value.length)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.RouteVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
        try writer["PayloadCapacity"].write(value.payloadCapacity)
        try writer["TireCount"].write(value.tireCount)
        try writer["Trailer"].write(value.trailer, with: GeoRoutesClientTypes.RouteTrailerOptions.write(value:to:))
        try writer["TruckType"].write(value.truckType)
        try writer["TunnelRestrictionCode"].write(value.tunnelRestrictionCode)
        try writer["WeightPerAxle"].write(value.weightPerAxle)
        try writer["WeightPerAxleGroup"].write(value.weightPerAxleGroup, with: GeoRoutesClientTypes.WeightPerAxleGroup.write(value:to:))
        try writer["Width"].write(value.width)
    }
}

extension GeoRoutesClientTypes.RouteVehicleLicensePlate {

    static func write(value: GeoRoutesClientTypes.RouteVehicleLicensePlate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LastCharacter"].write(value.lastCharacter)
    }
}

extension GeoRoutesClientTypes.RouteTrailerOptions {

    static func write(value: GeoRoutesClientTypes.RouteTrailerOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxleCount"].write(value.axleCount)
        try writer["TrailerCount"].write(value.trailerCount)
    }
}

extension GeoRoutesClientTypes.RouteScooterOptions {

    static func write(value: GeoRoutesClientTypes.RouteScooterOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineType"].write(value.engineType)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.RouteVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
    }
}

extension GeoRoutesClientTypes.RoutePedestrianOptions {

    static func write(value: GeoRoutesClientTypes.RoutePedestrianOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Speed"].write(value.speed)
    }
}

extension GeoRoutesClientTypes.RouteEvOptions {

    static func write(value: GeoRoutesClientTypes.RouteEvOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuxiliaryConsumptionRate"].write(value.auxiliaryConsumptionRate)
        try writer["ChargingCurve"].writeList(value.chargingCurve, memberWritingClosure: GeoRoutesClientTypes.ChargingRateAtChargeLevel.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChargingSetupDuration"].write(value.chargingSetupDuration)
        try writer["ConnectorTypes"].writeList(value.connectorTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.RouteChargingConnectorType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ConsumptionRateOnAscent"].write(value.consumptionRateOnAscent)
        try writer["ConsumptionRateOnDescent"].write(value.consumptionRateOnDescent)
        try writer["FreeFlowConsumptionCurve"].writeList(value.freeFlowConsumptionCurve, memberWritingClosure: GeoRoutesClientTypes.ConsumptionRateAtSpeed.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MakeReachable"].write(value.makeReachable)
        try writer["MaxCharge"].write(value.maxCharge)
        try writer["MaxChargeDepartingFromChargingStation"].write(value.maxChargeDepartingFromChargingStation)
        try writer["MaxChargingCurrent"].write(value.maxChargingCurrent)
        try writer["MaxChargingVoltage"].write(value.maxChargingVoltage)
        try writer["MinChargeArrivingAtChargingStation"].write(value.minChargeArrivingAtChargingStation)
        try writer["MinChargeArrivingAtDestination"].write(value.minChargeArrivingAtDestination)
        try writer["MinChargeArrivingAtFirstChargingStation"].write(value.minChargeArrivingAtFirstChargingStation)
        try writer["OriginCharge"].write(value.originCharge)
        try writer["TrafficConsumptionCurve"].writeList(value.trafficConsumptionCurve, memberWritingClosure: GeoRoutesClientTypes.ConsumptionRateAtSpeed.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.ConsumptionRateAtSpeed {

    static func write(value: GeoRoutesClientTypes.ConsumptionRateAtSpeed?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConsumptionRate"].write(value.consumptionRate)
        try writer["Speed"].write(value.speed)
    }
}

extension GeoRoutesClientTypes.ChargingRateAtChargeLevel {

    static func write(value: GeoRoutesClientTypes.ChargingRateAtChargeLevel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChargingLevel"].write(value.chargingLevel)
        try writer["ChargingRate"].write(value.chargingRate)
    }
}

extension GeoRoutesClientTypes.RouteCarOptions {

    static func write(value: GeoRoutesClientTypes.RouteCarOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineType"].write(value.engineType)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.RouteVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
    }
}

extension GeoRoutesClientTypes.RouteWaypoint {

    static func write(value: GeoRoutesClientTypes.RouteWaypoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["AvoidUTurns"].write(value.avoidUTurns)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.RouteMatchingOptions.write(value:to:))
        try writer["PassThrough"].write(value.passThrough)
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.RouteSideOfStreetOptions.write(value:to:))
        try writer["StopDuration"].write(value.stopDuration)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationAvoidanceOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationAvoidanceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Areas"].writeList(value.areas, memberWritingClosure: GeoRoutesClientTypes.WaypointOptimizationAvoidanceArea.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CarShuttleTrains"].write(value.carShuttleTrains)
        try writer["ControlledAccessHighways"].write(value.controlledAccessHighways)
        try writer["DirtRoads"].write(value.dirtRoads)
        try writer["Ferries"].write(value.ferries)
        try writer["TollRoads"].write(value.tollRoads)
        try writer["Tunnels"].write(value.tunnels)
        try writer["UTurns"].write(value.uTurns)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationAvoidanceArea {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationAvoidanceArea?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Geometry"].write(value.geometry, with: GeoRoutesClientTypes.WaypointOptimizationAvoidanceAreaGeometry.write(value:to:))
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationAvoidanceAreaGeometry {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationAvoidanceAreaGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationClusteringOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationClusteringOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Algorithm"].write(value.algorithm)
        try writer["DrivingDistanceOptions"].write(value.drivingDistanceOptions, with: GeoRoutesClientTypes.WaypointOptimizationDrivingDistanceOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationDrivingDistanceOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationDrivingDistanceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DrivingDistance"].write(value.drivingDistance)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationDestinationOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationDestinationOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessHours"].write(value.accessHours, with: GeoRoutesClientTypes.WaypointOptimizationAccessHours.write(value:to:))
        try writer["AppointmentTime"].write(value.appointmentTime)
        try writer["Heading"].write(value.heading)
        try writer["Id"].write(value.id)
        try writer["ServiceDuration"].write(value.serviceDuration)
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UseWith"].write(value.useWith)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationAccessHours {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationAccessHours?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["From"].write(value.from, with: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry.write(value:to:))
        try writer["To"].write(value.to, with: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry.write(value:to:))
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DayOfWeek"].write(value.dayOfWeek)
        try writer["TimeOfDay"].write(value.timeOfDay)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationDriverOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationDriverOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RestCycles"].write(value.restCycles, with: GeoRoutesClientTypes.WaypointOptimizationRestCycles.write(value:to:))
        try writer["RestProfile"].write(value.restProfile, with: GeoRoutesClientTypes.WaypointOptimizationRestProfile.write(value:to:))
        try writer["TreatServiceTimeAs"].write(value.treatServiceTimeAs)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationRestProfile {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationRestProfile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Profile"].write(value.profile)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationRestCycles {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationRestCycles?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LongCycle"].write(value.longCycle, with: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations.write(value:to:))
        try writer["ShortCycle"].write(value.shortCycle, with: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations.write(value:to:))
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RestDuration"].write(value.restDuration)
        try writer["WorkDuration"].write(value.workDuration)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationExclusionOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationExclusionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Countries"].writeList(value.countries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationOriginOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationOriginOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationTrafficOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationTrafficOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Usage"].write(value.usage)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationTravelModeOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationTravelModeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ev"].write(value.ev, with: GeoRoutesClientTypes.WaypointOptimizationEvOptions.write(value:to:))
        try writer["Pedestrian"].write(value.pedestrian, with: GeoRoutesClientTypes.WaypointOptimizationPedestrianOptions.write(value:to:))
        try writer["Truck"].write(value.truck, with: GeoRoutesClientTypes.WaypointOptimizationTruckOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationTruckOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationTruckOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrossWeight"].write(value.grossWeight)
        try writer["HazardousCargos"].writeList(value.hazardousCargos, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.WaypointOptimizationHazardousCargoType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Height"].write(value.height)
        try writer["Length"].write(value.length)
        try writer["Trailer"].write(value.trailer, with: GeoRoutesClientTypes.WaypointOptimizationTrailerOptions.write(value:to:))
        try writer["TruckType"].write(value.truckType)
        try writer["TunnelRestrictionCode"].write(value.tunnelRestrictionCode)
        try writer["WeightPerAxle"].write(value.weightPerAxle)
        try writer["Width"].write(value.width)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationTrailerOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationTrailerOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrailerCount"].write(value.trailerCount)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationPedestrianOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationPedestrianOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Speed"].write(value.speed)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationEvOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationEvOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChargingTime"].write(value.chargingTime, with: GeoRoutesClientTypes.WaypointOptimizationChargingTime.write(value:to:))
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationChargingTime {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationChargingTime?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChargingTime"].write(value.chargingTime)
        try writer["RangeIncrease"].write(value.rangeIncrease)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationWaypoint {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationWaypoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessHours"].write(value.accessHours, with: GeoRoutesClientTypes.WaypointOptimizationAccessHours.write(value:to:))
        try writer["AppointmentTime"].write(value.appointmentTime)
        try writer["Before"].writeList(value.before, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Heading"].write(value.heading)
        try writer["Id"].write(value.id)
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ServiceDuration"].write(value.serviceDuration)
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RoadSnapTracePoint {

    static func write(value: GeoRoutesClientTypes.RoadSnapTracePoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Heading"].write(value.heading)
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Speed"].write(value.speed)
        try writer["Timestamp"].write(value.timestamp)
    }
}

extension GeoRoutesClientTypes.RoadSnapTravelModeOptions {

    static func write(value: GeoRoutesClientTypes.RoadSnapTravelModeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Truck"].write(value.truck, with: GeoRoutesClientTypes.RoadSnapTruckOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RoadSnapTruckOptions {

    static func write(value: GeoRoutesClientTypes.RoadSnapTruckOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrossWeight"].write(value.grossWeight)
        try writer["HazardousCargos"].writeList(value.hazardousCargos, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.RoadSnapHazardousCargoType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Height"].write(value.height)
        try writer["Length"].write(value.length)
        try writer["Trailer"].write(value.trailer, with: GeoRoutesClientTypes.RoadSnapTrailerOptions.write(value:to:))
        try writer["TunnelRestrictionCode"].write(value.tunnelRestrictionCode)
        try writer["Width"].write(value.width)
    }
}

extension GeoRoutesClientTypes.RoadSnapTrailerOptions {

    static func write(value: GeoRoutesClientTypes.RoadSnapTrailerOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrailerCount"].write(value.trailerCount)
    }
}

public enum GeoRoutesClientTypes {}
