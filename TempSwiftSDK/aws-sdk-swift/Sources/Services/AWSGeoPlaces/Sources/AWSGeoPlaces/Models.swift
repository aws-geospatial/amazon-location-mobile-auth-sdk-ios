//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GeoPlacesClientTypes {

    public struct AccessPoint: Swift.Sendable {
        public var position: [Swift.Double]?

        public init(
            position: [Swift.Double]? = nil
        )
        {
            self.position = position
        }
    }
}

extension GeoPlacesClientTypes.AccessPoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessPoint(position: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public struct Category: Swift.Sendable {
        /// This member is required.
        public var id: Swift.String?
        public var localizedName: Swift.String?
        /// This member is required.
        public var name: Swift.String?
        public var primary: Swift.Bool?

        public init(
            id: Swift.String? = nil,
            localizedName: Swift.String? = nil,
            name: Swift.String? = nil,
            primary: Swift.Bool? = nil
        )
        {
            self.id = id
            self.localizedName = localizedName
            self.name = name
            self.primary = primary
        }
    }
}

extension GeoPlacesClientTypes {

    public struct AccessRestriction: Swift.Sendable {
        public var categories: [GeoPlacesClientTypes.Category]?
        public var restricted: Swift.Bool?

        public init(
            categories: [GeoPlacesClientTypes.Category]? = nil,
            restricted: Swift.Bool? = nil
        )
        {
            self.categories = categories
            self.restricted = restricted
        }
    }
}

extension GeoPlacesClientTypes {

    public struct Country: Swift.Sendable {
        public var code2: Swift.String?
        public var code3: Swift.String?
        public var name: Swift.String?

        public init(
            code2: Swift.String? = nil,
            code3: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code2 = code2
            self.code3 = code3
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    public struct Region: Swift.Sendable {
        public var code: Swift.String?
        public var name: Swift.String?

        public init(
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    public enum TypePlacement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afterBaseName
        case beforeBaseName
        case sdkUnknown(Swift.String)

        public static var allCases: [TypePlacement] {
            return [
                .afterBaseName,
                .beforeBaseName
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afterBaseName: return "AfterBaseName"
            case .beforeBaseName: return "BeforeBaseName"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public struct StreetComponents: Swift.Sendable {
        public var baseName: Swift.String?
        public var direction: Swift.String?
        public var language: Swift.String?
        public var `prefix`: Swift.String?
        public var suffix: Swift.String?
        public var type: Swift.String?
        public var typePlacement: GeoPlacesClientTypes.TypePlacement?
        public var typeSeparator: Swift.String?

        public init(
            baseName: Swift.String? = nil,
            direction: Swift.String? = nil,
            language: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            suffix: Swift.String? = nil,
            type: Swift.String? = nil,
            typePlacement: GeoPlacesClientTypes.TypePlacement? = nil,
            typeSeparator: Swift.String? = nil
        )
        {
            self.baseName = baseName
            self.direction = direction
            self.language = language
            self.`prefix` = `prefix`
            self.suffix = suffix
            self.type = type
            self.typePlacement = typePlacement
            self.typeSeparator = typeSeparator
        }
    }
}

extension GeoPlacesClientTypes {

    public struct SubRegion: Swift.Sendable {
        public var code: Swift.String?
        public var name: Swift.String?

        public init(
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    public struct Address: Swift.Sendable {
        public var addressNumber: Swift.String?
        public var block: Swift.String?
        public var building: Swift.String?
        public var country: GeoPlacesClientTypes.Country?
        public var district: Swift.String?
        public var intersection: [Swift.String]?
        public var label: Swift.String?
        public var locality: Swift.String?
        public var postalCode: Swift.String?
        public var region: GeoPlacesClientTypes.Region?
        public var street: Swift.String?
        public var streetComponents: [GeoPlacesClientTypes.StreetComponents]?
        public var subBlock: Swift.String?
        public var subDistrict: Swift.String?
        public var subRegion: GeoPlacesClientTypes.SubRegion?

        public init(
            addressNumber: Swift.String? = nil,
            block: Swift.String? = nil,
            building: Swift.String? = nil,
            country: GeoPlacesClientTypes.Country? = nil,
            district: Swift.String? = nil,
            intersection: [Swift.String]? = nil,
            label: Swift.String? = nil,
            locality: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            region: GeoPlacesClientTypes.Region? = nil,
            street: Swift.String? = nil,
            streetComponents: [GeoPlacesClientTypes.StreetComponents]? = nil,
            subBlock: Swift.String? = nil,
            subDistrict: Swift.String? = nil,
            subRegion: GeoPlacesClientTypes.SubRegion? = nil
        )
        {
            self.addressNumber = addressNumber
            self.block = block
            self.building = building
            self.country = country
            self.district = district
            self.intersection = intersection
            self.label = label
            self.locality = locality
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.streetComponents = streetComponents
            self.subBlock = subBlock
            self.subDistrict = subDistrict
            self.subRegion = subRegion
        }
    }
}

extension GeoPlacesClientTypes {

    public struct AddressComponentMatchScores: Swift.Sendable {
        public var addressNumber: Swift.Double
        public var block: Swift.Double
        public var building: Swift.Double
        public var country: Swift.Double
        public var district: Swift.Double
        public var intersection: [Swift.Double]?
        public var locality: Swift.Double
        public var postalCode: Swift.Double
        public var region: Swift.Double
        public var subBlock: Swift.Double
        public var subDistrict: Swift.Double
        public var subRegion: Swift.Double

        public init(
            addressNumber: Swift.Double = 0.0,
            block: Swift.Double = 0.0,
            building: Swift.Double = 0.0,
            country: Swift.Double = 0.0,
            district: Swift.Double = 0.0,
            intersection: [Swift.Double]? = nil,
            locality: Swift.Double = 0.0,
            postalCode: Swift.Double = 0.0,
            region: Swift.Double = 0.0,
            subBlock: Swift.Double = 0.0,
            subDistrict: Swift.Double = 0.0,
            subRegion: Swift.Double = 0.0
        )
        {
            self.addressNumber = addressNumber
            self.block = block
            self.building = building
            self.country = country
            self.district = district
            self.intersection = intersection
            self.locality = locality
            self.postalCode = postalCode
            self.region = region
            self.subBlock = subBlock
            self.subDistrict = subDistrict
            self.subRegion = subRegion
        }
    }
}

extension GeoPlacesClientTypes {

    public struct PhonemeTranscription: Swift.Sendable {
        public var language: Swift.String?
        public var preferred: Swift.Bool?
        public var value: Swift.String?

        public init(
            language: Swift.String? = nil,
            preferred: Swift.Bool? = nil,
            value: Swift.String? = nil
        )
        {
            self.language = language
            self.preferred = preferred
            self.value = value
        }
    }
}

extension GeoPlacesClientTypes {

    public struct AddressComponentPhonemes: Swift.Sendable {
        public var block: [GeoPlacesClientTypes.PhonemeTranscription]?
        public var country: [GeoPlacesClientTypes.PhonemeTranscription]?
        public var district: [GeoPlacesClientTypes.PhonemeTranscription]?
        public var locality: [GeoPlacesClientTypes.PhonemeTranscription]?
        public var region: [GeoPlacesClientTypes.PhonemeTranscription]?
        public var street: [GeoPlacesClientTypes.PhonemeTranscription]?
        public var subBlock: [GeoPlacesClientTypes.PhonemeTranscription]?
        public var subDistrict: [GeoPlacesClientTypes.PhonemeTranscription]?
        public var subRegion: [GeoPlacesClientTypes.PhonemeTranscription]?

        public init(
            block: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            country: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            district: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            locality: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            region: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            street: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            subBlock: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            subDistrict: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            subRegion: [GeoPlacesClientTypes.PhonemeTranscription]? = nil
        )
        {
            self.block = block
            self.country = country
            self.district = district
            self.locality = locality
            self.region = region
            self.street = street
            self.subBlock = subBlock
            self.subDistrict = subDistrict
            self.subRegion = subRegion
        }
    }
}

public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GeoPlacesClientTypes {

    public struct ValidationExceptionField: Swift.Sendable {
        /// This member is required.
        public var message: Swift.String?
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The input cannot be parsed. For example a required JSON document, ARN identifier, date value, or numeric field cannot be parsed.
        case cannotparse
        /// The input is present and parsable, but it is otherwise invalid. For example, a required numeric argument is outside the allowed range.
        case fieldvalidationfailed
        /// The required input is missing.
        case missing
        /// The input is invalid but no more specific reason is applicable.
        case other
        /// No such field is supported.
        case unknownfield
        /// No such operation is supported.
        case unknownoperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotparse,
                .fieldvalidationfailed,
                .missing,
                .other,
                .unknownfield,
                .unknownoperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotparse: return "CannotParse"
            case .fieldvalidationfailed: return "FieldValidationFailed"
            case .missing: return "Missing"
            case .other: return "Other"
            case .unknownfield: return "UnknownField"
            case .unknownoperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var fieldList: [GeoPlacesClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// This member is required.
        public internal(set) var reason: GeoPlacesClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [GeoPlacesClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: GeoPlacesClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension GeoPlacesClientTypes {

    public struct FilterCircle: Swift.Sendable {
        /// This member is required.
        public var center: [Swift.Double]?
        /// This member is required.
        public var radius: Swift.Int?

        public init(
            center: [Swift.Double]? = nil,
            radius: Swift.Int? = 0
        )
        {
            self.center = center
            self.radius = radius
        }
    }
}

extension GeoPlacesClientTypes.FilterCircle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension GeoPlacesClientTypes {

    public enum AutocompleteFilterPlaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case country
        case district
        case interpolatedAddress
        case intersection
        case locality
        case pointAddress
        case postalCodeArea
        case postalCodePoint
        case region
        case street
        case subDistrict
        case subRegion
        case sdkUnknown(Swift.String)

        public static var allCases: [AutocompleteFilterPlaceType] {
            return [
                .country,
                .district,
                .interpolatedAddress,
                .intersection,
                .locality,
                .pointAddress,
                .postalCodeArea,
                .postalCodePoint,
                .region,
                .street,
                .subDistrict,
                .subRegion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .country: return "Country"
            case .district: return "District"
            case .interpolatedAddress: return "InterpolatedAddress"
            case .intersection: return "Intersection"
            case .locality: return "Locality"
            case .pointAddress: return "PointAddress"
            case .postalCodeArea: return "PostalCodeArea"
            case .postalCodePoint: return "PostalCodePoint"
            case .region: return "Region"
            case .street: return "Street"
            case .subDistrict: return "SubDistrict"
            case .subRegion: return "SubRegion"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public struct AutocompleteFilter: Swift.Sendable {
        public var boundingBox: [Swift.Double]?
        public var circle: GeoPlacesClientTypes.FilterCircle?
        public var includeCountries: [Swift.String]?
        public var includePlaceTypes: [GeoPlacesClientTypes.AutocompleteFilterPlaceType]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            circle: GeoPlacesClientTypes.FilterCircle? = nil,
            includeCountries: [Swift.String]? = nil,
            includePlaceTypes: [GeoPlacesClientTypes.AutocompleteFilterPlaceType]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.circle = circle
            self.includeCountries = includeCountries
            self.includePlaceTypes = includePlaceTypes
        }
    }
}

extension GeoPlacesClientTypes.AutocompleteFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutocompleteFilter(includeCountries: \(Swift.String(describing: includeCountries)), includePlaceTypes: \(Swift.String(describing: includePlaceTypes)), boundingBox: \"CONTENT_REDACTED\", circle: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public enum IntendedUse: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse
        /// Indicates that results of the operation may be stored locally.
        case storage
        case sdkUnknown(Swift.String)

        public static var allCases: [IntendedUse] {
            return [
                .singleUse,
                .storage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .singleUse: return "SingleUse"
            case .storage: return "Storage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public enum PostalCodeMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enumerateSpannedLocalities
        case mergeAllSpannedLocalities
        case sdkUnknown(Swift.String)

        public static var allCases: [PostalCodeMode] {
            return [
                .enumerateSpannedLocalities,
                .mergeAllSpannedLocalities
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enumerateSpannedLocalities: return "EnumerateSpannedLocalities"
            case .mergeAllSpannedLocalities: return "MergeAllSpannedLocalities"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AutocompleteInput: Swift.Sendable {
    public var biasPosition: [Swift.Double]?
    public var filter: GeoPlacesClientTypes.AutocompleteFilter?
    public var intendedUse: GeoPlacesClientTypes.IntendedUse?
    public var key: Swift.String?
    public var language: Swift.String?
    public var maxResults: Swift.Int?
    public var politicalView: Swift.String?
    public var postalCodeMode: GeoPlacesClientTypes.PostalCodeMode?
    /// This member is required.
    public var queryText: Swift.String?

    public init(
        biasPosition: [Swift.Double]? = nil,
        filter: GeoPlacesClientTypes.AutocompleteFilter? = nil,
        intendedUse: GeoPlacesClientTypes.IntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        politicalView: Swift.String? = nil,
        postalCodeMode: GeoPlacesClientTypes.PostalCodeMode? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.biasPosition = biasPosition
        self.filter = filter
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.politicalView = politicalView
        self.postalCodeMode = postalCodeMode
        self.queryText = queryText
    }
}

extension AutocompleteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutocompleteInput(filter: \(Swift.String(describing: filter)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), politicalView: \(Swift.String(describing: politicalView)), postalCodeMode: \(Swift.String(describing: postalCodeMode)), biasPosition: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", queryText: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public struct Highlight: Swift.Sendable {
        public var endIndex: Swift.Int?
        public var startIndex: Swift.Int?
        public var value: Swift.String?

        public init(
            endIndex: Swift.Int? = nil,
            startIndex: Swift.Int? = nil,
            value: Swift.String? = nil
        )
        {
            self.endIndex = endIndex
            self.startIndex = startIndex
            self.value = value
        }
    }
}

extension GeoPlacesClientTypes {

    public struct CountryHighlights: Swift.Sendable {
        public var code: [GeoPlacesClientTypes.Highlight]?
        public var name: [GeoPlacesClientTypes.Highlight]?

        public init(
            code: [GeoPlacesClientTypes.Highlight]? = nil,
            name: [GeoPlacesClientTypes.Highlight]? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    public struct RegionHighlights: Swift.Sendable {
        public var code: [GeoPlacesClientTypes.Highlight]?
        public var name: [GeoPlacesClientTypes.Highlight]?

        public init(
            code: [GeoPlacesClientTypes.Highlight]? = nil,
            name: [GeoPlacesClientTypes.Highlight]? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    public struct SubRegionHighlights: Swift.Sendable {
        public var code: [GeoPlacesClientTypes.Highlight]?
        public var name: [GeoPlacesClientTypes.Highlight]?

        public init(
            code: [GeoPlacesClientTypes.Highlight]? = nil,
            name: [GeoPlacesClientTypes.Highlight]? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    public struct AutocompleteAddressHighlights: Swift.Sendable {
        public var addressNumber: [GeoPlacesClientTypes.Highlight]?
        public var block: [GeoPlacesClientTypes.Highlight]?
        public var building: [GeoPlacesClientTypes.Highlight]?
        public var country: GeoPlacesClientTypes.CountryHighlights?
        public var district: [GeoPlacesClientTypes.Highlight]?
        public var intersection: [[GeoPlacesClientTypes.Highlight]]?
        public var label: [GeoPlacesClientTypes.Highlight]?
        public var locality: [GeoPlacesClientTypes.Highlight]?
        public var postalCode: [GeoPlacesClientTypes.Highlight]?
        public var region: GeoPlacesClientTypes.RegionHighlights?
        public var street: [GeoPlacesClientTypes.Highlight]?
        public var subBlock: [GeoPlacesClientTypes.Highlight]?
        public var subDistrict: [GeoPlacesClientTypes.Highlight]?
        public var subRegion: GeoPlacesClientTypes.SubRegionHighlights?

        public init(
            addressNumber: [GeoPlacesClientTypes.Highlight]? = nil,
            block: [GeoPlacesClientTypes.Highlight]? = nil,
            building: [GeoPlacesClientTypes.Highlight]? = nil,
            country: GeoPlacesClientTypes.CountryHighlights? = nil,
            district: [GeoPlacesClientTypes.Highlight]? = nil,
            intersection: [[GeoPlacesClientTypes.Highlight]]? = nil,
            label: [GeoPlacesClientTypes.Highlight]? = nil,
            locality: [GeoPlacesClientTypes.Highlight]? = nil,
            postalCode: [GeoPlacesClientTypes.Highlight]? = nil,
            region: GeoPlacesClientTypes.RegionHighlights? = nil,
            street: [GeoPlacesClientTypes.Highlight]? = nil,
            subBlock: [GeoPlacesClientTypes.Highlight]? = nil,
            subDistrict: [GeoPlacesClientTypes.Highlight]? = nil,
            subRegion: GeoPlacesClientTypes.SubRegionHighlights? = nil
        )
        {
            self.addressNumber = addressNumber
            self.block = block
            self.building = building
            self.country = country
            self.district = district
            self.intersection = intersection
            self.label = label
            self.locality = locality
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subBlock = subBlock
            self.subDistrict = subDistrict
            self.subRegion = subRegion
        }
    }
}

extension GeoPlacesClientTypes {

    public struct AutocompleteHighlights: Swift.Sendable {
        public var address: GeoPlacesClientTypes.AutocompleteAddressHighlights?
        public var title: [GeoPlacesClientTypes.Highlight]?

        public init(
            address: GeoPlacesClientTypes.AutocompleteAddressHighlights? = nil,
            title: [GeoPlacesClientTypes.Highlight]? = nil
        )
        {
            self.address = address
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes {

    public enum PlaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case block
        case country
        case district
        case interpolatedAddress
        case intersection
        case locality
        case pointAddress
        case pointOfInterest
        case postalCodeArea
        case postalCodePoint
        case region
        case street
        case subBlock
        case subDistrict
        case subRegion
        case sdkUnknown(Swift.String)

        public static var allCases: [PlaceType] {
            return [
                .block,
                .country,
                .district,
                .interpolatedAddress,
                .intersection,
                .locality,
                .pointAddress,
                .pointOfInterest,
                .postalCodeArea,
                .postalCodePoint,
                .region,
                .street,
                .subBlock,
                .subDistrict,
                .subRegion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .block: return "Block"
            case .country: return "Country"
            case .district: return "District"
            case .interpolatedAddress: return "InterpolatedAddress"
            case .intersection: return "Intersection"
            case .locality: return "Locality"
            case .pointAddress: return "PointAddress"
            case .pointOfInterest: return "PointOfInterest"
            case .postalCodeArea: return "PostalCodeArea"
            case .postalCodePoint: return "PostalCodePoint"
            case .region: return "Region"
            case .street: return "Street"
            case .subBlock: return "SubBlock"
            case .subDistrict: return "SubDistrict"
            case .subRegion: return "SubRegion"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public struct AutocompleteResultItem: Swift.Sendable {
        public var address: GeoPlacesClientTypes.Address?
        public var distance: Swift.Int
        public var highlights: GeoPlacesClientTypes.AutocompleteHighlights?
        public var language: Swift.String?
        /// This member is required.
        public var placeId: Swift.String?
        /// This member is required.
        public var placeType: GeoPlacesClientTypes.PlaceType?
        public var politicalView: Swift.String?
        /// This member is required.
        public var title: Swift.String?

        public init(
            address: GeoPlacesClientTypes.Address? = nil,
            distance: Swift.Int = 0,
            highlights: GeoPlacesClientTypes.AutocompleteHighlights? = nil,
            language: Swift.String? = nil,
            placeId: Swift.String? = nil,
            placeType: GeoPlacesClientTypes.PlaceType? = nil,
            politicalView: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.address = address
            self.distance = distance
            self.highlights = highlights
            self.language = language
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.title = title
        }
    }
}

public struct AutocompleteOutput: Swift.Sendable {
    /// This member is required.
    public var pricingBucket: Swift.String?
    public var resultItems: [GeoPlacesClientTypes.AutocompleteResultItem]?

    public init(
        pricingBucket: Swift.String? = nil,
        resultItems: [GeoPlacesClientTypes.AutocompleteResultItem]? = nil
    )
    {
        self.pricingBucket = pricingBucket
        self.resultItems = resultItems
    }
}

extension GeoPlacesClientTypes {

    public struct BusinessChain: Swift.Sendable {
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    public struct ComponentMatchScores: Swift.Sendable {
        public var address: GeoPlacesClientTypes.AddressComponentMatchScores?
        public var title: Swift.Double

        public init(
            address: GeoPlacesClientTypes.AddressComponentMatchScores? = nil,
            title: Swift.Double = 0.0
        )
        {
            self.address = address
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes {

    public struct ContactDetails: Swift.Sendable {
        public var categories: [GeoPlacesClientTypes.Category]?
        public var label: Swift.String?
        public var value: Swift.String?

        public init(
            categories: [GeoPlacesClientTypes.Category]? = nil,
            label: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.categories = categories
            self.label = label
            self.value = value
        }
    }
}

extension GeoPlacesClientTypes {

    public struct Contacts: Swift.Sendable {
        public var emails: [GeoPlacesClientTypes.ContactDetails]?
        public var faxes: [GeoPlacesClientTypes.ContactDetails]?
        public var phones: [GeoPlacesClientTypes.ContactDetails]?
        public var websites: [GeoPlacesClientTypes.ContactDetails]?

        public init(
            emails: [GeoPlacesClientTypes.ContactDetails]? = nil,
            faxes: [GeoPlacesClientTypes.ContactDetails]? = nil,
            phones: [GeoPlacesClientTypes.ContactDetails]? = nil,
            websites: [GeoPlacesClientTypes.ContactDetails]? = nil
        )
        {
            self.emails = emails
            self.faxes = faxes
            self.phones = phones
            self.websites = websites
        }
    }
}

extension GeoPlacesClientTypes {

    public struct FoodType: Swift.Sendable {
        /// This member is required.
        public var localizedName: Swift.String?
        public var primary: Swift.Bool?

        public init(
            localizedName: Swift.String? = nil,
            primary: Swift.Bool? = nil
        )
        {
            self.localizedName = localizedName
            self.primary = primary
        }
    }
}

extension GeoPlacesClientTypes {

    public enum GeocodeAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case timeZone
        case sdkUnknown(Swift.String)

        public static var allCases: [GeocodeAdditionalFeature] {
            return [
                .timeZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .timeZone: return "TimeZone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public enum GeocodeFilterPlaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case block
        case country
        case district
        case interpolatedAddress
        case intersection
        case locality
        case pointAddress
        case pointOfInterest
        case postalCodeArea
        case postalCodePoint
        case region
        case street
        case subBlock
        case subDistrict
        case subRegion
        case sdkUnknown(Swift.String)

        public static var allCases: [GeocodeFilterPlaceType] {
            return [
                .block,
                .country,
                .district,
                .interpolatedAddress,
                .intersection,
                .locality,
                .pointAddress,
                .pointOfInterest,
                .postalCodeArea,
                .postalCodePoint,
                .region,
                .street,
                .subBlock,
                .subDistrict,
                .subRegion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .block: return "Block"
            case .country: return "Country"
            case .district: return "District"
            case .interpolatedAddress: return "InterpolatedAddress"
            case .intersection: return "Intersection"
            case .locality: return "Locality"
            case .pointAddress: return "PointAddress"
            case .pointOfInterest: return "PointOfInterest"
            case .postalCodeArea: return "PostalCodeArea"
            case .postalCodePoint: return "PostalCodePoint"
            case .region: return "Region"
            case .street: return "Street"
            case .subBlock: return "SubBlock"
            case .subDistrict: return "SubDistrict"
            case .subRegion: return "SubRegion"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public struct GeocodeFilter: Swift.Sendable {
        public var includeCountries: [Swift.String]?
        public var includePlaceTypes: [GeoPlacesClientTypes.GeocodeFilterPlaceType]?

        public init(
            includeCountries: [Swift.String]? = nil,
            includePlaceTypes: [GeoPlacesClientTypes.GeocodeFilterPlaceType]? = nil
        )
        {
            self.includeCountries = includeCountries
            self.includePlaceTypes = includePlaceTypes
        }
    }
}

extension GeoPlacesClientTypes {

    public struct GeocodeQueryComponents: Swift.Sendable {
        public var addressNumber: Swift.String?
        public var country: Swift.String?
        public var district: Swift.String?
        public var locality: Swift.String?
        public var postalCode: Swift.String?
        public var region: Swift.String?
        public var street: Swift.String?
        public var subRegion: Swift.String?

        public init(
            addressNumber: Swift.String? = nil,
            country: Swift.String? = nil,
            district: Swift.String? = nil,
            locality: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            region: Swift.String? = nil,
            street: Swift.String? = nil,
            subRegion: Swift.String? = nil
        )
        {
            self.addressNumber = addressNumber
            self.country = country
            self.district = district
            self.locality = locality
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subRegion = subRegion
        }
    }
}

extension GeoPlacesClientTypes.GeocodeQueryComponents: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeocodeQueryComponents(addressNumber: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", district: \"CONTENT_REDACTED\", locality: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", region: \"CONTENT_REDACTED\", street: \"CONTENT_REDACTED\", subRegion: \"CONTENT_REDACTED\")"}
}

public struct GeocodeInput: Swift.Sendable {
    public var additionalFeatures: [GeoPlacesClientTypes.GeocodeAdditionalFeature]?
    public var biasPosition: [Swift.Double]?
    public var filter: GeoPlacesClientTypes.GeocodeFilter?
    public var intendedUse: GeoPlacesClientTypes.IntendedUse?
    public var key: Swift.String?
    public var language: Swift.String?
    public var maxResults: Swift.Int?
    public var politicalView: Swift.String?
    public var queryComponents: GeoPlacesClientTypes.GeocodeQueryComponents?
    public var queryText: Swift.String?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.GeocodeAdditionalFeature]? = nil,
        biasPosition: [Swift.Double]? = nil,
        filter: GeoPlacesClientTypes.GeocodeFilter? = nil,
        intendedUse: GeoPlacesClientTypes.IntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        politicalView: Swift.String? = nil,
        queryComponents: GeoPlacesClientTypes.GeocodeQueryComponents? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.additionalFeatures = additionalFeatures
        self.biasPosition = biasPosition
        self.filter = filter
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.politicalView = politicalView
        self.queryComponents = queryComponents
        self.queryText = queryText
    }
}

extension GeocodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeocodeInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), filter: \(Swift.String(describing: filter)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), politicalView: \(Swift.String(describing: politicalView)), queryComponents: \(Swift.String(describing: queryComponents)), biasPosition: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", queryText: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public struct MatchScoreDetails: Swift.Sendable {
        public var components: GeoPlacesClientTypes.ComponentMatchScores?
        public var overall: Swift.Double

        public init(
            components: GeoPlacesClientTypes.ComponentMatchScores? = nil,
            overall: Swift.Double = 0.0
        )
        {
            self.components = components
            self.overall = overall
        }
    }
}

extension GeoPlacesClientTypes {

    public enum PostalAuthority: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case usps
        case sdkUnknown(Swift.String)

        public static var allCases: [PostalAuthority] {
            return [
                .usps
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .usps: return "Usps"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public enum PostalCodeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case uspsZip
        case uspsZipPlus4
        case sdkUnknown(Swift.String)

        public static var allCases: [PostalCodeType] {
            return [
                .uspsZip,
                .uspsZipPlus4
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .uspsZip: return "UspsZip"
            case .uspsZipPlus4: return "UspsZipPlus4"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public enum ZipClassificationCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case military
        case postOfficeBoxes
        case unique
        case sdkUnknown(Swift.String)

        public static var allCases: [ZipClassificationCode] {
            return [
                .military,
                .postOfficeBoxes,
                .unique
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .military: return "Military"
            case .postOfficeBoxes: return "PostOfficeBoxes"
            case .unique: return "Unique"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public struct UspsZip: Swift.Sendable {
        public var zipClassificationCode: GeoPlacesClientTypes.ZipClassificationCode?

        public init(
            zipClassificationCode: GeoPlacesClientTypes.ZipClassificationCode? = nil
        )
        {
            self.zipClassificationCode = zipClassificationCode
        }
    }
}

extension GeoPlacesClientTypes {

    public enum RecordTypeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case firm
        case general
        case highRise
        case postOfficeBox
        case rural
        case street
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordTypeCode] {
            return [
                .firm,
                .general,
                .highRise,
                .postOfficeBox,
                .rural,
                .street
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .firm: return "Firm"
            case .general: return "General"
            case .highRise: return "HighRise"
            case .postOfficeBox: return "PostOfficeBox"
            case .rural: return "Rural"
            case .street: return "Street"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public struct UspsZipPlus4: Swift.Sendable {
        public var recordTypeCode: GeoPlacesClientTypes.RecordTypeCode?

        public init(
            recordTypeCode: GeoPlacesClientTypes.RecordTypeCode? = nil
        )
        {
            self.recordTypeCode = recordTypeCode
        }
    }
}

extension GeoPlacesClientTypes {

    public struct PostalCodeDetails: Swift.Sendable {
        public var postalAuthority: GeoPlacesClientTypes.PostalAuthority?
        public var postalCode: Swift.String?
        public var postalCodeType: GeoPlacesClientTypes.PostalCodeType?
        public var uspsZip: GeoPlacesClientTypes.UspsZip?
        public var uspsZipPlus4: GeoPlacesClientTypes.UspsZipPlus4?

        public init(
            postalAuthority: GeoPlacesClientTypes.PostalAuthority? = nil,
            postalCode: Swift.String? = nil,
            postalCodeType: GeoPlacesClientTypes.PostalCodeType? = nil,
            uspsZip: GeoPlacesClientTypes.UspsZip? = nil,
            uspsZipPlus4: GeoPlacesClientTypes.UspsZipPlus4? = nil
        )
        {
            self.postalAuthority = postalAuthority
            self.postalCode = postalCode
            self.postalCodeType = postalCodeType
            self.uspsZip = uspsZip
            self.uspsZipPlus4 = uspsZipPlus4
        }
    }
}

extension GeoPlacesClientTypes {

    public struct TimeZone: Swift.Sendable {
        /// This member is required.
        public var name: Swift.String?
        public var offset: Swift.String?
        public var offsetSeconds: Swift.Int

        public init(
            name: Swift.String? = nil,
            offset: Swift.String? = nil,
            offsetSeconds: Swift.Int = 0
        )
        {
            self.name = name
            self.offset = offset
            self.offsetSeconds = offsetSeconds
        }
    }
}

extension GeoPlacesClientTypes {

    public struct GeocodeResultItem: Swift.Sendable {
        public var accessPoints: [GeoPlacesClientTypes.AccessPoint]?
        public var address: GeoPlacesClientTypes.Address?
        public var addressNumberCorrected: Swift.Bool?
        public var categories: [GeoPlacesClientTypes.Category]?
        public var distance: Swift.Int
        public var foodTypes: [GeoPlacesClientTypes.FoodType]?
        public var mapView: [Swift.Double]?
        public var matchScores: GeoPlacesClientTypes.MatchScoreDetails?
        /// This member is required.
        public var placeId: Swift.String?
        /// This member is required.
        public var placeType: GeoPlacesClientTypes.PlaceType?
        public var politicalView: Swift.String?
        public var position: [Swift.Double]?
        public var postalCodeDetails: [GeoPlacesClientTypes.PostalCodeDetails]?
        public var timeZone: GeoPlacesClientTypes.TimeZone?
        /// This member is required.
        public var title: Swift.String?

        public init(
            accessPoints: [GeoPlacesClientTypes.AccessPoint]? = nil,
            address: GeoPlacesClientTypes.Address? = nil,
            addressNumberCorrected: Swift.Bool? = nil,
            categories: [GeoPlacesClientTypes.Category]? = nil,
            distance: Swift.Int = 0,
            foodTypes: [GeoPlacesClientTypes.FoodType]? = nil,
            mapView: [Swift.Double]? = nil,
            matchScores: GeoPlacesClientTypes.MatchScoreDetails? = nil,
            placeId: Swift.String? = nil,
            placeType: GeoPlacesClientTypes.PlaceType? = nil,
            politicalView: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            postalCodeDetails: [GeoPlacesClientTypes.PostalCodeDetails]? = nil,
            timeZone: GeoPlacesClientTypes.TimeZone? = nil,
            title: Swift.String? = nil
        )
        {
            self.accessPoints = accessPoints
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.categories = categories
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.matchScores = matchScores
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.postalCodeDetails = postalCodeDetails
            self.timeZone = timeZone
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes.GeocodeResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeocodeResultItem(accessPoints: \(Swift.String(describing: accessPoints)), address: \(Swift.String(describing: address)), addressNumberCorrected: \(Swift.String(describing: addressNumberCorrected)), categories: \(Swift.String(describing: categories)), distance: \(Swift.String(describing: distance)), foodTypes: \(Swift.String(describing: foodTypes)), matchScores: \(Swift.String(describing: matchScores)), placeId: \(Swift.String(describing: placeId)), placeType: \(Swift.String(describing: placeType)), politicalView: \(Swift.String(describing: politicalView)), postalCodeDetails: \(Swift.String(describing: postalCodeDetails)), timeZone: \(Swift.String(describing: timeZone)), title: \(Swift.String(describing: title)), mapView: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

public struct GeocodeOutput: Swift.Sendable {
    /// This member is required.
    public var pricingBucket: Swift.String?
    public var resultItems: [GeoPlacesClientTypes.GeocodeResultItem]?

    public init(
        pricingBucket: Swift.String? = nil,
        resultItems: [GeoPlacesClientTypes.GeocodeResultItem]? = nil
    )
    {
        self.pricingBucket = pricingBucket
        self.resultItems = resultItems
    }
}

extension GeoPlacesClientTypes {

    public enum GetPlaceAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case phonemes
        case timeZone
        case sdkUnknown(Swift.String)

        public static var allCases: [GetPlaceAdditionalFeature] {
            return [
                .phonemes,
                .timeZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .phonemes: return "Phonemes"
            case .timeZone: return "TimeZone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetPlaceInput: Swift.Sendable {
    public var additionalFeatures: [GeoPlacesClientTypes.GetPlaceAdditionalFeature]?
    public var intendedUse: GeoPlacesClientTypes.IntendedUse?
    public var key: Swift.String?
    public var language: Swift.String?
    /// This member is required.
    public var placeId: Swift.String?
    public var politicalView: Swift.String?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.GetPlaceAdditionalFeature]? = nil,
        intendedUse: GeoPlacesClientTypes.IntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        placeId: Swift.String? = nil,
        politicalView: Swift.String? = nil
    )
    {
        self.additionalFeatures = additionalFeatures
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.placeId = placeId
        self.politicalView = politicalView
    }
}

extension GetPlaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPlaceInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), politicalView: \(Swift.String(describing: politicalView)), key: \"CONTENT_REDACTED\", placeId: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public struct OpeningHoursComponents: Swift.Sendable {
        public var openDuration: Swift.String?
        public var openTime: Swift.String?
        public var recurrence: Swift.String?

        public init(
            openDuration: Swift.String? = nil,
            openTime: Swift.String? = nil,
            recurrence: Swift.String? = nil
        )
        {
            self.openDuration = openDuration
            self.openTime = openTime
            self.recurrence = recurrence
        }
    }
}

extension GeoPlacesClientTypes {

    public struct OpeningHours: Swift.Sendable {
        public var categories: [GeoPlacesClientTypes.Category]?
        public var components: [GeoPlacesClientTypes.OpeningHoursComponents]?
        public var display: [Swift.String]?
        public var openNow: Swift.Bool?

        public init(
            categories: [GeoPlacesClientTypes.Category]? = nil,
            components: [GeoPlacesClientTypes.OpeningHoursComponents]? = nil,
            display: [Swift.String]? = nil,
            openNow: Swift.Bool? = nil
        )
        {
            self.categories = categories
            self.components = components
            self.display = display
            self.openNow = openNow
        }
    }
}

extension GeoPlacesClientTypes {

    public struct PhonemeDetails: Swift.Sendable {
        public var address: GeoPlacesClientTypes.AddressComponentPhonemes?
        public var title: [GeoPlacesClientTypes.PhonemeTranscription]?

        public init(
            address: GeoPlacesClientTypes.AddressComponentPhonemes? = nil,
            title: [GeoPlacesClientTypes.PhonemeTranscription]? = nil
        )
        {
            self.address = address
            self.title = title
        }
    }
}

public struct GetPlaceOutput: Swift.Sendable {
    public var accessPoints: [GeoPlacesClientTypes.AccessPoint]?
    public var accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]?
    public var address: GeoPlacesClientTypes.Address?
    public var addressNumberCorrected: Swift.Bool?
    public var businessChains: [GeoPlacesClientTypes.BusinessChain]?
    public var categories: [GeoPlacesClientTypes.Category]?
    public var contacts: GeoPlacesClientTypes.Contacts?
    public var foodTypes: [GeoPlacesClientTypes.FoodType]?
    public var mapView: [Swift.Double]?
    public var openingHours: [GeoPlacesClientTypes.OpeningHours]?
    public var phonemes: GeoPlacesClientTypes.PhonemeDetails?
    /// This member is required.
    public var placeId: Swift.String?
    /// This member is required.
    public var placeType: GeoPlacesClientTypes.PlaceType?
    public var politicalView: Swift.String?
    public var position: [Swift.Double]?
    public var postalCodeDetails: [GeoPlacesClientTypes.PostalCodeDetails]?
    /// This member is required.
    public var pricingBucket: Swift.String?
    public var timeZone: GeoPlacesClientTypes.TimeZone?
    /// This member is required.
    public var title: Swift.String?

    public init(
        accessPoints: [GeoPlacesClientTypes.AccessPoint]? = nil,
        accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]? = nil,
        address: GeoPlacesClientTypes.Address? = nil,
        addressNumberCorrected: Swift.Bool? = nil,
        businessChains: [GeoPlacesClientTypes.BusinessChain]? = nil,
        categories: [GeoPlacesClientTypes.Category]? = nil,
        contacts: GeoPlacesClientTypes.Contacts? = nil,
        foodTypes: [GeoPlacesClientTypes.FoodType]? = nil,
        mapView: [Swift.Double]? = nil,
        openingHours: [GeoPlacesClientTypes.OpeningHours]? = nil,
        phonemes: GeoPlacesClientTypes.PhonemeDetails? = nil,
        placeId: Swift.String? = nil,
        placeType: GeoPlacesClientTypes.PlaceType? = nil,
        politicalView: Swift.String? = nil,
        position: [Swift.Double]? = nil,
        postalCodeDetails: [GeoPlacesClientTypes.PostalCodeDetails]? = nil,
        pricingBucket: Swift.String? = nil,
        timeZone: GeoPlacesClientTypes.TimeZone? = nil,
        title: Swift.String? = nil
    )
    {
        self.accessPoints = accessPoints
        self.accessRestrictions = accessRestrictions
        self.address = address
        self.addressNumberCorrected = addressNumberCorrected
        self.businessChains = businessChains
        self.categories = categories
        self.contacts = contacts
        self.foodTypes = foodTypes
        self.mapView = mapView
        self.openingHours = openingHours
        self.phonemes = phonemes
        self.placeId = placeId
        self.placeType = placeType
        self.politicalView = politicalView
        self.position = position
        self.postalCodeDetails = postalCodeDetails
        self.pricingBucket = pricingBucket
        self.timeZone = timeZone
        self.title = title
    }
}

extension GetPlaceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPlaceOutput(accessPoints: \(Swift.String(describing: accessPoints)), accessRestrictions: \(Swift.String(describing: accessRestrictions)), address: \(Swift.String(describing: address)), addressNumberCorrected: \(Swift.String(describing: addressNumberCorrected)), businessChains: \(Swift.String(describing: businessChains)), categories: \(Swift.String(describing: categories)), contacts: \(Swift.String(describing: contacts)), foodTypes: \(Swift.String(describing: foodTypes)), openingHours: \(Swift.String(describing: openingHours)), phonemes: \(Swift.String(describing: phonemes)), placeId: \(Swift.String(describing: placeId)), placeType: \(Swift.String(describing: placeType)), politicalView: \(Swift.String(describing: politicalView)), postalCodeDetails: \(Swift.String(describing: postalCodeDetails)), pricingBucket: \(Swift.String(describing: pricingBucket)), timeZone: \(Swift.String(describing: timeZone)), title: \(Swift.String(describing: title)), mapView: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public enum ReverseGeocodeAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case timeZone
        case sdkUnknown(Swift.String)

        public static var allCases: [ReverseGeocodeAdditionalFeature] {
            return [
                .timeZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .timeZone: return "TimeZone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public enum ReverseGeocodeFilterPlaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case block
        case country
        case district
        case interpolatedAddress
        case locality
        case pointAddress
        case pointOfInterest
        case postalCodeArea
        case postalCodePoint
        case region
        case street
        case subBlock
        case subDistrict
        case subRegion
        case sdkUnknown(Swift.String)

        public static var allCases: [ReverseGeocodeFilterPlaceType] {
            return [
                .block,
                .country,
                .district,
                .interpolatedAddress,
                .locality,
                .pointAddress,
                .pointOfInterest,
                .postalCodeArea,
                .postalCodePoint,
                .region,
                .street,
                .subBlock,
                .subDistrict,
                .subRegion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .block: return "Block"
            case .country: return "Country"
            case .district: return "District"
            case .interpolatedAddress: return "InterpolatedAddress"
            case .locality: return "Locality"
            case .pointAddress: return "PointAddress"
            case .pointOfInterest: return "PointOfInterest"
            case .postalCodeArea: return "PostalCodeArea"
            case .postalCodePoint: return "PostalCodePoint"
            case .region: return "Region"
            case .street: return "Street"
            case .subBlock: return "SubBlock"
            case .subDistrict: return "SubDistrict"
            case .subRegion: return "SubRegion"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public struct ReverseGeocodeFilter: Swift.Sendable {
        public var includePlaceTypes: [GeoPlacesClientTypes.ReverseGeocodeFilterPlaceType]?

        public init(
            includePlaceTypes: [GeoPlacesClientTypes.ReverseGeocodeFilterPlaceType]? = nil
        )
        {
            self.includePlaceTypes = includePlaceTypes
        }
    }
}

public struct ReverseGeocodeInput: Swift.Sendable {
    public var additionalFeatures: [GeoPlacesClientTypes.ReverseGeocodeAdditionalFeature]?
    public var filter: GeoPlacesClientTypes.ReverseGeocodeFilter?
    public var intendedUse: GeoPlacesClientTypes.IntendedUse?
    public var key: Swift.String?
    public var language: Swift.String?
    public var maxResults: Swift.Int?
    public var politicalView: Swift.String?
    /// This member is required.
    public var queryPosition: [Swift.Double]?
    public var queryRadius: Swift.Int?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.ReverseGeocodeAdditionalFeature]? = nil,
        filter: GeoPlacesClientTypes.ReverseGeocodeFilter? = nil,
        intendedUse: GeoPlacesClientTypes.IntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        politicalView: Swift.String? = nil,
        queryPosition: [Swift.Double]? = nil,
        queryRadius: Swift.Int? = 0
    )
    {
        self.additionalFeatures = additionalFeatures
        self.filter = filter
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.politicalView = politicalView
        self.queryPosition = queryPosition
        self.queryRadius = queryRadius
    }
}

extension ReverseGeocodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReverseGeocodeInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), filter: \(Swift.String(describing: filter)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), politicalView: \(Swift.String(describing: politicalView)), queryRadius: \(Swift.String(describing: queryRadius)), key: \"CONTENT_REDACTED\", queryPosition: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public struct ReverseGeocodeResultItem: Swift.Sendable {
        public var accessPoints: [GeoPlacesClientTypes.AccessPoint]?
        public var address: GeoPlacesClientTypes.Address?
        public var addressNumberCorrected: Swift.Bool?
        public var categories: [GeoPlacesClientTypes.Category]?
        public var distance: Swift.Int
        public var foodTypes: [GeoPlacesClientTypes.FoodType]?
        public var mapView: [Swift.Double]?
        /// This member is required.
        public var placeId: Swift.String?
        /// This member is required.
        public var placeType: GeoPlacesClientTypes.PlaceType?
        public var politicalView: Swift.String?
        public var position: [Swift.Double]?
        public var postalCodeDetails: [GeoPlacesClientTypes.PostalCodeDetails]?
        public var timeZone: GeoPlacesClientTypes.TimeZone?
        /// This member is required.
        public var title: Swift.String?

        public init(
            accessPoints: [GeoPlacesClientTypes.AccessPoint]? = nil,
            address: GeoPlacesClientTypes.Address? = nil,
            addressNumberCorrected: Swift.Bool? = nil,
            categories: [GeoPlacesClientTypes.Category]? = nil,
            distance: Swift.Int = 0,
            foodTypes: [GeoPlacesClientTypes.FoodType]? = nil,
            mapView: [Swift.Double]? = nil,
            placeId: Swift.String? = nil,
            placeType: GeoPlacesClientTypes.PlaceType? = nil,
            politicalView: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            postalCodeDetails: [GeoPlacesClientTypes.PostalCodeDetails]? = nil,
            timeZone: GeoPlacesClientTypes.TimeZone? = nil,
            title: Swift.String? = nil
        )
        {
            self.accessPoints = accessPoints
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.categories = categories
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.postalCodeDetails = postalCodeDetails
            self.timeZone = timeZone
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes.ReverseGeocodeResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReverseGeocodeResultItem(accessPoints: \(Swift.String(describing: accessPoints)), address: \(Swift.String(describing: address)), addressNumberCorrected: \(Swift.String(describing: addressNumberCorrected)), categories: \(Swift.String(describing: categories)), distance: \(Swift.String(describing: distance)), foodTypes: \(Swift.String(describing: foodTypes)), placeId: \(Swift.String(describing: placeId)), placeType: \(Swift.String(describing: placeType)), politicalView: \(Swift.String(describing: politicalView)), postalCodeDetails: \(Swift.String(describing: postalCodeDetails)), timeZone: \(Swift.String(describing: timeZone)), title: \(Swift.String(describing: title)), mapView: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

public struct ReverseGeocodeOutput: Swift.Sendable {
    /// This member is required.
    public var pricingBucket: Swift.String?
    public var resultItems: [GeoPlacesClientTypes.ReverseGeocodeResultItem]?

    public init(
        pricingBucket: Swift.String? = nil,
        resultItems: [GeoPlacesClientTypes.ReverseGeocodeResultItem]? = nil
    )
    {
        self.pricingBucket = pricingBucket
        self.resultItems = resultItems
    }
}

extension GeoPlacesClientTypes {

    public enum SearchNearbyAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case phonemes
        case timeZone
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchNearbyAdditionalFeature] {
            return [
                .phonemes,
                .timeZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .phonemes: return "Phonemes"
            case .timeZone: return "TimeZone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public struct SearchNearbyFilter: Swift.Sendable {
        public var boundingBox: [Swift.Double]?
        public var excludeBusinessChains: [Swift.String]?
        public var excludeCategories: [Swift.String]?
        public var excludeFoodTypes: [Swift.String]?
        public var includeBusinessChains: [Swift.String]?
        public var includeCategories: [Swift.String]?
        public var includeCountries: [Swift.String]?
        public var includeFoodTypes: [Swift.String]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            excludeBusinessChains: [Swift.String]? = nil,
            excludeCategories: [Swift.String]? = nil,
            excludeFoodTypes: [Swift.String]? = nil,
            includeBusinessChains: [Swift.String]? = nil,
            includeCategories: [Swift.String]? = nil,
            includeCountries: [Swift.String]? = nil,
            includeFoodTypes: [Swift.String]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.excludeBusinessChains = excludeBusinessChains
            self.excludeCategories = excludeCategories
            self.excludeFoodTypes = excludeFoodTypes
            self.includeBusinessChains = includeBusinessChains
            self.includeCategories = includeCategories
            self.includeCountries = includeCountries
            self.includeFoodTypes = includeFoodTypes
        }
    }
}

extension GeoPlacesClientTypes.SearchNearbyFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchNearbyFilter(excludeBusinessChains: \(Swift.String(describing: excludeBusinessChains)), excludeCategories: \(Swift.String(describing: excludeCategories)), excludeFoodTypes: \(Swift.String(describing: excludeFoodTypes)), includeBusinessChains: \(Swift.String(describing: includeBusinessChains)), includeCategories: \(Swift.String(describing: includeCategories)), includeCountries: \(Swift.String(describing: includeCountries)), includeFoodTypes: \(Swift.String(describing: includeFoodTypes)), boundingBox: \"CONTENT_REDACTED\")"}
}

public struct SearchNearbyInput: Swift.Sendable {
    public var additionalFeatures: [GeoPlacesClientTypes.SearchNearbyAdditionalFeature]?
    public var filter: GeoPlacesClientTypes.SearchNearbyFilter?
    public var intendedUse: GeoPlacesClientTypes.IntendedUse?
    public var key: Swift.String?
    public var language: Swift.String?
    public var maxResults: Swift.Int?
    public var politicalView: Swift.String?
    /// This member is required.
    public var queryPosition: [Swift.Double]?
    public var queryRadius: Swift.Int?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.SearchNearbyAdditionalFeature]? = nil,
        filter: GeoPlacesClientTypes.SearchNearbyFilter? = nil,
        intendedUse: GeoPlacesClientTypes.IntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        politicalView: Swift.String? = nil,
        queryPosition: [Swift.Double]? = nil,
        queryRadius: Swift.Int? = 0
    )
    {
        self.additionalFeatures = additionalFeatures
        self.filter = filter
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.politicalView = politicalView
        self.queryPosition = queryPosition
        self.queryRadius = queryRadius
    }
}

extension SearchNearbyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchNearbyInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), filter: \(Swift.String(describing: filter)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), politicalView: \(Swift.String(describing: politicalView)), queryRadius: \(Swift.String(describing: queryRadius)), key: \"CONTENT_REDACTED\", queryPosition: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public struct SearchNearbyResultItem: Swift.Sendable {
        public var accessPoints: [GeoPlacesClientTypes.AccessPoint]?
        public var accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]?
        public var address: GeoPlacesClientTypes.Address?
        public var addressNumberCorrected: Swift.Bool?
        public var businessChains: [GeoPlacesClientTypes.BusinessChain]?
        public var categories: [GeoPlacesClientTypes.Category]?
        public var contacts: GeoPlacesClientTypes.Contacts?
        public var distance: Swift.Int
        public var foodTypes: [GeoPlacesClientTypes.FoodType]?
        public var mapView: [Swift.Double]?
        public var openingHours: [GeoPlacesClientTypes.OpeningHours]?
        public var phonemes: GeoPlacesClientTypes.PhonemeDetails?
        /// This member is required.
        public var placeId: Swift.String?
        /// This member is required.
        public var placeType: GeoPlacesClientTypes.PlaceType?
        public var politicalView: Swift.String?
        public var position: [Swift.Double]?
        public var timeZone: GeoPlacesClientTypes.TimeZone?
        /// This member is required.
        public var title: Swift.String?

        public init(
            accessPoints: [GeoPlacesClientTypes.AccessPoint]? = nil,
            accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]? = nil,
            address: GeoPlacesClientTypes.Address? = nil,
            addressNumberCorrected: Swift.Bool? = nil,
            businessChains: [GeoPlacesClientTypes.BusinessChain]? = nil,
            categories: [GeoPlacesClientTypes.Category]? = nil,
            contacts: GeoPlacesClientTypes.Contacts? = nil,
            distance: Swift.Int = 0,
            foodTypes: [GeoPlacesClientTypes.FoodType]? = nil,
            mapView: [Swift.Double]? = nil,
            openingHours: [GeoPlacesClientTypes.OpeningHours]? = nil,
            phonemes: GeoPlacesClientTypes.PhonemeDetails? = nil,
            placeId: Swift.String? = nil,
            placeType: GeoPlacesClientTypes.PlaceType? = nil,
            politicalView: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            timeZone: GeoPlacesClientTypes.TimeZone? = nil,
            title: Swift.String? = nil
        )
        {
            self.accessPoints = accessPoints
            self.accessRestrictions = accessRestrictions
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.businessChains = businessChains
            self.categories = categories
            self.contacts = contacts
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.openingHours = openingHours
            self.phonemes = phonemes
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.timeZone = timeZone
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes.SearchNearbyResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchNearbyResultItem(accessPoints: \(Swift.String(describing: accessPoints)), accessRestrictions: \(Swift.String(describing: accessRestrictions)), address: \(Swift.String(describing: address)), addressNumberCorrected: \(Swift.String(describing: addressNumberCorrected)), businessChains: \(Swift.String(describing: businessChains)), categories: \(Swift.String(describing: categories)), contacts: \(Swift.String(describing: contacts)), distance: \(Swift.String(describing: distance)), foodTypes: \(Swift.String(describing: foodTypes)), openingHours: \(Swift.String(describing: openingHours)), phonemes: \(Swift.String(describing: phonemes)), placeId: \(Swift.String(describing: placeId)), placeType: \(Swift.String(describing: placeType)), politicalView: \(Swift.String(describing: politicalView)), timeZone: \(Swift.String(describing: timeZone)), title: \(Swift.String(describing: title)), mapView: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

public struct SearchNearbyOutput: Swift.Sendable {
    /// This member is required.
    public var pricingBucket: Swift.String?
    public var resultItems: [GeoPlacesClientTypes.SearchNearbyResultItem]?

    public init(
        pricingBucket: Swift.String? = nil,
        resultItems: [GeoPlacesClientTypes.SearchNearbyResultItem]? = nil
    )
    {
        self.pricingBucket = pricingBucket
        self.resultItems = resultItems
    }
}

extension GeoPlacesClientTypes {

    public enum SearchTextAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case phonemes
        case timeZone
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchTextAdditionalFeature] {
            return [
                .phonemes,
                .timeZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .phonemes: return "Phonemes"
            case .timeZone: return "TimeZone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public struct SearchTextFilter: Swift.Sendable {
        public var boundingBox: [Swift.Double]?
        public var circle: GeoPlacesClientTypes.FilterCircle?
        public var includeCountries: [Swift.String]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            circle: GeoPlacesClientTypes.FilterCircle? = nil,
            includeCountries: [Swift.String]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.circle = circle
            self.includeCountries = includeCountries
        }
    }
}

extension GeoPlacesClientTypes.SearchTextFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchTextFilter(includeCountries: \(Swift.String(describing: includeCountries)), boundingBox: \"CONTENT_REDACTED\", circle: \"CONTENT_REDACTED\")"}
}

public struct SearchTextInput: Swift.Sendable {
    public var additionalFeatures: [GeoPlacesClientTypes.SearchTextAdditionalFeature]?
    public var biasPosition: [Swift.Double]?
    public var filter: GeoPlacesClientTypes.SearchTextFilter?
    public var intendedUse: GeoPlacesClientTypes.IntendedUse?
    public var key: Swift.String?
    public var language: Swift.String?
    public var maxResults: Swift.Int?
    public var politicalView: Swift.String?
    public var queryId: Swift.String?
    public var queryText: Swift.String?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.SearchTextAdditionalFeature]? = nil,
        biasPosition: [Swift.Double]? = nil,
        filter: GeoPlacesClientTypes.SearchTextFilter? = nil,
        intendedUse: GeoPlacesClientTypes.IntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        politicalView: Swift.String? = nil,
        queryId: Swift.String? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.additionalFeatures = additionalFeatures
        self.biasPosition = biasPosition
        self.filter = filter
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.politicalView = politicalView
        self.queryId = queryId
        self.queryText = queryText
    }
}

extension SearchTextInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchTextInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), filter: \(Swift.String(describing: filter)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), politicalView: \(Swift.String(describing: politicalView)), biasPosition: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", queryId: \"CONTENT_REDACTED\", queryText: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public struct SearchTextResultItem: Swift.Sendable {
        public var accessPoints: [GeoPlacesClientTypes.AccessPoint]?
        public var accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]?
        public var address: GeoPlacesClientTypes.Address?
        public var addressNumberCorrected: Swift.Bool?
        public var businessChains: [GeoPlacesClientTypes.BusinessChain]?
        public var categories: [GeoPlacesClientTypes.Category]?
        public var contacts: GeoPlacesClientTypes.Contacts?
        public var distance: Swift.Int
        public var foodTypes: [GeoPlacesClientTypes.FoodType]?
        public var mapView: [Swift.Double]?
        public var openingHours: [GeoPlacesClientTypes.OpeningHours]?
        public var phonemes: GeoPlacesClientTypes.PhonemeDetails?
        /// This member is required.
        public var placeId: Swift.String?
        /// This member is required.
        public var placeType: GeoPlacesClientTypes.PlaceType?
        public var politicalView: Swift.String?
        public var position: [Swift.Double]?
        public var timeZone: GeoPlacesClientTypes.TimeZone?
        /// This member is required.
        public var title: Swift.String?

        public init(
            accessPoints: [GeoPlacesClientTypes.AccessPoint]? = nil,
            accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]? = nil,
            address: GeoPlacesClientTypes.Address? = nil,
            addressNumberCorrected: Swift.Bool? = nil,
            businessChains: [GeoPlacesClientTypes.BusinessChain]? = nil,
            categories: [GeoPlacesClientTypes.Category]? = nil,
            contacts: GeoPlacesClientTypes.Contacts? = nil,
            distance: Swift.Int = 0,
            foodTypes: [GeoPlacesClientTypes.FoodType]? = nil,
            mapView: [Swift.Double]? = nil,
            openingHours: [GeoPlacesClientTypes.OpeningHours]? = nil,
            phonemes: GeoPlacesClientTypes.PhonemeDetails? = nil,
            placeId: Swift.String? = nil,
            placeType: GeoPlacesClientTypes.PlaceType? = nil,
            politicalView: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            timeZone: GeoPlacesClientTypes.TimeZone? = nil,
            title: Swift.String? = nil
        )
        {
            self.accessPoints = accessPoints
            self.accessRestrictions = accessRestrictions
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.businessChains = businessChains
            self.categories = categories
            self.contacts = contacts
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.openingHours = openingHours
            self.phonemes = phonemes
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.timeZone = timeZone
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes.SearchTextResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchTextResultItem(accessPoints: \(Swift.String(describing: accessPoints)), accessRestrictions: \(Swift.String(describing: accessRestrictions)), address: \(Swift.String(describing: address)), addressNumberCorrected: \(Swift.String(describing: addressNumberCorrected)), businessChains: \(Swift.String(describing: businessChains)), categories: \(Swift.String(describing: categories)), contacts: \(Swift.String(describing: contacts)), distance: \(Swift.String(describing: distance)), foodTypes: \(Swift.String(describing: foodTypes)), openingHours: \(Swift.String(describing: openingHours)), phonemes: \(Swift.String(describing: phonemes)), placeId: \(Swift.String(describing: placeId)), placeType: \(Swift.String(describing: placeType)), politicalView: \(Swift.String(describing: politicalView)), timeZone: \(Swift.String(describing: timeZone)), title: \(Swift.String(describing: title)), mapView: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

public struct SearchTextOutput: Swift.Sendable {
    /// This member is required.
    public var pricingBucket: Swift.String?
    public var resultItems: [GeoPlacesClientTypes.SearchTextResultItem]?

    public init(
        pricingBucket: Swift.String? = nil,
        resultItems: [GeoPlacesClientTypes.SearchTextResultItem]? = nil
    )
    {
        self.pricingBucket = pricingBucket
        self.resultItems = resultItems
    }
}

extension GeoPlacesClientTypes {

    public enum SuggestAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case phonemes
        case timeZone
        case sdkUnknown(Swift.String)

        public static var allCases: [SuggestAdditionalFeature] {
            return [
                .phonemes,
                .timeZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .phonemes: return "Phonemes"
            case .timeZone: return "TimeZone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public struct SuggestFilter: Swift.Sendable {
        public var boundingBox: [Swift.Double]?
        public var circle: GeoPlacesClientTypes.FilterCircle?
        public var includeCountries: [Swift.String]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            circle: GeoPlacesClientTypes.FilterCircle? = nil,
            includeCountries: [Swift.String]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.circle = circle
            self.includeCountries = includeCountries
        }
    }
}

extension GeoPlacesClientTypes.SuggestFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuggestFilter(includeCountries: \(Swift.String(describing: includeCountries)), boundingBox: \"CONTENT_REDACTED\", circle: \"CONTENT_REDACTED\")"}
}

public struct SuggestInput: Swift.Sendable {
    public var additionalFeatures: [GeoPlacesClientTypes.SuggestAdditionalFeature]?
    public var biasPosition: [Swift.Double]?
    public var filter: GeoPlacesClientTypes.SuggestFilter?
    public var intendedUse: GeoPlacesClientTypes.IntendedUse?
    public var key: Swift.String?
    public var language: Swift.String?
    public var maxQueryRefinements: Swift.Int?
    public var maxResults: Swift.Int?
    public var politicalView: Swift.String?
    /// This member is required.
    public var queryText: Swift.String?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.SuggestAdditionalFeature]? = nil,
        biasPosition: [Swift.Double]? = nil,
        filter: GeoPlacesClientTypes.SuggestFilter? = nil,
        intendedUse: GeoPlacesClientTypes.IntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxQueryRefinements: Swift.Int? = nil,
        maxResults: Swift.Int? = nil,
        politicalView: Swift.String? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.additionalFeatures = additionalFeatures
        self.biasPosition = biasPosition
        self.filter = filter
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.maxQueryRefinements = maxQueryRefinements
        self.maxResults = maxResults
        self.politicalView = politicalView
        self.queryText = queryText
    }
}

extension SuggestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuggestInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), filter: \(Swift.String(describing: filter)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), maxQueryRefinements: \(Swift.String(describing: maxQueryRefinements)), maxResults: \(Swift.String(describing: maxResults)), politicalView: \(Swift.String(describing: politicalView)), biasPosition: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", queryText: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public struct QueryRefinement: Swift.Sendable {
        /// This member is required.
        public var endIndex: Swift.Int?
        /// This member is required.
        public var originalTerm: Swift.String?
        /// This member is required.
        public var refinedTerm: Swift.String?
        /// This member is required.
        public var startIndex: Swift.Int?

        public init(
            endIndex: Swift.Int? = nil,
            originalTerm: Swift.String? = nil,
            refinedTerm: Swift.String? = nil,
            startIndex: Swift.Int? = nil
        )
        {
            self.endIndex = endIndex
            self.originalTerm = originalTerm
            self.refinedTerm = refinedTerm
            self.startIndex = startIndex
        }
    }
}

extension GeoPlacesClientTypes {

    public struct SuggestAddressHighlights: Swift.Sendable {
        public var label: [GeoPlacesClientTypes.Highlight]?

        public init(
            label: [GeoPlacesClientTypes.Highlight]? = nil
        )
        {
            self.label = label
        }
    }
}

extension GeoPlacesClientTypes {

    public struct SuggestHighlights: Swift.Sendable {
        public var address: GeoPlacesClientTypes.SuggestAddressHighlights?
        public var title: [GeoPlacesClientTypes.Highlight]?

        public init(
            address: GeoPlacesClientTypes.SuggestAddressHighlights? = nil,
            title: [GeoPlacesClientTypes.Highlight]? = nil
        )
        {
            self.address = address
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes {

    public struct SuggestPlaceResult: Swift.Sendable {
        public var accessPoints: [GeoPlacesClientTypes.AccessPoint]?
        public var accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]?
        public var address: GeoPlacesClientTypes.Address?
        public var businessChains: [GeoPlacesClientTypes.BusinessChain]?
        public var categories: [GeoPlacesClientTypes.Category]?
        public var distance: Swift.Int
        public var foodTypes: [GeoPlacesClientTypes.FoodType]?
        public var mapView: [Swift.Double]?
        public var phonemes: GeoPlacesClientTypes.PhonemeDetails?
        public var placeId: Swift.String?
        public var placeType: GeoPlacesClientTypes.PlaceType?
        public var politicalView: Swift.String?
        public var position: [Swift.Double]?
        public var timeZone: GeoPlacesClientTypes.TimeZone?

        public init(
            accessPoints: [GeoPlacesClientTypes.AccessPoint]? = nil,
            accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]? = nil,
            address: GeoPlacesClientTypes.Address? = nil,
            businessChains: [GeoPlacesClientTypes.BusinessChain]? = nil,
            categories: [GeoPlacesClientTypes.Category]? = nil,
            distance: Swift.Int = 0,
            foodTypes: [GeoPlacesClientTypes.FoodType]? = nil,
            mapView: [Swift.Double]? = nil,
            phonemes: GeoPlacesClientTypes.PhonemeDetails? = nil,
            placeId: Swift.String? = nil,
            placeType: GeoPlacesClientTypes.PlaceType? = nil,
            politicalView: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            timeZone: GeoPlacesClientTypes.TimeZone? = nil
        )
        {
            self.accessPoints = accessPoints
            self.accessRestrictions = accessRestrictions
            self.address = address
            self.businessChains = businessChains
            self.categories = categories
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.phonemes = phonemes
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.timeZone = timeZone
        }
    }
}

extension GeoPlacesClientTypes.SuggestPlaceResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuggestPlaceResult(accessPoints: \(Swift.String(describing: accessPoints)), accessRestrictions: \(Swift.String(describing: accessRestrictions)), address: \(Swift.String(describing: address)), businessChains: \(Swift.String(describing: businessChains)), categories: \(Swift.String(describing: categories)), distance: \(Swift.String(describing: distance)), foodTypes: \(Swift.String(describing: foodTypes)), phonemes: \(Swift.String(describing: phonemes)), placeId: \(Swift.String(describing: placeId)), placeType: \(Swift.String(describing: placeType)), politicalView: \(Swift.String(describing: politicalView)), timeZone: \(Swift.String(describing: timeZone)), mapView: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public enum QueryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businessChain
        case category
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryType] {
            return [
                .businessChain,
                .category
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businessChain: return "BusinessChain"
            case .category: return "Category"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public struct SuggestQueryResult: Swift.Sendable {
        public var queryId: Swift.String?
        public var queryType: GeoPlacesClientTypes.QueryType?

        public init(
            queryId: Swift.String? = nil,
            queryType: GeoPlacesClientTypes.QueryType? = nil
        )
        {
            self.queryId = queryId
            self.queryType = queryType
        }
    }
}

extension GeoPlacesClientTypes {

    public enum SuggestResultItemType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case place
        case query
        case sdkUnknown(Swift.String)

        public static var allCases: [SuggestResultItemType] {
            return [
                .place,
                .query
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .place: return "Place"
            case .query: return "Query"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public struct SuggestResultItem: Swift.Sendable {
        public var highlights: GeoPlacesClientTypes.SuggestHighlights?
        public var place: GeoPlacesClientTypes.SuggestPlaceResult?
        public var query: GeoPlacesClientTypes.SuggestQueryResult?
        /// This member is required.
        public var suggestResultItemType: GeoPlacesClientTypes.SuggestResultItemType?
        /// This member is required.
        public var title: Swift.String?

        public init(
            highlights: GeoPlacesClientTypes.SuggestHighlights? = nil,
            place: GeoPlacesClientTypes.SuggestPlaceResult? = nil,
            query: GeoPlacesClientTypes.SuggestQueryResult? = nil,
            suggestResultItemType: GeoPlacesClientTypes.SuggestResultItemType? = nil,
            title: Swift.String? = nil
        )
        {
            self.highlights = highlights
            self.place = place
            self.query = query
            self.suggestResultItemType = suggestResultItemType
            self.title = title
        }
    }
}

public struct SuggestOutput: Swift.Sendable {
    /// This member is required.
    public var pricingBucket: Swift.String?
    public var queryRefinements: [GeoPlacesClientTypes.QueryRefinement]?
    public var resultItems: [GeoPlacesClientTypes.SuggestResultItem]?

    public init(
        pricingBucket: Swift.String? = nil,
        queryRefinements: [GeoPlacesClientTypes.QueryRefinement]? = nil,
        resultItems: [GeoPlacesClientTypes.SuggestResultItem]? = nil
    )
    {
        self.pricingBucket = pricingBucket
        self.queryRefinements = queryRefinements
        self.resultItems = resultItems
    }
}

extension AutocompleteInput {

    static func urlPathProvider(_ value: AutocompleteInput) -> Swift.String? {
        return "/autocomplete"
    }
}

extension AutocompleteInput {

    static func queryItemProvider(_ value: AutocompleteInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GeocodeInput {

    static func urlPathProvider(_ value: GeocodeInput) -> Swift.String? {
        return "/geocode"
    }
}

extension GeocodeInput {

    static func queryItemProvider(_ value: GeocodeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetPlaceInput {

    static func urlPathProvider(_ value: GetPlaceInput) -> Swift.String? {
        guard let placeId = value.placeId else {
            return nil
        }
        return "/place/\(placeId.urlPercentEncoding())"
    }
}

extension GetPlaceInput {

    static func queryItemProvider(_ value: GetPlaceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let intendedUse = value.intendedUse {
            let intendedUseQueryItem = Smithy.URIQueryItem(name: "intended-use".urlPercentEncoding(), value: Swift.String(intendedUse.rawValue).urlPercentEncoding())
            items.append(intendedUseQueryItem)
        }
        if let additionalFeatures = value.additionalFeatures {
            additionalFeatures.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "additional-features".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let language = value.language {
            let languageQueryItem = Smithy.URIQueryItem(name: "language".urlPercentEncoding(), value: Swift.String(language).urlPercentEncoding())
            items.append(languageQueryItem)
        }
        if let politicalView = value.politicalView {
            let politicalViewQueryItem = Smithy.URIQueryItem(name: "political-view".urlPercentEncoding(), value: Swift.String(politicalView).urlPercentEncoding())
            items.append(politicalViewQueryItem)
        }
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension ReverseGeocodeInput {

    static func urlPathProvider(_ value: ReverseGeocodeInput) -> Swift.String? {
        return "/reverse-geocode"
    }
}

extension ReverseGeocodeInput {

    static func queryItemProvider(_ value: ReverseGeocodeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SearchNearbyInput {

    static func urlPathProvider(_ value: SearchNearbyInput) -> Swift.String? {
        return "/search-nearby"
    }
}

extension SearchNearbyInput {

    static func queryItemProvider(_ value: SearchNearbyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SearchTextInput {

    static func urlPathProvider(_ value: SearchTextInput) -> Swift.String? {
        return "/search-text"
    }
}

extension SearchTextInput {

    static func queryItemProvider(_ value: SearchTextInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SuggestInput {

    static func urlPathProvider(_ value: SuggestInput) -> Swift.String? {
        return "/suggest"
    }
}

extension SuggestInput {

    static func queryItemProvider(_ value: SuggestInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension AutocompleteInput {

    static func write(value: AutocompleteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BiasPosition"].writeList(value.biasPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: GeoPlacesClientTypes.AutocompleteFilter.write(value:to:))
        try writer["IntendedUse"].write(value.intendedUse)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["PostalCodeMode"].write(value.postalCodeMode)
        try writer["QueryText"].write(value.queryText)
    }
}

extension GeocodeInput {

    static func write(value: GeocodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalFeatures"].writeList(value.additionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.GeocodeAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BiasPosition"].writeList(value.biasPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: GeoPlacesClientTypes.GeocodeFilter.write(value:to:))
        try writer["IntendedUse"].write(value.intendedUse)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["QueryComponents"].write(value.queryComponents, with: GeoPlacesClientTypes.GeocodeQueryComponents.write(value:to:))
        try writer["QueryText"].write(value.queryText)
    }
}

extension ReverseGeocodeInput {

    static func write(value: ReverseGeocodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalFeatures"].writeList(value.additionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.ReverseGeocodeAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: GeoPlacesClientTypes.ReverseGeocodeFilter.write(value:to:))
        try writer["IntendedUse"].write(value.intendedUse)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["QueryPosition"].writeList(value.queryPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QueryRadius"].write(value.queryRadius)
    }
}

extension SearchNearbyInput {

    static func write(value: SearchNearbyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalFeatures"].writeList(value.additionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.SearchNearbyAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: GeoPlacesClientTypes.SearchNearbyFilter.write(value:to:))
        try writer["IntendedUse"].write(value.intendedUse)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["QueryPosition"].writeList(value.queryPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QueryRadius"].write(value.queryRadius)
    }
}

extension SearchTextInput {

    static func write(value: SearchTextInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalFeatures"].writeList(value.additionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.SearchTextAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BiasPosition"].writeList(value.biasPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: GeoPlacesClientTypes.SearchTextFilter.write(value:to:))
        try writer["IntendedUse"].write(value.intendedUse)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["QueryId"].write(value.queryId)
        try writer["QueryText"].write(value.queryText)
    }
}

extension SuggestInput {

    static func write(value: SuggestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalFeatures"].writeList(value.additionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.SuggestAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BiasPosition"].writeList(value.biasPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: GeoPlacesClientTypes.SuggestFilter.write(value:to:))
        try writer["IntendedUse"].write(value.intendedUse)
        try writer["Language"].write(value.language)
        try writer["MaxQueryRefinements"].write(value.maxQueryRefinements)
        try writer["MaxResults"].write(value.maxResults)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["QueryText"].write(value.queryText)
    }
}

extension AutocompleteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AutocompleteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AutocompleteOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AutocompleteResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeocodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GeocodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GeocodeOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.GeocodeResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetPlaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPlaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPlaceOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessRestrictions = try reader["AccessRestrictions"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessRestriction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.addressNumberCorrected = try reader["AddressNumberCorrected"].readIfPresent()
        value.businessChains = try reader["BusinessChains"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.BusinessChain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.contacts = try reader["Contacts"].readIfPresent(with: GeoPlacesClientTypes.Contacts.read(from:))
        value.foodTypes = try reader["FoodTypes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.FoodType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mapView = try reader["MapView"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.openingHours = try reader["OpeningHours"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.OpeningHours.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.phonemes = try reader["Phonemes"].readIfPresent(with: GeoPlacesClientTypes.PhonemeDetails.read(from:))
        value.placeId = try reader["PlaceId"].readIfPresent() ?? ""
        value.placeType = try reader["PlaceType"].readIfPresent() ?? .sdkUnknown("")
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.postalCodeDetails = try reader["PostalCodeDetails"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PostalCodeDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeZone = try reader["TimeZone"].readIfPresent(with: GeoPlacesClientTypes.TimeZone.read(from:))
        value.title = try reader["Title"].readIfPresent() ?? ""
        return value
    }
}

extension ReverseGeocodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReverseGeocodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ReverseGeocodeOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.ReverseGeocodeResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchNearbyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchNearbyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchNearbyOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.SearchNearbyResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchTextOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchTextOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchTextOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.SearchTextResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SuggestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SuggestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SuggestOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.queryRefinements = try reader["QueryRefinements"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.QueryRefinement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.SuggestResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

enum AutocompleteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GeocodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPlaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReverseGeocodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchNearbyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchTextOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SuggestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GeoPlacesClientTypes.AutocompleteResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AutocompleteResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AutocompleteResultItem()
        value.placeId = try reader["PlaceId"].readIfPresent() ?? ""
        value.placeType = try reader["PlaceType"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.language = try reader["Language"].readIfPresent()
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.highlights = try reader["Highlights"].readIfPresent(with: GeoPlacesClientTypes.AutocompleteHighlights.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.AutocompleteHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AutocompleteHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AutocompleteHighlights()
        value.title = try reader["Title"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.AutocompleteAddressHighlights.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.AutocompleteAddressHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AutocompleteAddressHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AutocompleteAddressHighlights()
        value.label = try reader["Label"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.country = try reader["Country"].readIfPresent(with: GeoPlacesClientTypes.CountryHighlights.read(from:))
        value.region = try reader["Region"].readIfPresent(with: GeoPlacesClientTypes.RegionHighlights.read(from:))
        value.subRegion = try reader["SubRegion"].readIfPresent(with: GeoPlacesClientTypes.SubRegionHighlights.read(from:))
        value.locality = try reader["Locality"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.district = try reader["District"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subDistrict = try reader["SubDistrict"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.street = try reader["Street"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.block = try reader["Block"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subBlock = try reader["SubBlock"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.postalCode = try reader["PostalCode"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.addressNumber = try reader["AddressNumber"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.building = try reader["Building"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.Highlight {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.Highlight {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.Highlight()
        value.startIndex = try reader["StartIndex"].readIfPresent()
        value.endIndex = try reader["EndIndex"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.SubRegionHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SubRegionHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SubRegionHighlights()
        value.code = try reader["Code"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.RegionHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.RegionHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.RegionHighlights()
        value.code = try reader["Code"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.CountryHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.CountryHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.CountryHighlights()
        value.code = try reader["Code"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.Address {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.Address {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.Address()
        value.label = try reader["Label"].readIfPresent()
        value.country = try reader["Country"].readIfPresent(with: GeoPlacesClientTypes.Country.read(from:))
        value.region = try reader["Region"].readIfPresent(with: GeoPlacesClientTypes.Region.read(from:))
        value.subRegion = try reader["SubRegion"].readIfPresent(with: GeoPlacesClientTypes.SubRegion.read(from:))
        value.locality = try reader["Locality"].readIfPresent()
        value.district = try reader["District"].readIfPresent()
        value.subDistrict = try reader["SubDistrict"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        value.block = try reader["Block"].readIfPresent()
        value.subBlock = try reader["SubBlock"].readIfPresent()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.street = try reader["Street"].readIfPresent()
        value.streetComponents = try reader["StreetComponents"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.StreetComponents.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.addressNumber = try reader["AddressNumber"].readIfPresent()
        value.building = try reader["Building"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.StreetComponents {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.StreetComponents {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.StreetComponents()
        value.baseName = try reader["BaseName"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.typePlacement = try reader["TypePlacement"].readIfPresent()
        value.typeSeparator = try reader["TypeSeparator"].readIfPresent()
        value.`prefix` = try reader["Prefix"].readIfPresent()
        value.suffix = try reader["Suffix"].readIfPresent()
        value.direction = try reader["Direction"].readIfPresent()
        value.language = try reader["Language"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.SubRegion {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SubRegion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SubRegion()
        value.code = try reader["Code"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.Region {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.Region {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.Region()
        value.code = try reader["Code"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.Country {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.Country {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.Country()
        value.code2 = try reader["Code2"].readIfPresent()
        value.code3 = try reader["Code3"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.GeocodeResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.GeocodeResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.GeocodeResultItem()
        value.placeId = try reader["PlaceId"].readIfPresent() ?? ""
        value.placeType = try reader["PlaceType"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.addressNumberCorrected = try reader["AddressNumberCorrected"].readIfPresent()
        value.postalCodeDetails = try reader["PostalCodeDetails"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PostalCodeDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.mapView = try reader["MapView"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.foodTypes = try reader["FoodTypes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.FoodType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeZone = try reader["TimeZone"].readIfPresent(with: GeoPlacesClientTypes.TimeZone.read(from:))
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.matchScores = try reader["MatchScores"].readIfPresent(with: GeoPlacesClientTypes.MatchScoreDetails.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.MatchScoreDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.MatchScoreDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.MatchScoreDetails()
        value.overall = try reader["Overall"].readIfPresent() ?? 0
        value.components = try reader["Components"].readIfPresent(with: GeoPlacesClientTypes.ComponentMatchScores.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.ComponentMatchScores {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.ComponentMatchScores {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.ComponentMatchScores()
        value.title = try reader["Title"].readIfPresent() ?? 0
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.AddressComponentMatchScores.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.AddressComponentMatchScores {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AddressComponentMatchScores {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AddressComponentMatchScores()
        value.country = try reader["Country"].readIfPresent() ?? 0
        value.region = try reader["Region"].readIfPresent() ?? 0
        value.subRegion = try reader["SubRegion"].readIfPresent() ?? 0
        value.locality = try reader["Locality"].readIfPresent() ?? 0
        value.district = try reader["District"].readIfPresent() ?? 0
        value.subDistrict = try reader["SubDistrict"].readIfPresent() ?? 0
        value.postalCode = try reader["PostalCode"].readIfPresent() ?? 0
        value.block = try reader["Block"].readIfPresent() ?? 0
        value.subBlock = try reader["SubBlock"].readIfPresent() ?? 0
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.addressNumber = try reader["AddressNumber"].readIfPresent() ?? 0
        value.building = try reader["Building"].readIfPresent() ?? 0
        return value
    }
}

extension GeoPlacesClientTypes.TimeZone {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.TimeZone {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.TimeZone()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.offset = try reader["Offset"].readIfPresent()
        value.offsetSeconds = try reader["OffsetSeconds"].readIfPresent() ?? 0
        return value
    }
}

extension GeoPlacesClientTypes.AccessPoint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AccessPoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AccessPoint()
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.FoodType {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.FoodType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.FoodType()
        value.localizedName = try reader["LocalizedName"].readIfPresent() ?? ""
        value.primary = try reader["Primary"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.Category {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.Category {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.Category()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.localizedName = try reader["LocalizedName"].readIfPresent()
        value.primary = try reader["Primary"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.PostalCodeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.PostalCodeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.PostalCodeDetails()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        value.postalAuthority = try reader["PostalAuthority"].readIfPresent()
        value.postalCodeType = try reader["PostalCodeType"].readIfPresent()
        value.uspsZip = try reader["UspsZip"].readIfPresent(with: GeoPlacesClientTypes.UspsZip.read(from:))
        value.uspsZipPlus4 = try reader["UspsZipPlus4"].readIfPresent(with: GeoPlacesClientTypes.UspsZipPlus4.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.UspsZipPlus4 {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.UspsZipPlus4 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.UspsZipPlus4()
        value.recordTypeCode = try reader["RecordTypeCode"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.UspsZip {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.UspsZip {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.UspsZip()
        value.zipClassificationCode = try reader["ZipClassificationCode"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.BusinessChain {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.BusinessChain {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.BusinessChain()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.Contacts {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.Contacts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.Contacts()
        value.phones = try reader["Phones"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.ContactDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.faxes = try reader["Faxes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.ContactDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.websites = try reader["Websites"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.ContactDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.emails = try reader["Emails"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.ContactDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.ContactDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.ContactDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.ContactDetails()
        value.label = try reader["Label"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.OpeningHours {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.OpeningHours {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.OpeningHours()
        value.display = try reader["Display"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.openNow = try reader["OpenNow"].readIfPresent()
        value.components = try reader["Components"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.OpeningHoursComponents.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.OpeningHoursComponents {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.OpeningHoursComponents {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.OpeningHoursComponents()
        value.openTime = try reader["OpenTime"].readIfPresent()
        value.openDuration = try reader["OpenDuration"].readIfPresent()
        value.recurrence = try reader["Recurrence"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.AccessRestriction {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AccessRestriction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AccessRestriction()
        value.restricted = try reader["Restricted"].readIfPresent()
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.PhonemeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.PhonemeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.PhonemeDetails()
        value.title = try reader["Title"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.AddressComponentPhonemes.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.AddressComponentPhonemes {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AddressComponentPhonemes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AddressComponentPhonemes()
        value.country = try reader["Country"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.region = try reader["Region"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subRegion = try reader["SubRegion"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.locality = try reader["Locality"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.district = try reader["District"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subDistrict = try reader["SubDistrict"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.block = try reader["Block"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subBlock = try reader["SubBlock"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.street = try reader["Street"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.PhonemeTranscription {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.PhonemeTranscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.PhonemeTranscription()
        value.value = try reader["Value"].readIfPresent()
        value.language = try reader["Language"].readIfPresent()
        value.preferred = try reader["Preferred"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.ReverseGeocodeResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.ReverseGeocodeResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.ReverseGeocodeResultItem()
        value.placeId = try reader["PlaceId"].readIfPresent() ?? ""
        value.placeType = try reader["PlaceType"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.addressNumberCorrected = try reader["AddressNumberCorrected"].readIfPresent()
        value.postalCodeDetails = try reader["PostalCodeDetails"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PostalCodeDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.mapView = try reader["MapView"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.foodTypes = try reader["FoodTypes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.FoodType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeZone = try reader["TimeZone"].readIfPresent(with: GeoPlacesClientTypes.TimeZone.read(from:))
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.SearchNearbyResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SearchNearbyResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SearchNearbyResultItem()
        value.placeId = try reader["PlaceId"].readIfPresent() ?? ""
        value.placeType = try reader["PlaceType"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.addressNumberCorrected = try reader["AddressNumberCorrected"].readIfPresent()
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.mapView = try reader["MapView"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.foodTypes = try reader["FoodTypes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.FoodType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.businessChains = try reader["BusinessChains"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.BusinessChain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.contacts = try reader["Contacts"].readIfPresent(with: GeoPlacesClientTypes.Contacts.read(from:))
        value.openingHours = try reader["OpeningHours"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.OpeningHours.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessRestrictions = try reader["AccessRestrictions"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessRestriction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeZone = try reader["TimeZone"].readIfPresent(with: GeoPlacesClientTypes.TimeZone.read(from:))
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.phonemes = try reader["Phonemes"].readIfPresent(with: GeoPlacesClientTypes.PhonemeDetails.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.SearchTextResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SearchTextResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SearchTextResultItem()
        value.placeId = try reader["PlaceId"].readIfPresent() ?? ""
        value.placeType = try reader["PlaceType"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.addressNumberCorrected = try reader["AddressNumberCorrected"].readIfPresent()
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.mapView = try reader["MapView"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.foodTypes = try reader["FoodTypes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.FoodType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.businessChains = try reader["BusinessChains"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.BusinessChain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.contacts = try reader["Contacts"].readIfPresent(with: GeoPlacesClientTypes.Contacts.read(from:))
        value.openingHours = try reader["OpeningHours"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.OpeningHours.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessRestrictions = try reader["AccessRestrictions"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessRestriction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeZone = try reader["TimeZone"].readIfPresent(with: GeoPlacesClientTypes.TimeZone.read(from:))
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.phonemes = try reader["Phonemes"].readIfPresent(with: GeoPlacesClientTypes.PhonemeDetails.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.SuggestResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SuggestResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SuggestResultItem()
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.suggestResultItemType = try reader["SuggestResultItemType"].readIfPresent() ?? .sdkUnknown("")
        value.place = try reader["Place"].readIfPresent(with: GeoPlacesClientTypes.SuggestPlaceResult.read(from:))
        value.query = try reader["Query"].readIfPresent(with: GeoPlacesClientTypes.SuggestQueryResult.read(from:))
        value.highlights = try reader["Highlights"].readIfPresent(with: GeoPlacesClientTypes.SuggestHighlights.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.SuggestHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SuggestHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SuggestHighlights()
        value.title = try reader["Title"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.SuggestAddressHighlights.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.SuggestAddressHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SuggestAddressHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SuggestAddressHighlights()
        value.label = try reader["Label"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.SuggestQueryResult {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SuggestQueryResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SuggestQueryResult()
        value.queryId = try reader["QueryId"].readIfPresent()
        value.queryType = try reader["QueryType"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.SuggestPlaceResult {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SuggestPlaceResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SuggestPlaceResult()
        value.placeId = try reader["PlaceId"].readIfPresent()
        value.placeType = try reader["PlaceType"].readIfPresent()
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.mapView = try reader["MapView"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.foodTypes = try reader["FoodTypes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.FoodType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.businessChains = try reader["BusinessChains"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.BusinessChain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessRestrictions = try reader["AccessRestrictions"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessRestriction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeZone = try reader["TimeZone"].readIfPresent(with: GeoPlacesClientTypes.TimeZone.read(from:))
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.phonemes = try reader["Phonemes"].readIfPresent(with: GeoPlacesClientTypes.PhonemeDetails.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.QueryRefinement {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.QueryRefinement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.QueryRefinement()
        value.refinedTerm = try reader["RefinedTerm"].readIfPresent() ?? ""
        value.originalTerm = try reader["OriginalTerm"].readIfPresent() ?? ""
        value.startIndex = try reader["StartIndex"].readIfPresent() ?? 0
        value.endIndex = try reader["EndIndex"].readIfPresent() ?? 0
        return value
    }
}

extension GeoPlacesClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension GeoPlacesClientTypes.AutocompleteFilter {

    static func write(value: GeoPlacesClientTypes.AutocompleteFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Circle"].write(value.circle, with: GeoPlacesClientTypes.FilterCircle.write(value:to:))
        try writer["IncludeCountries"].writeList(value.includeCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludePlaceTypes"].writeList(value.includePlaceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.AutocompleteFilterPlaceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoPlacesClientTypes.FilterCircle {

    static func write(value: GeoPlacesClientTypes.FilterCircle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Center"].writeList(value.center, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Radius"].write(value.radius)
    }
}

extension GeoPlacesClientTypes.GeocodeQueryComponents {

    static func write(value: GeoPlacesClientTypes.GeocodeQueryComponents?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressNumber"].write(value.addressNumber)
        try writer["Country"].write(value.country)
        try writer["District"].write(value.district)
        try writer["Locality"].write(value.locality)
        try writer["PostalCode"].write(value.postalCode)
        try writer["Region"].write(value.region)
        try writer["Street"].write(value.street)
        try writer["SubRegion"].write(value.subRegion)
    }
}

extension GeoPlacesClientTypes.GeocodeFilter {

    static func write(value: GeoPlacesClientTypes.GeocodeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludeCountries"].writeList(value.includeCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludePlaceTypes"].writeList(value.includePlaceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.GeocodeFilterPlaceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoPlacesClientTypes.ReverseGeocodeFilter {

    static func write(value: GeoPlacesClientTypes.ReverseGeocodeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludePlaceTypes"].writeList(value.includePlaceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.ReverseGeocodeFilterPlaceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoPlacesClientTypes.SearchNearbyFilter {

    static func write(value: GeoPlacesClientTypes.SearchNearbyFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExcludeBusinessChains"].writeList(value.excludeBusinessChains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExcludeCategories"].writeList(value.excludeCategories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExcludeFoodTypes"].writeList(value.excludeFoodTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeBusinessChains"].writeList(value.includeBusinessChains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeCategories"].writeList(value.includeCategories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeCountries"].writeList(value.includeCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeFoodTypes"].writeList(value.includeFoodTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoPlacesClientTypes.SearchTextFilter {

    static func write(value: GeoPlacesClientTypes.SearchTextFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Circle"].write(value.circle, with: GeoPlacesClientTypes.FilterCircle.write(value:to:))
        try writer["IncludeCountries"].writeList(value.includeCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoPlacesClientTypes.SuggestFilter {

    static func write(value: GeoPlacesClientTypes.SuggestFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Circle"].write(value.circle, with: GeoPlacesClientTypes.FilterCircle.write(value:to:))
        try writer["IncludeCountries"].writeList(value.includeCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum GeoPlacesClientTypes {}
